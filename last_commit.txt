Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-03-21T22:08:12+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.outputfilters/commit/813a145e7791ebe91a9bc7cb98c4f5d887963ffc

start dealing with sgmllib in py3 (TODO: port to BS4)

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 18da6c7..20eace8 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -8,8 +8,6 @@\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n-from sgmllib import SGMLParseError\n-from sgmllib import SGMLParser\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n@@ -27,6 +25,20 @@\n import re\n import six\n \n+try:\n+    from sgmllib import SGMLParseError\n+    from sgmllib import SGMLParser\n+except ImportError:\n+    # This is probably Python 3, which doesn't include sgmllib anymore\n+    _SGML_AVAILABLE = 0\n+\n+    # Mock sgmllib enough to allow subclassing later on\n+    class SGMLParser(object):\n+        pass\n+\n+    class SGMLParseError(object):\n+        pass\n+\n \n HAS_LINGUAPLONE = True\n try:\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-03-22T17:20:24+01:00
Author: Tobias Herp (tobiasherp) <tobias.herp@visaplan.com>
Commit: https://github.com/plone/plone.outputfilters/commit/e8cbb34423db36d2f96313cba83ec51b9c19d95a

updated .gitignore

Added 3 lines

Files changed:
M .gitignore

b'diff --git a/.gitignore b/.gitignore\nindex 67a7ae8..48f1ce2 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -9,3 +9,6 @@ include/\n parts/\n .installed.cfg\n develop-eggs/\n+eggs/\n+local/\n+pip-selfcheck.json\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-03-23T10:22:24+01:00
Author: Tobias Herp (tobiasherp) <tobias.herp@visaplan.com>
Commit: https://github.com/plone/plone.outputfilters/commit/de3a7cef050c5c785fe437e5ed411b9c782543dc

Merge branch 'master' into issue27

Files changed:
M buildout.cfg

b'diff --git a/buildout.cfg b/buildout.cfg\nindex 0673a58..52c5ba2 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -3,6 +3,7 @@ extends =\n     http://dist.plone.org/release/5.0.6/versions.cfg\n develop = .\n parts = test\n+index = https://pypi.python.org/simple\n \n [versions]\n plone.outputfilters =\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-03-23T13:57:16+01:00
Author: Tobias Herp (tobiasherp) <tobias.herp@visaplan.com>
Commit: https://github.com/plone/plone.outputfilters/commit/d00945af2e6c81df36eb3e1dae9634c022557222

use BeautifulSoup 4 instead of SGMLParser (WIP)

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py
M setup.py

b'diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 20eace8..7e09dd1 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+# reimplementation, based on lxml instead of SGMLParser\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n@@ -8,6 +9,8 @@\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n+from bs4 import BeautifulSoup\n+# ... import exception class \n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n@@ -73,7 +76,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(SGMLParser):\n+class ResolveUIDAndCaptionFilter(HTMLParser):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -82,13 +85,9 @@ class ResolveUIDAndCaptionFilter(SGMLParser):\n         \'source\', \'track\', \'wbr\'])\n \n     def __init__(self, context=None, request=None):\n-        SGMLParser.__init__(self)\n         self.current_status = None\n         self.context = context\n         self.request = request\n-        self.pieces = []\n-        self.in_link = False\n-        self.in_script = False\n \n     # IFilter implementation\n     order = 800\n@@ -126,43 +125,70 @@ def _shorttag_replace(self, match):\n             return \'<\' + tag + \'></\' + tag + \'>\'\n \n     def __call__(self, data):\n+        # from SGMLParser implementation; still necessary?\n         data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        self.feed(data)\n-        self.close()\n-        return self.getResult()\n+        soup = BeautifulSoup(data, \'lxml\')\n \n-    # SGMLParser implementation\n-\n-    def append_data(self, data, add_eol=0):\n-        """Append data unmodified to self.data, add_eol adds a newline\n-        character"""\n-        if add_eol:\n-            data += \'\\n\'\n-        self.pieces.append(data)\n-\n-    def handle_charref(self, ref):\n-        """ Handle characters, just add them again """\n-        self.append_data("&#%s;" % ref)\n-\n-    def handle_entityref(self, ref):\n-        """ Handle html entities, put them back as we get them """\n-        self.append_data("&%s;" % ref)\n-\n-    def handle_data(self, text):\n-        """ Add data unmodified """\n-        self.append_data(text)\n+        for elem in soup.find_all([\'a\', \'area\'], \'href\'):\n+            attributes = elem.attrs\n+            href = attributes[\'href\']\n+            changed = False\n+            if 1:\n+                scheme = urlsplit(href)[0]\n+                if not scheme and not href.startswith(\'/\') \\\n+                        and not href.startswith(\'mailto<\') \\\n+                        and not href.startswith(\'mailto:\') \\\n+                        and not href.startswith(\'tel:\') \\\n+                        and not href.startswith(\'#\'):\n+                    obj, subpath, appendix = self.resolve_link(href)\n+                    if obj is not None:\n+                        href = obj.absolute_url()\n+                        if subpath:\n+                            href += \'/\' + subpath\n+                        href += appendix\n+                        changed = True\n+                    elif resolveuid_re.match(href) is None:\n+                        # absolutize relative URIs; this text isn\'t necessarily\n+                        # being rendered in the context where it was stored\n+                        relative_root = self.context\n+                        if not getattr(\n+                                self.context, \'isPrincipiaFolderish\', False):\n+                            relative_root = aq_parent(self.context)\n+                        actual_url = relative_root.absolute_url()\n+                        href = urljoin(actual_url + \'/\', subpath) + appendix\n+                        changed = True\n+                    if not changed:\n+                        continue\n+                    attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\', \'src\'):\n+            attributes = elem.attrs\n+            if 1:\n+                src = attributes.get(\'src\', \'\')\n+                image, fullimage, src, description = self.resolve_image(src)\n+                attributes["src"] = src\n \n-    def handle_comment(self, text):\n-        """ Handle comments unmodified """\n-        self.append_data("<!--%s-->" % text)\n+                if fullimage is not None:\n+                    # Check to see if the alt / title tags need setting\n+                    title = aq_acquire(fullimage, \'Title\')()\n+                    if not attributes.get(\'alt\'):\n+                        # XXX alt attribute contains *alternate* text \n+                        attributes[\'alt\'] = description or title\n+                    if \'title\' not in attributes:\n+                        attributes[\'title\'] = title\n \n-    def handle_pi(self, text):\n-        """ Handle processing instructions unmodified"""\n-        self.append_data("<?%s>" % text)\n+                caption = description\n+                # Check if the image needs to be captioned\n+                if (\n+                    self.captioned_images and\n+                    image is not None and\n+                    caption and\n+                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n+                ):\n+                    self.handle_captioned_image(attributes, image, fullimage,\n+                                                elem, soup,\n+                                                caption)\n \n-    def handle_decl(self, text):\n-        """Handle declarations unmodified """\n-        self.append_data("<!%s>" % text)\n+        return six.text_type(soup)\n \n     def lookup_uid(self, uid):\n         context = self.context\n@@ -280,8 +306,13 @@ def traverse_path(base, path):\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n-    def handle_captioned_image(self, attributes, image, fullimage, caption):\n+    def handle_captioned_image(self, attributes, image, fullimage,\n+                               elem, soup,\n+                               caption):\n         """Handle captioned image.\n+\n+        The img element is replaced by a definition list\n+        as created by the template ../browser/captioned_image.pt\n         """\n         klass = attributes[\'class\']\n         del attributes[\'class\']\n@@ -325,9 +356,16 @@ def handle_captioned_image(self, attributes, image, fullimage, caption):\n             options[\'isfullsize\'] = True\n \n         captioned_html = self.captioned_image_template(**options)\n-        if isinstance(captioned_html, six.text_type):\n-            captioned_html = captioned_html.encode(\'utf8\')\n-        self.append_data(captioned_html)\n+        new_elem = soup.new_tag\n+        if not options[\'isfullsize\']:\n+            a_elem = soup.new_tag(\'a\',\n+                                  rel=\'lightbox\',\n+                                  href=options[\'url_path\'])\n+            elem = elem.wrap(a_elem)\n+        dt = elem.wrap(soup.new_tag(\'dt\')\n+        dl = dt.wrap(soup.new_tag(\'dl\', class_=klass))\n+        dl.append(soup.new_tag(\'dd\', options[\'caption\'])\n+        elem.replace_with(dl)\n \n     def unknown_starttag(self, tag, attrs):\n         """Here we\'ve got the actual conversion of links and images.\n@@ -426,8 +464,8 @@ def parse_declaration(self, i):\n             self.append_data("<![CDATA[%s]]>" % data)\n         else:\n             try:\n-                j = SGMLParser.parse_declaration(self, i)\n-            except SGMLParseError:\n+                j = HTMLParser.parse_declaration(self, i)\n+            except HTMLParseError:\n                 toHandle = self.rawdata[i:]\n                 self.handle_data(toHandle)\n                 j = i + len(toHandle)\ndiff --git a/setup.py b/setup.py\nindex d784892..b21ab22 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,6 +43,8 @@\n           \'setuptools\',\n           \'six\',\n           \'unidecode\',\n+          \'beautifulsoup4\',\n+          \'lxml\',\n       ],\n       extras_require={\n           \'test\': [\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-03-23T14:53:47+01:00
Author: Tobias Herp (tobiasherp) <tobias.herp@visaplan.com>
Commit: https://github.com/plone/plone.outputfilters/commit/baf79cb8fbfb53269d355389af52efb2d5ac2999

Merge branch 'python3-therp' of github.com:plone/plone.outputfilters into python3-therp

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py
M setup.py

b'diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 18da6c7..7e09dd1 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+# reimplementation, based on lxml instead of SGMLParser\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n@@ -8,8 +9,8 @@\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n-from sgmllib import SGMLParseError\n-from sgmllib import SGMLParser\n+from bs4 import BeautifulSoup\n+# ... import exception class \n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n@@ -27,6 +28,20 @@\n import re\n import six\n \n+try:\n+    from sgmllib import SGMLParseError\n+    from sgmllib import SGMLParser\n+except ImportError:\n+    # This is probably Python 3, which doesn\'t include sgmllib anymore\n+    _SGML_AVAILABLE = 0\n+\n+    # Mock sgmllib enough to allow subclassing later on\n+    class SGMLParser(object):\n+        pass\n+\n+    class SGMLParseError(object):\n+        pass\n+\n \n HAS_LINGUAPLONE = True\n try:\n@@ -61,7 +76,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(SGMLParser):\n+class ResolveUIDAndCaptionFilter(HTMLParser):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -70,13 +85,9 @@ class ResolveUIDAndCaptionFilter(SGMLParser):\n         \'source\', \'track\', \'wbr\'])\n \n     def __init__(self, context=None, request=None):\n-        SGMLParser.__init__(self)\n         self.current_status = None\n         self.context = context\n         self.request = request\n-        self.pieces = []\n-        self.in_link = False\n-        self.in_script = False\n \n     # IFilter implementation\n     order = 800\n@@ -114,43 +125,70 @@ def _shorttag_replace(self, match):\n             return \'<\' + tag + \'></\' + tag + \'>\'\n \n     def __call__(self, data):\n+        # from SGMLParser implementation; still necessary?\n         data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        self.feed(data)\n-        self.close()\n-        return self.getResult()\n-\n-    # SGMLParser implementation\n-\n-    def append_data(self, data, add_eol=0):\n-        """Append data unmodified to self.data, add_eol adds a newline\n-        character"""\n-        if add_eol:\n-            data += \'\\n\'\n-        self.pieces.append(data)\n+        soup = BeautifulSoup(data, \'lxml\')\n \n-    def handle_charref(self, ref):\n-        """ Handle characters, just add them again """\n-        self.append_data("&#%s;" % ref)\n-\n-    def handle_entityref(self, ref):\n-        """ Handle html entities, put them back as we get them """\n-        self.append_data("&%s;" % ref)\n-\n-    def handle_data(self, text):\n-        """ Add data unmodified """\n-        self.append_data(text)\n+        for elem in soup.find_all([\'a\', \'area\'], \'href\'):\n+            attributes = elem.attrs\n+            href = attributes[\'href\']\n+            changed = False\n+            if 1:\n+                scheme = urlsplit(href)[0]\n+                if not scheme and not href.startswith(\'/\') \\\n+                        and not href.startswith(\'mailto<\') \\\n+                        and not href.startswith(\'mailto:\') \\\n+                        and not href.startswith(\'tel:\') \\\n+                        and not href.startswith(\'#\'):\n+                    obj, subpath, appendix = self.resolve_link(href)\n+                    if obj is not None:\n+                        href = obj.absolute_url()\n+                        if subpath:\n+                            href += \'/\' + subpath\n+                        href += appendix\n+                        changed = True\n+                    elif resolveuid_re.match(href) is None:\n+                        # absolutize relative URIs; this text isn\'t necessarily\n+                        # being rendered in the context where it was stored\n+                        relative_root = self.context\n+                        if not getattr(\n+                                self.context, \'isPrincipiaFolderish\', False):\n+                            relative_root = aq_parent(self.context)\n+                        actual_url = relative_root.absolute_url()\n+                        href = urljoin(actual_url + \'/\', subpath) + appendix\n+                        changed = True\n+                    if not changed:\n+                        continue\n+                    attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\', \'src\'):\n+            attributes = elem.attrs\n+            if 1:\n+                src = attributes.get(\'src\', \'\')\n+                image, fullimage, src, description = self.resolve_image(src)\n+                attributes["src"] = src\n \n-    def handle_comment(self, text):\n-        """ Handle comments unmodified """\n-        self.append_data("<!--%s-->" % text)\n+                if fullimage is not None:\n+                    # Check to see if the alt / title tags need setting\n+                    title = aq_acquire(fullimage, \'Title\')()\n+                    if not attributes.get(\'alt\'):\n+                        # XXX alt attribute contains *alternate* text \n+                        attributes[\'alt\'] = description or title\n+                    if \'title\' not in attributes:\n+                        attributes[\'title\'] = title\n \n-    def handle_pi(self, text):\n-        """ Handle processing instructions unmodified"""\n-        self.append_data("<?%s>" % text)\n+                caption = description\n+                # Check if the image needs to be captioned\n+                if (\n+                    self.captioned_images and\n+                    image is not None and\n+                    caption and\n+                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n+                ):\n+                    self.handle_captioned_image(attributes, image, fullimage,\n+                                                elem, soup,\n+                                                caption)\n \n-    def handle_decl(self, text):\n-        """Handle declarations unmodified """\n-        self.append_data("<!%s>" % text)\n+        return six.text_type(soup)\n \n     def lookup_uid(self, uid):\n         context = self.context\n@@ -268,8 +306,13 @@ def traverse_path(base, path):\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n-    def handle_captioned_image(self, attributes, image, fullimage, caption):\n+    def handle_captioned_image(self, attributes, image, fullimage,\n+                               elem, soup,\n+                               caption):\n         """Handle captioned image.\n+\n+        The img element is replaced by a definition list\n+        as created by the template ../browser/captioned_image.pt\n         """\n         klass = attributes[\'class\']\n         del attributes[\'class\']\n@@ -313,9 +356,16 @@ def handle_captioned_image(self, attributes, image, fullimage, caption):\n             options[\'isfullsize\'] = True\n \n         captioned_html = self.captioned_image_template(**options)\n-        if isinstance(captioned_html, six.text_type):\n-            captioned_html = captioned_html.encode(\'utf8\')\n-        self.append_data(captioned_html)\n+        new_elem = soup.new_tag\n+        if not options[\'isfullsize\']:\n+            a_elem = soup.new_tag(\'a\',\n+                                  rel=\'lightbox\',\n+                                  href=options[\'url_path\'])\n+            elem = elem.wrap(a_elem)\n+        dt = elem.wrap(soup.new_tag(\'dt\')\n+        dl = dt.wrap(soup.new_tag(\'dl\', class_=klass))\n+        dl.append(soup.new_tag(\'dd\', options[\'caption\'])\n+        elem.replace_with(dl)\n \n     def unknown_starttag(self, tag, attrs):\n         """Here we\'ve got the actual conversion of links and images.\n@@ -414,8 +464,8 @@ def parse_declaration(self, i):\n             self.append_data("<![CDATA[%s]]>" % data)\n         else:\n             try:\n-                j = SGMLParser.parse_declaration(self, i)\n-            except SGMLParseError:\n+                j = HTMLParser.parse_declaration(self, i)\n+            except HTMLParseError:\n                 toHandle = self.rawdata[i:]\n                 self.handle_data(toHandle)\n                 j = i + len(toHandle)\ndiff --git a/setup.py b/setup.py\nindex d784892..b21ab22 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,6 +43,8 @@\n           \'setuptools\',\n           \'six\',\n           \'unidecode\',\n+          \'beautifulsoup4\',\n+          \'lxml\',\n       ],\n       extras_require={\n           \'test\': [\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-04-01T14:17:06+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.outputfilters/commit/e1d1f90057ba737639a1b5315a73d429bc324cd1

disable resolveuid_and_caption for py3 (see #27)

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 20eace8..cb79e60 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -126,7 +126,10 @@ def _shorttag_replace(self, match):\n             return '<' + tag + '></' + tag + '>'\n \n     def __call__(self, data):\n-        data = re.sub(r'<([^<>\\s]+?)\\s*/>', self._shorttag_replace, data)\n+        if six.PY3:\n+            # FIXME: See https://github.com/plone/plone.outputfilters/issues/27\n+            return data\n+        data = re.sub(br'<([^<>\\s]+?)\\s*/>', self._shorttag_replace, data)\n         self.feed(data)\n         self.close()\n         return self.getResult()\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T12:24:08+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/b3082953610b330f7ff9e3104391738972f7c2e4

remove sgmllib completely and fix tests

2 failing tests remaining ... WIP

Files changed:
M CHANGES.rst
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex dfef1a5..f0da8f4 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,13 +10,13 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- remove deprecated sgmllib and move to BeautifulSoup4\n+  [tobiasherp, petschki]\n \n Bug fixes:\n \n - *add item here*\n \n-\n 3.0.4 (2018-02-02)\n ------------------\n \ndiff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 7e09dd1..c8720d1 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -1,47 +1,29 @@\n # -*- coding: utf-8 -*-\n-# reimplementation, based on lxml instead of SGMLParser\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n-from cgi import escape\n from DocumentTemplate.DT_Util import html_quote\n from DocumentTemplate.DT_Var import newline_to_br\n-from plone.outputfilters.browser.resolveuid import uuidToObject\n-from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n from bs4 import BeautifulSoup\n-# ... import exception class \n+from plone.outputfilters.browser.resolveuid import uuidToObject\n+from plone.outputfilters.interfaces import IFilter\n+from ZODB.POSException import ConflictError\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n-from unidecode import unidecode\n from zExceptions import NotFound\n-from ZODB.POSException import ConflictError\n from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getAllUtilitiesRegisteredFor\n from zope.component.hooks import getSite\n from zope.interface import Attribute\n-from zope.interface import implementer\n from zope.interface import Interface\n+from zope.interface import implementer\n from zope.publisher.interfaces import NotFound as ztkNotFound\n \n import re\n import six\n \n-try:\n-    from sgmllib import SGMLParseError\n-    from sgmllib import SGMLParser\n-except ImportError:\n-    # This is probably Python 3, which doesn\'t include sgmllib anymore\n-    _SGML_AVAILABLE = 0\n-\n-    # Mock sgmllib enough to allow subclassing later on\n-    class SGMLParser(object):\n-        pass\n-\n-    class SGMLParseError(object):\n-        pass\n-\n \n HAS_LINGUAPLONE = True\n try:\n@@ -50,7 +32,7 @@ class SGMLParseError(object):\n     HAS_LINGUAPLONE = False\n \n \n-appendix_re = re.compile(\'^(.*)([\\?#].*)$\')\n+appendix_re = re.compile(\'^(.*)([?#].*)$\')\n resolveuid_re = re.compile(\'^[./]*resolve[Uu]id/([^/]*)/?(.*)$\')\n \n \n@@ -76,7 +58,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(HTMLParser):\n+class ResolveUIDAndCaptionFilter(object):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -125,68 +107,66 @@ def _shorttag_replace(self, match):\n             return \'<\' + tag + \'></\' + tag + \'>\'\n \n     def __call__(self, data):\n-        # from SGMLParser implementation; still necessary?\n         data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        soup = BeautifulSoup(data, \'lxml\')\n+        soup = BeautifulSoup(data, \'html.parser\')\n \n-        for elem in soup.find_all([\'a\', \'area\'], \'href\'):\n+        for elem in soup.find_all([\'a\', \'area\']):\n             attributes = elem.attrs\n-            href = attributes[\'href\']\n+            href = attributes.get(\'href\')\n+            if href is None:\n+                continue\n             changed = False\n-            if 1:\n-                scheme = urlsplit(href)[0]\n-                if not scheme and not href.startswith(\'/\') \\\n-                        and not href.startswith(\'mailto<\') \\\n-                        and not href.startswith(\'mailto:\') \\\n-                        and not href.startswith(\'tel:\') \\\n-                        and not href.startswith(\'#\'):\n-                    obj, subpath, appendix = self.resolve_link(href)\n-                    if obj is not None:\n-                        href = obj.absolute_url()\n-                        if subpath:\n-                            href += \'/\' + subpath\n-                        href += appendix\n-                        changed = True\n-                    elif resolveuid_re.match(href) is None:\n-                        # absolutize relative URIs; this text isn\'t necessarily\n-                        # being rendered in the context where it was stored\n-                        relative_root = self.context\n-                        if not getattr(\n-                                self.context, \'isPrincipiaFolderish\', False):\n-                            relative_root = aq_parent(self.context)\n-                        actual_url = relative_root.absolute_url()\n-                        href = urljoin(actual_url + \'/\', subpath) + appendix\n-                        changed = True\n-                    if not changed:\n-                        continue\n-                    attributes[\'href\'] = href\n-        for elem in soup.find_all(\'img\', \'src\'):\n+            scheme = urlsplit(href)[0]\n+            if not scheme and not href.startswith(\'/\') \\\n+                    and not href.startswith(\'mailto<\') \\\n+                    and not href.startswith(\'mailto:\') \\\n+                    and not href.startswith(\'tel:\') \\\n+                    and not href.startswith(\'#\'):\n+                obj, subpath, appendix = self.resolve_link(href)\n+                if obj is not None:\n+                    href = obj.absolute_url()\n+                    if subpath:\n+                        href += \'/\' + subpath\n+                    href += appendix\n+                    changed = True\n+                elif resolveuid_re.match(href) is None:\n+                    # absolutize relative URIs; this text isn\'t necessarily\n+                    # being rendered in the context where it was stored\n+                    relative_root = self.context\n+                    if not getattr(\n+                            self.context, \'isPrincipiaFolderish\', False):\n+                        relative_root = aq_parent(self.context)\n+                    actual_url = relative_root.absolute_url()\n+                    href = urljoin(actual_url + \'/\', subpath) + appendix\n+                    changed = True\n+                if not changed:\n+                    continue\n+                attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\'):\n             attributes = elem.attrs\n-            if 1:\n-                src = attributes.get(\'src\', \'\')\n-                image, fullimage, src, description = self.resolve_image(src)\n-                attributes["src"] = src\n-\n-                if fullimage is not None:\n-                    # Check to see if the alt / title tags need setting\n-                    title = aq_acquire(fullimage, \'Title\')()\n-                    if not attributes.get(\'alt\'):\n-                        # XXX alt attribute contains *alternate* text \n-                        attributes[\'alt\'] = description or title\n-                    if \'title\' not in attributes:\n-                        attributes[\'title\'] = title\n-\n-                caption = description\n-                # Check if the image needs to be captioned\n-                if (\n-                    self.captioned_images and\n-                    image is not None and\n-                    caption and\n-                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n-                ):\n-                    self.handle_captioned_image(attributes, image, fullimage,\n-                                                elem, soup,\n-                                                caption)\n+            src = attributes.get(\'src\', \'\')\n+            image, fullimage, src, description = self.resolve_image(src)\n+            attributes["src"] = src\n+\n+            if fullimage is not None:\n+                # Check to see if the alt / title tags need setting\n+                title = aq_acquire(fullimage, \'Title\')()\n+                if not attributes.get(\'alt\'):\n+                    # XXX alt attribute contains *alternate* text\n+                    attributes[\'alt\'] = description or title\n+                if \'title\' not in attributes:\n+                    attributes[\'title\'] = title\n+\n+            caption = description\n+            # Check if the image needs to be captioned\n+            if (\n+                self.captioned_images and\n+                image is not None and\n+                caption and\n+                \'captioned\' in attributes.get(\'class\', [])\n+            ):\n+                self.handle_captioned_image(\n+                    attributes, image, fullimage, elem, caption)\n \n         return six.text_type(soup)\n \n@@ -300,21 +280,18 @@ def traverse_path(base, path):\n             url = image.absolute_url()\n         except AttributeError:\n             return None, None, src, description\n-        if isinstance(url, six.text_type):\n-            url = url.encode(\'utf8\')\n         src = url + appendix\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n     def handle_captioned_image(self, attributes, image, fullimage,\n-                               elem, soup,\n-                               caption):\n+                               elem, caption):\n         """Handle captioned image.\n \n         The img element is replaced by a definition list\n         as created by the template ../browser/captioned_image.pt\n         """\n-        klass = attributes[\'class\']\n+        klass = \' \'.join(attributes[\'class\'])\n         del attributes[\'class\']\n         del attributes[\'src\']\n         if \'width\' in attributes:\n@@ -350,129 +327,7 @@ def handle_captioned_image(self, attributes, image, fullimage,\n                 image.height == original_height),\n             \'width\': attributes.get(\'width\', width),\n         }\n-        if self.in_link:\n-            # Must preserve original link, don\'t overwrite\n-            # with a link to the image\n-            options[\'isfullsize\'] = True\n-\n-        captioned_html = self.captioned_image_template(**options)\n-        new_elem = soup.new_tag\n-        if not options[\'isfullsize\']:\n-            a_elem = soup.new_tag(\'a\',\n-                                  rel=\'lightbox\',\n-                                  href=options[\'url_path\'])\n-            elem = elem.wrap(a_elem)\n-        dt = elem.wrap(soup.new_tag(\'dt\')\n-        dl = dt.wrap(soup.new_tag(\'dl\', class_=klass))\n-        dl.append(soup.new_tag(\'dd\', options[\'caption\'])\n-        elem.replace_with(dl)\n-\n-    def unknown_starttag(self, tag, attrs):\n-        """Here we\'ve got the actual conversion of links and images.\n-\n-        Convert UUID\'s to absolute URLs, and process captioned images to HTML.\n-        """\n-        if tag == \'script\':\n-            self.in_script = True\n-        if tag in [\'a\', \'img\', \'area\'] and not self.in_script:\n-            # Only do something if tag is a link, image, or image map area.\n-\n-            attributes = dict(attrs)\n-            if tag == \'a\':\n-                self.in_link = True\n-            if (tag == \'a\' or tag == \'area\') and \'href\' in attributes:\n-                href = attributes[\'href\']\n-                scheme = urlsplit(href)[0]\n-                if not scheme and not href.startswith(\'/\') \\\n-                        and not href.startswith(\'mailto<\') \\\n-                        and not href.startswith(\'mailto:\') \\\n-                        and not href.startswith(\'tel:\') \\\n-                        and not href.startswith(\'#\'):\n-                    obj, subpath, appendix = self.resolve_link(href)\n-                    if obj is not None:\n-                        href = obj.absolute_url()\n-                        if subpath:\n-                            href += \'/\' + subpath\n-                        href += appendix\n-                    elif resolveuid_re.match(href) is None:\n-                        # absolutize relative URIs; this text isn\'t necessarily\n-                        # being rendered in the context where it was stored\n-                        relative_root = self.context\n-                        if not getattr(\n-                                self.context, \'isPrincipiaFolderish\', False):\n-                            relative_root = aq_parent(self.context)\n-                        actual_url = relative_root.absolute_url()\n-                        href = urljoin(actual_url + \'/\', subpath) + appendix\n-                    attributes[\'href\'] = href\n-                    attrs = six.iteritems(attributes)\n-            elif tag == \'img\':\n-                src = attributes.get(\'src\', \'\')\n-                image, fullimage, src, description = self.resolve_image(src)\n-                attributes["src"] = src\n-                caption = description\n-                # Check if the image needs to be captioned\n-                if (\n-                    self.captioned_images and\n-                    image is not None and\n-                    caption and\n-                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n-                ):\n-                    self.handle_captioned_image(attributes, image, fullimage,\n-                                                caption)\n-                    return True\n-                if fullimage is not None:\n-                    # Check to see if the alt / title tags need setting\n-                    title = aq_acquire(fullimage, \'Title\')()\n-                    if not attributes.get(\'alt\'):\n-                        attributes[\'alt\'] = description or title\n-                    if \'title\' not in attributes:\n-                        attributes[\'title\'] = title\n-                    attrs = six.iteritems(attributes)\n-\n-        # Add the tag to the result\n-        strattrs = ""\n-        for key, value in attrs:\n-            try:\n-                strattrs += \' %s="%s"\' % (key, escape(value, quote=True))\n-            except UnicodeDecodeError:\n-                strattrs += \' %s="%s"\' % (unidecode(key),\n-                                          escape(unidecode(value), quote=True))\n \n-        if tag in self.singleton_tags:\n-            self.append_data("<%s%s />" % (tag, strattrs))\n-        else:\n-            self.append_data("<%s%s>" % (tag, strattrs))\n-\n-    def unknown_endtag(self, tag):\n-        """Add the endtag unmodified"""\n-        if tag == \'a\':\n-            self.in_link = False\n-        if tag == \'script\':\n-            self.in_script = False\n-        self.append_data("</%s>" % tag)\n-\n-    def parse_declaration(self, i):\n-        """Fix handling of CDATA sections. Code borrowed from BeautifulSoup.\n-        """\n-        j = None\n-        if self.rawdata[i:i + 9] == \'<![CDATA[\':\n-            k = self.rawdata.find(\']]>\', i)\n-            if k == -1:\n-                k = len(self.rawdata)\n-            data = self.rawdata[i + 9:k]\n-            j = k + 3\n-            self.append_data("<![CDATA[%s]]>" % data)\n-        else:\n-            try:\n-                j = HTMLParser.parse_declaration(self, i)\n-            except HTMLParseError:\n-                toHandle = self.rawdata[i:]\n-                self.handle_data(toHandle)\n-                j = i + len(toHandle)\n-        return j\n-\n-    def getResult(self):\n-        """Return the parsed result and flush it"""\n-        result = "".join(self.pieces)\n-        self.pieces = None\n-        return result\n+        captioned = BeautifulSoup(\n+            self.captioned_image_template(**options), \'html.parser\')\n+        elem.replace_with(captioned)\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex f9b43f1..ffcfe31 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -192,10 +192,10 @@ def test_resolve_uids_fragment(self):\n \n     def test_resolve_uids_in_image_maps(self):\n         text_in = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n </map>""" % self.UID\n         text_out = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="http://nohost/plone/image.jpg" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" coords="1,2,3,4" href="http://nohost/plone/image.jpg" shape="rect"/>\n </map>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -270,30 +270,31 @@ def test_image_captioning_in_news_item(self):\n \n         # Test captioning\n         output = news_item.text.output\n-        self.assertRegexpMatches(output, r"""<span><dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/(.*?)\\.jpeg" alt="Image" title="Image" height="331" width="500"( ?)/></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<span><dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>\n-</span>""")\n+</span>"""\n+        self._assertTransformsTo(output, text_out)\n \n     def test_image_captioning_absolutizes_uncaptioned_image(self):\n         text_in = """<img src="/image.jpg" />"""\n-        text_out = """<img src="http://nohost/plone/image.jpg" alt="My caption" title="Image" />"""\n+        text_out = """<img alt="My caption" src="http://nohost/plone/image.jpg" title="Image"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_absolute_path(self):\n         text_in = """<img class="captioned" src="/image.jpg"/>"""\n-        text_out = """<dl  class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path(self):\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -313,40 +314,40 @@ def test_image_captioning_relative_path_private_folder(self):\n \n         text_in = """<img class="captioned" src="private/image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/private/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My private image caption</dd>\n+<dt><img alt="My private image caption" height="331" src="http://nohost/plone/private/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My private image caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path_scale(self):\n         text_in = """<img class="captioned" src="image.jpg/@@images/image/thumb"/>"""\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid(self):\n         text_in = """<img class="captioned" src="resolveuid/%s"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_new_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -355,13 +356,13 @@ def test_image_captioning_resolveuid_new_scale_plone_namedfile(self):\n             return\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image/thumb"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_no_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n <dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n@@ -371,46 +372,46 @@ def test_image_captioning_resolveuid_no_scale_plone_namedfile(self):\n             return\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_bad_uid(self):\n-        text_in = """<img src="resolveuid/notauid" width="120" height="144" start="fileopen" alt="Duncan\'s picture" class="image-left captioned" loop="1" />"""\n+        text_in = """<img alt="Duncan\'s picture" class="image-left captioned" height="144" loop="1" src="resolveuid/notauid" start="fileopen" width="120"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale(self):\n-        text_in = """<img src="resolveuid/%s/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale_images_view(self):\n-        text_in = """<img src="resolveuid/%s/@@images/image/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/@@images/image/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_external_url(self):\n-        text_in = """<img src="http://example.com/foo" class="captioned" />"""\n+        text_in = """<img class="captioned" src="http://example.com/foo"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_preserves_custom_attributes(self):\n         text_in = """<img class="captioned" width="42" height="42" foo="bar" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="42" width="42" foo="bar" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" foo="bar" height="42" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="42"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_unquoted_attributes(self):\n         text_in = """<img class=captioned height=144 alt="picture alt text" src="resolveuid/%s" width=120 />""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="picture alt text" title="Image" height="144" width="120" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="picture alt text" height="144" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="120"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_preserves_existing_links(self):\n         text_in = """<a href="/xyzzy" class="link"><img class="image-left captioned" src="image.jpg/@@images/image/thumb"/></a>"""\n         text_out = """<a href="/xyzzy" class="link"><dl class="image-left captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl></a>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -419,9 +420,9 @@ def test_image_captioning_handles_non_ascii(self):\n         self.portal[\'image.jpg\'].setDescription(\n             u\'Kupu Test Image \\xe5\\xe4\\xf6\')\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n-        text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" width="500" /></dt>\n- <dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n+        text_out = u"""<dl class="captioned">\n+<dt><img alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" width="500" /></dt>\n+<dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -432,7 +433,7 @@ def test_resolve_uids_with_bigU(self):\n \n     def test_singleton_elements(self):\n         self._assertTransformsTo(\n-            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr />\\r\\n<p>foo</p><br />\')\n+            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr/>\\r\\n<p>foo</p><br/>\')\n \n     def test_no_change_when_a_in_script(self):\n         text_in = """<script>a=\'<a href="">test</a>\';</script>"""\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T12:32:28+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/a5b979274539ac4f1de4ee63532468dadd6b3433

Merge branch 'python3' into python3-therp

Files changed:
M setup.py

b"diff --git a/setup.py b/setup.py\nindex b21ab22..86e37fd 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -42,7 +42,6 @@\n           'Products.PortalTransforms>=2.0a1',\n           'setuptools',\n           'six',\n-          'unidecode',\n           'beautifulsoup4',\n           'lxml',\n       ],\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T13:59:40+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/e1543462b2814920b1390b1f7873a9fa0239ecff

fix failing tests in py2 and py3

Files changed:
M plone/outputfilters/filters/example.py
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b'diff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex e119fd8..9a79ff0 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r\'--\')\n \n     def __call__(self, data):\n-        return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+        return self.pattern.sub(u\'\xe2\x80\x94\', data)\ndiff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex c8720d1..d524b63 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -330,4 +330,10 @@ def handle_captioned_image(self, attributes, image, fullimage,\n \n         captioned = BeautifulSoup(\n             self.captioned_image_template(**options), \'html.parser\')\n+\n+        # if we are a captioned image within a link, remove and occurrences\n+        # of a tags inside caption template to preserve the outer link\n+        if bool(elem.find_parent(\'a\')):\n+            captioned.a.unwrap()\n+\n         elem.replace_with(captioned)\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex ffcfe31..690f191 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -409,10 +409,11 @@ def test_image_captioning_handles_unquoted_attributes(self):\n \n     def test_image_captioning_preserves_existing_links(self):\n         text_in = """<a href="/xyzzy" class="link"><img class="image-left captioned" src="image.jpg/@@images/image/thumb"/></a>"""\n-        text_out = """<a href="/xyzzy" class="link"><dl class="image-left captioned">\n+        text_out = """<a class="link" href="/xyzzy"><dl class="image-left captioned">\n <dt><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></dt>\n <dd class="image-caption">My caption</dd>\n-</dl></a>"""\n+</dl>\n+</a>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_non_ascii(self):\n@@ -421,8 +422,8 @@ def test_image_captioning_handles_non_ascii(self):\n             u\'Kupu Test Image \\xe5\\xe4\\xf6\')\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n         text_out = u"""<dl class="captioned">\n-<dt><img alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" width="500" /></dt>\n-<dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n+<dt><img alt="Kupu Test Image \\xe5\\xe4\\xf6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xe5\\xe4\\xf6" width="500"/></dt>\n+<dd class="image-caption">Kupu Test Image \\xe5\\xe4\\xf6</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T14:08:26+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/1d8c3d0c99c468a76d06d0395facac059b53f788

try to fix failing doctest for py2 and py3

py2 - fail
py3 - pass

Files changed:
M plone/outputfilters/filters/example.py

b"diff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex 9a79ff0..928d3ca 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r'--')\n \n     def __call__(self, data):\n-        return self.pattern.sub(u'\xe2\x80\x94', data)\n+        return self.pattern.sub(u'\\xe2\\x80\\x94', data)\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T14:38:04+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/98cf21fdc00edb3a8d9f61e61a7132ef765d0451

fix `ResourceWarning: unclosed file` in tests

Files changed:
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex 690f191..789b203 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -33,7 +33,10 @@\n def dummy_image():\n     from plone.namedfile.file import NamedBlobImage\n     filename = join(PREFIX, u'image.jpg')\n-    data = open(filename, 'rb').read()\n+    data = None\n+    with open(filename, 'rb') as fd:\n+        data = fd.read()\n+        fd.close()\n     return NamedBlobImage(data=data, filename=filename)\n \n \n@@ -75,7 +78,9 @@ def UID(self):\n \n         if HAS_NAMEDFILE:\n             dummy2 = DummyContent2('foo2')\n-            data = open(join(PREFIX, self.image_id), 'rb').read()\n+            with open(join(PREFIX, self.image_id), 'rb') as fd:\n+                data = fd.read()\n+                fd.close()\n             dummy2.image = NamedImage(data, 'image/jpeg', u'image.jpeg')\n             self.portal._setObject('foo2', dummy2)\n             self.portal.portal_catalog.catalog_object(self.portal.foo2)\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T20:27:01+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/a60792f3ab54cc1c262d9c578fe77eefc2e2bf3f

test non ascii transforms for py2 and py3

Files changed:
A plone/outputfilters/tests/README_py2.rst
M plone/outputfilters/README.rst
M plone/outputfilters/filters/example.py
M plone/outputfilters/tests/test_docs.py

b'diff --git a/plone/outputfilters/README.rst b/plone/outputfilters/README.rst\nindex bca160d..454b166 100644\n--- a/plone/outputfilters/README.rst\n+++ b/plone/outputfilters/README.rst\n@@ -28,7 +28,7 @@ Example::\n         pattern = re.compile(r\'--\')\n \n         def __call__(self, data):\n-            return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+            return self.pattern.sub(\'\xe2\x80\x94\', data)\n \n The ``order`` attribute may be used to affect the order in which filters are\n applied (higher values run later). The is_enabled method should return a boolean\n@@ -62,7 +62,7 @@ be applied::\n     >>> portal = layer[\'portal\']\n     >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n     ...     \'test--test\', mimetype=\'text/html\', context=portal))\n-    \'test\\xe2\\x80\\x94test\'\n+    \'test\xe2\x80\x94test\'\n \n \n How it works\ndiff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex 928d3ca..9a79ff0 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r\'--\')\n \n     def __call__(self, data):\n-        return self.pattern.sub(u\'\\xe2\\x80\\x94\', data)\n+        return self.pattern.sub(u\'\xe2\x80\x94\', data)\ndiff --git a/plone/outputfilters/tests/README_py2.rst b/plone/outputfilters/tests/README_py2.rst\nnew file mode 100644\nindex 0000000..0e7dca9\n--- /dev/null\n+++ b/plone/outputfilters/tests/README_py2.rst\n@@ -0,0 +1,85 @@\n+Adding a custom filter\n+======================\n+\n+As an example, the following filter replaces all doubled hyphens ("--") with em\n+dashes ("-"). (Don\'t use the example verbatim, because it doesn\'t parse HTML to\n+apply itself only to text nodes, so will mangle HTML comments.)\n+\n+A filter is a callable which accepts a UTF-8-encoded HTML string as input, and\n+returns a modified UTF-8-encoded HTML string. A return value of ``None`` may be\n+used to indicate that the input should not be modified.\n+\n+Example::\n+\n+    import re\n+    from zope.interface import implements\n+    from plone.outputfilters.interfaces import IFilter\n+\n+    class EmDashAdder(object):\n+        implements(IFilter)\n+        order = 1000\n+\n+        def __init__(self, context, request):\n+            pass\n+\n+        def is_enabled(self):\n+            return True\n+\n+        pattern = re.compile(r\'--\')\n+\n+        def __call__(self, data):\n+            return self.pattern.sub(u\'\\xe2\\x80\\x94\', data)\n+\n+The ``order`` attribute may be used to affect the order in which filters are\n+applied (higher values run later). The is_enabled method should return a boolean\n+indicating whether the filter should be applied.\n+\n+Filters are registered in ZCML as a named multi-adapter of the context and\n+request to IFilter::\n+\n+    >>> from Zope2.App import zcml\n+    >>> import Products.Five\n+    >>> configure = """\n+    ... <configure\n+    ...     xmlns="http://namespaces.zope.org/zope">\n+    ...\n+    ...   <adapter\n+    ...     name="em_dash_adder"\n+    ...     provides="plone.outputfilters.interfaces.IFilter"\n+    ...     for="* *"\n+    ...     factory="plone.outputfilters.filters.example.EmDashAdder"\n+    ...     />\n+    ...\n+    ... </configure>\n+    ... """\n+    >>> zcml.load_config("configure.zcml", Products.Five)\n+    >>> zcml.load_string(configure)\n+\n+Now when text is transformed from text/html to text/x-html-safe, the filter will\n+be applied::\n+\n+    >>> app = layer[\'app\']\n+    >>> portal = layer[\'portal\']\n+    >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n+    ...     \'test--test\', mimetype=\'text/html\', context=portal))\n+    \'test\\xe2\\x80\\x94test\'\n+\n+\n+How it works\n+============\n+\n+``plone.outputfilters`` hooks into the PortalTransforms machinery by installing:\n+\n+1. a new mimetype ("text/x-plone-outputfilters-html")\n+2. a transform from text/html to text/x-plone-outputfilters-html\n+3. a null transform from text/x-plone-outputfilters-html back to text/html\n+4. a "transform policy" for the text/x-html-safe mimetype, which says that text\n+   being transformed to text/x-html-safe must first be transformed to\n+   text/x-plone-outputfilters-html\n+\n+The filter adapters are looked up and applied during the execution of the\n+transform from step #2.\n+\n+This should be considered an implementation detail and may change at some point\n+in the future.\n+\ndiff --git a/plone/outputfilters/tests/test_docs.py b/plone/outputfilters/tests/test_docs.py\nindex 211461f..df7327e 100644\n--- a/plone/outputfilters/tests/test_docs.py\n+++ b/plone/outputfilters/tests/test_docs.py\n@@ -4,17 +4,23 @@\n \n import doctest\n import pprint\n+import six\n import unittest\n \n-\n optionflags = (\n     doctest.ELLIPSIS |\n     doctest.NORMALIZE_WHITESPACE |\n     doctest.REPORT_ONLY_FIRST_FAILURE\n )\n-normal_testfiles = [\n-    \'../README.rst\'\n-]\n+\n+if six.PY3:\n+    normal_testfiles = [\n+        \'../README.rst\'\n+    ]\n+else:\n+    normal_testfiles = [\n+        \'./README_py2.rst\',\n+    ]\n \n \n def test_suite():\n@@ -23,7 +29,7 @@ def test_suite():\n         layered(doctest.DocFileSuite(test,\n                                      optionflags=optionflags,\n                                      globs={\'pprint\': pprint.pprint,\n-                                            }\n+                                            },\n                                      ),\n                 layer=PLONE_OUTPUTFILTERS_FUNCTIONAL_TESTING)\n         for test in normal_testfiles])\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-16T20:46:39+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/e5b875ad3d79826c7da8e134865aaabb67ed7b16

update classifier

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 86e37fd..daaf6f4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -25,6 +25,7 @@\n           "License :: OSI Approved :: GNU General Public License (GPL)",\n           "Programming Language :: Python",\n           "Programming Language :: Python :: 2.7",\n+          "Programming Language :: Python :: 3.6",\n       ],\n       keywords=\'plone transform filter uid caption\',\n       author=\'David Glick, Plone Foundation\',\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-17T09:57:50+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.outputfilters/commit/8878037b75a976d7c1c69f204d811498e4db26eb

Merge pull request #30 from plone/python3-therp

python3 compatibility

Files changed:
A plone/outputfilters/tests/README_py2.rst
M .gitignore
M CHANGES.rst
M buildout.cfg
M plone/outputfilters/README.rst
M plone/outputfilters/filters/example.py
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_docs.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py
M setup.py

b'diff --git a/.gitignore b/.gitignore\nindex 67a7ae8..48f1ce2 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -9,3 +9,6 @@ include/\n parts/\n .installed.cfg\n develop-eggs/\n+eggs/\n+local/\n+pip-selfcheck.json\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex dfef1a5..f0da8f4 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,13 +10,13 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- remove deprecated sgmllib and move to BeautifulSoup4\n+  [tobiasherp, petschki]\n \n Bug fixes:\n \n - *add item here*\n \n-\n 3.0.4 (2018-02-02)\n ------------------\n \ndiff --git a/buildout.cfg b/buildout.cfg\nindex 0673a58..52c5ba2 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -3,6 +3,7 @@ extends =\n     http://dist.plone.org/release/5.0.6/versions.cfg\n develop = .\n parts = test\n+index = https://pypi.python.org/simple\n \n [versions]\n plone.outputfilters =\ndiff --git a/plone/outputfilters/README.rst b/plone/outputfilters/README.rst\nindex bca160d..454b166 100644\n--- a/plone/outputfilters/README.rst\n+++ b/plone/outputfilters/README.rst\n@@ -28,7 +28,7 @@ Example::\n         pattern = re.compile(r\'--\')\n \n         def __call__(self, data):\n-            return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+            return self.pattern.sub(\'\xe2\x80\x94\', data)\n \n The ``order`` attribute may be used to affect the order in which filters are\n applied (higher values run later). The is_enabled method should return a boolean\n@@ -62,7 +62,7 @@ be applied::\n     >>> portal = layer[\'portal\']\n     >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n     ...     \'test--test\', mimetype=\'text/html\', context=portal))\n-    \'test\\xe2\\x80\\x94test\'\n+    \'test\xe2\x80\x94test\'\n \n \n How it works\ndiff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex e119fd8..9a79ff0 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r\'--\')\n \n     def __call__(self, data):\n-        return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+        return self.pattern.sub(u\'\xe2\x80\x94\', data)\ndiff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex cb79e60..d524b63 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -2,43 +2,28 @@\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n-from cgi import escape\n from DocumentTemplate.DT_Util import html_quote\n from DocumentTemplate.DT_Var import newline_to_br\n+from Products.CMFCore.interfaces import IContentish\n+from bs4 import BeautifulSoup\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n-from Products.CMFCore.interfaces import IContentish\n+from ZODB.POSException import ConflictError\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n-from unidecode import unidecode\n from zExceptions import NotFound\n-from ZODB.POSException import ConflictError\n from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getAllUtilitiesRegisteredFor\n from zope.component.hooks import getSite\n from zope.interface import Attribute\n-from zope.interface import implementer\n from zope.interface import Interface\n+from zope.interface import implementer\n from zope.publisher.interfaces import NotFound as ztkNotFound\n \n import re\n import six\n \n-try:\n-    from sgmllib import SGMLParseError\n-    from sgmllib import SGMLParser\n-except ImportError:\n-    # This is probably Python 3, which doesn\'t include sgmllib anymore\n-    _SGML_AVAILABLE = 0\n-\n-    # Mock sgmllib enough to allow subclassing later on\n-    class SGMLParser(object):\n-        pass\n-\n-    class SGMLParseError(object):\n-        pass\n-\n \n HAS_LINGUAPLONE = True\n try:\n@@ -47,7 +32,7 @@ class SGMLParseError(object):\n     HAS_LINGUAPLONE = False\n \n \n-appendix_re = re.compile(\'^(.*)([\\?#].*)$\')\n+appendix_re = re.compile(\'^(.*)([?#].*)$\')\n resolveuid_re = re.compile(\'^[./]*resolve[Uu]id/([^/]*)/?(.*)$\')\n \n \n@@ -73,7 +58,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(SGMLParser):\n+class ResolveUIDAndCaptionFilter(object):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -82,13 +67,9 @@ class ResolveUIDAndCaptionFilter(SGMLParser):\n         \'source\', \'track\', \'wbr\'])\n \n     def __init__(self, context=None, request=None):\n-        SGMLParser.__init__(self)\n         self.current_status = None\n         self.context = context\n         self.request = request\n-        self.pieces = []\n-        self.in_link = False\n-        self.in_script = False\n \n     # IFilter implementation\n     order = 800\n@@ -126,46 +107,68 @@ def _shorttag_replace(self, match):\n             return \'<\' + tag + \'></\' + tag + \'>\'\n \n     def __call__(self, data):\n-        if six.PY3:\n-            # FIXME: See https://github.com/plone/plone.outputfilters/issues/27\n-            return data\n-        data = re.sub(br\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        self.feed(data)\n-        self.close()\n-        return self.getResult()\n-\n-    # SGMLParser implementation\n-\n-    def append_data(self, data, add_eol=0):\n-        """Append data unmodified to self.data, add_eol adds a newline\n-        character"""\n-        if add_eol:\n-            data += \'\\n\'\n-        self.pieces.append(data)\n-\n-    def handle_charref(self, ref):\n-        """ Handle characters, just add them again """\n-        self.append_data("&#%s;" % ref)\n-\n-    def handle_entityref(self, ref):\n-        """ Handle html entities, put them back as we get them """\n-        self.append_data("&%s;" % ref)\n-\n-    def handle_data(self, text):\n-        """ Add data unmodified """\n-        self.append_data(text)\n-\n-    def handle_comment(self, text):\n-        """ Handle comments unmodified """\n-        self.append_data("<!--%s-->" % text)\n-\n-    def handle_pi(self, text):\n-        """ Handle processing instructions unmodified"""\n-        self.append_data("<?%s>" % text)\n-\n-    def handle_decl(self, text):\n-        """Handle declarations unmodified """\n-        self.append_data("<!%s>" % text)\n+        data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n+        soup = BeautifulSoup(data, \'html.parser\')\n+\n+        for elem in soup.find_all([\'a\', \'area\']):\n+            attributes = elem.attrs\n+            href = attributes.get(\'href\')\n+            if href is None:\n+                continue\n+            changed = False\n+            scheme = urlsplit(href)[0]\n+            if not scheme and not href.startswith(\'/\') \\\n+                    and not href.startswith(\'mailto<\') \\\n+                    and not href.startswith(\'mailto:\') \\\n+                    and not href.startswith(\'tel:\') \\\n+                    and not href.startswith(\'#\'):\n+                obj, subpath, appendix = self.resolve_link(href)\n+                if obj is not None:\n+                    href = obj.absolute_url()\n+                    if subpath:\n+                        href += \'/\' + subpath\n+                    href += appendix\n+                    changed = True\n+                elif resolveuid_re.match(href) is None:\n+                    # absolutize relative URIs; this text isn\'t necessarily\n+                    # being rendered in the context where it was stored\n+                    relative_root = self.context\n+                    if not getattr(\n+                            self.context, \'isPrincipiaFolderish\', False):\n+                        relative_root = aq_parent(self.context)\n+                    actual_url = relative_root.absolute_url()\n+                    href = urljoin(actual_url + \'/\', subpath) + appendix\n+                    changed = True\n+                if not changed:\n+                    continue\n+                attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\'):\n+            attributes = elem.attrs\n+            src = attributes.get(\'src\', \'\')\n+            image, fullimage, src, description = self.resolve_image(src)\n+            attributes["src"] = src\n+\n+            if fullimage is not None:\n+                # Check to see if the alt / title tags need setting\n+                title = aq_acquire(fullimage, \'Title\')()\n+                if not attributes.get(\'alt\'):\n+                    # XXX alt attribute contains *alternate* text\n+                    attributes[\'alt\'] = description or title\n+                if \'title\' not in attributes:\n+                    attributes[\'title\'] = title\n+\n+            caption = description\n+            # Check if the image needs to be captioned\n+            if (\n+                self.captioned_images and\n+                image is not None and\n+                caption and\n+                \'captioned\' in attributes.get(\'class\', [])\n+            ):\n+                self.handle_captioned_image(\n+                    attributes, image, fullimage, elem, caption)\n+\n+        return six.text_type(soup)\n \n     def lookup_uid(self, uid):\n         context = self.context\n@@ -277,16 +280,18 @@ def traverse_path(base, path):\n             url = image.absolute_url()\n         except AttributeError:\n             return None, None, src, description\n-        if isinstance(url, six.text_type):\n-            url = url.encode(\'utf8\')\n         src = url + appendix\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n-    def handle_captioned_image(self, attributes, image, fullimage, caption):\n+    def handle_captioned_image(self, attributes, image, fullimage,\n+                               elem, caption):\n         """Handle captioned image.\n+\n+        The img element is replaced by a definition list\n+        as created by the template ../browser/captioned_image.pt\n         """\n-        klass = attributes[\'class\']\n+        klass = \' \'.join(attributes[\'class\'])\n         del attributes[\'class\']\n         del attributes[\'src\']\n         if \'width\' in attributes:\n@@ -322,122 +327,13 @@ def handle_captioned_image(self, attributes, image, fullimage, caption):\n                 image.height == original_height),\n             \'width\': attributes.get(\'width\', width),\n         }\n-        if self.in_link:\n-            # Must preserve original link, don\'t overwrite\n-            # with a link to the image\n-            options[\'isfullsize\'] = True\n \n-        captioned_html = self.captioned_image_template(**options)\n-        if isinstance(captioned_html, six.text_type):\n-            captioned_html = captioned_html.encode(\'utf8\')\n-        self.append_data(captioned_html)\n+        captioned = BeautifulSoup(\n+            self.captioned_image_template(**options), \'html.parser\')\n \n-    def unknown_starttag(self, tag, attrs):\n-        """Here we\'ve got the actual conversion of links and images.\n-\n-        Convert UUID\'s to absolute URLs, and process captioned images to HTML.\n-        """\n-        if tag == \'script\':\n-            self.in_script = True\n-        if tag in [\'a\', \'img\', \'area\'] and not self.in_script:\n-            # Only do something if tag is a link, image, or image map area.\n-\n-            attributes = dict(attrs)\n-            if tag == \'a\':\n-                self.in_link = True\n-            if (tag == \'a\' or tag == \'area\') and \'href\' in attributes:\n-                href = attributes[\'href\']\n-                scheme = urlsplit(href)[0]\n-                if not scheme and not href.startswith(\'/\') \\\n-                        and not href.startswith(\'mailto<\') \\\n-                        and not href.startswith(\'mailto:\') \\\n-                        and not href.startswith(\'tel:\') \\\n-                        and not href.startswith(\'#\'):\n-                    obj, subpath, appendix = self.resolve_link(href)\n-                    if obj is not None:\n-                        href = obj.absolute_url()\n-                        if subpath:\n-                            href += \'/\' + subpath\n-                        href += appendix\n-                    elif resolveuid_re.match(href) is None:\n-                        # absolutize relative URIs; this text isn\'t necessarily\n-                        # being rendered in the context where it was stored\n-                        relative_root = self.context\n-                        if not getattr(\n-                                self.context, \'isPrincipiaFolderish\', False):\n-                            relative_root = aq_parent(self.context)\n-                        actual_url = relative_root.absolute_url()\n-                        href = urljoin(actual_url + \'/\', subpath) + appendix\n-                    attributes[\'href\'] = href\n-                    attrs = six.iteritems(attributes)\n-            elif tag == \'img\':\n-                src = attributes.get(\'src\', \'\')\n-                image, fullimage, src, description = self.resolve_image(src)\n-                attributes["src"] = src\n-                caption = description\n-                # Check if the image needs to be captioned\n-                if (\n-                    self.captioned_images and\n-                    image is not None and\n-                    caption and\n-                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n-                ):\n-                    self.handle_captioned_image(attributes, image, fullimage,\n-                                                caption)\n-                    return True\n-                if fullimage is not None:\n-                    # Check to see if the alt / title tags need setting\n-                    title = aq_acquire(fullimage, \'Title\')()\n-                    if not attributes.get(\'alt\'):\n-                        attributes[\'alt\'] = description or title\n-                    if \'title\' not in attributes:\n-                        attributes[\'title\'] = title\n-                    attrs = six.iteritems(attributes)\n-\n-        # Add the tag to the result\n-        strattrs = ""\n-        for key, value in attrs:\n-            try:\n-                strattrs += \' %s="%s"\' % (key, escape(value, quote=True))\n-            except UnicodeDecodeError:\n-                strattrs += \' %s="%s"\' % (unidecode(key),\n-                                          escape(unidecode(value), quote=True))\n+        # if we are a captioned image within a link, remove and occurrences\n+        # of a tags inside caption template to preserve the outer link\n+        if bool(elem.find_parent(\'a\')):\n+            captioned.a.unwrap()\n \n-        if tag in self.singleton_tags:\n-            self.append_data("<%s%s />" % (tag, strattrs))\n-        else:\n-            self.append_data("<%s%s>" % (tag, strattrs))\n-\n-    def unknown_endtag(self, tag):\n-        """Add the endtag unmodified"""\n-        if tag == \'a\':\n-            self.in_link = False\n-        if tag == \'script\':\n-            self.in_script = False\n-        self.append_data("</%s>" % tag)\n-\n-    def parse_declaration(self, i):\n-        """Fix handling of CDATA sections. Code borrowed from BeautifulSoup.\n-        """\n-        j = None\n-        if self.rawdata[i:i + 9] == \'<![CDATA[\':\n-            k = self.rawdata.find(\']]>\', i)\n-            if k == -1:\n-                k = len(self.rawdata)\n-            data = self.rawdata[i + 9:k]\n-            j = k + 3\n-            self.append_data("<![CDATA[%s]]>" % data)\n-        else:\n-            try:\n-                j = SGMLParser.parse_declaration(self, i)\n-            except SGMLParseError:\n-                toHandle = self.rawdata[i:]\n-                self.handle_data(toHandle)\n-                j = i + len(toHandle)\n-        return j\n-\n-    def getResult(self):\n-        """Return the parsed result and flush it"""\n-        result = "".join(self.pieces)\n-        self.pieces = None\n-        return result\n+        elem.replace_with(captioned)\ndiff --git a/plone/outputfilters/tests/README_py2.rst b/plone/outputfilters/tests/README_py2.rst\nnew file mode 100644\nindex 0000000..0e7dca9\n--- /dev/null\n+++ b/plone/outputfilters/tests/README_py2.rst\n@@ -0,0 +1,85 @@\n+Adding a custom filter\n+======================\n+\n+As an example, the following filter replaces all doubled hyphens ("--") with em\n+dashes ("-"). (Don\'t use the example verbatim, because it doesn\'t parse HTML to\n+apply itself only to text nodes, so will mangle HTML comments.)\n+\n+A filter is a callable which accepts a UTF-8-encoded HTML string as input, and\n+returns a modified UTF-8-encoded HTML string. A return value of ``None`` may be\n+used to indicate that the input should not be modified.\n+\n+Example::\n+\n+    import re\n+    from zope.interface import implements\n+    from plone.outputfilters.interfaces import IFilter\n+\n+    class EmDashAdder(object):\n+        implements(IFilter)\n+        order = 1000\n+\n+        def __init__(self, context, request):\n+            pass\n+\n+        def is_enabled(self):\n+            return True\n+\n+        pattern = re.compile(r\'--\')\n+\n+        def __call__(self, data):\n+            return self.pattern.sub(u\'\\xe2\\x80\\x94\', data)\n+\n+The ``order`` attribute may be used to affect the order in which filters are\n+applied (higher values run later). The is_enabled method should return a boolean\n+indicating whether the filter should be applied.\n+\n+Filters are registered in ZCML as a named multi-adapter of the context and\n+request to IFilter::\n+\n+    >>> from Zope2.App import zcml\n+    >>> import Products.Five\n+    >>> configure = """\n+    ... <configure\n+    ...     xmlns="http://namespaces.zope.org/zope">\n+    ...\n+    ...   <adapter\n+    ...     name="em_dash_adder"\n+    ...     provides="plone.outputfilters.interfaces.IFilter"\n+    ...     for="* *"\n+    ...     factory="plone.outputfilters.filters.example.EmDashAdder"\n+    ...     />\n+    ...\n+    ... </configure>\n+    ... """\n+    >>> zcml.load_config("configure.zcml", Products.Five)\n+    >>> zcml.load_string(configure)\n+\n+Now when text is transformed from text/html to text/x-html-safe, the filter will\n+be applied::\n+\n+    >>> app = layer[\'app\']\n+    >>> portal = layer[\'portal\']\n+    >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n+    ...     \'test--test\', mimetype=\'text/html\', context=portal))\n+    \'test\\xe2\\x80\\x94test\'\n+\n+\n+How it works\n+============\n+\n+``plone.outputfilters`` hooks into the PortalTransforms machinery by installing:\n+\n+1. a new mimetype ("text/x-plone-outputfilters-html")\n+2. a transform from text/html to text/x-plone-outputfilters-html\n+3. a null transform from text/x-plone-outputfilters-html back to text/html\n+4. a "transform policy" for the text/x-html-safe mimetype, which says that text\n+   being transformed to text/x-html-safe must first be transformed to\n+   text/x-plone-outputfilters-html\n+\n+The filter adapters are looked up and applied during the execution of the\n+transform from step #2.\n+\n+This should be considered an implementation detail and may change at some point\n+in the future.\n+\ndiff --git a/plone/outputfilters/tests/test_docs.py b/plone/outputfilters/tests/test_docs.py\nindex 211461f..df7327e 100644\n--- a/plone/outputfilters/tests/test_docs.py\n+++ b/plone/outputfilters/tests/test_docs.py\n@@ -4,17 +4,23 @@\n \n import doctest\n import pprint\n+import six\n import unittest\n \n-\n optionflags = (\n     doctest.ELLIPSIS |\n     doctest.NORMALIZE_WHITESPACE |\n     doctest.REPORT_ONLY_FIRST_FAILURE\n )\n-normal_testfiles = [\n-    \'../README.rst\'\n-]\n+\n+if six.PY3:\n+    normal_testfiles = [\n+        \'../README.rst\'\n+    ]\n+else:\n+    normal_testfiles = [\n+        \'./README_py2.rst\',\n+    ]\n \n \n def test_suite():\n@@ -23,7 +29,7 @@ def test_suite():\n         layered(doctest.DocFileSuite(test,\n                                      optionflags=optionflags,\n                                      globs={\'pprint\': pprint.pprint,\n-                                            }\n+                                            },\n                                      ),\n                 layer=PLONE_OUTPUTFILTERS_FUNCTIONAL_TESTING)\n         for test in normal_testfiles])\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex f9b43f1..789b203 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -33,7 +33,10 @@\n def dummy_image():\n     from plone.namedfile.file import NamedBlobImage\n     filename = join(PREFIX, u\'image.jpg\')\n-    data = open(filename, \'rb\').read()\n+    data = None\n+    with open(filename, \'rb\') as fd:\n+        data = fd.read()\n+        fd.close()\n     return NamedBlobImage(data=data, filename=filename)\n \n \n@@ -75,7 +78,9 @@ def UID(self):\n \n         if HAS_NAMEDFILE:\n             dummy2 = DummyContent2(\'foo2\')\n-            data = open(join(PREFIX, self.image_id), \'rb\').read()\n+            with open(join(PREFIX, self.image_id), \'rb\') as fd:\n+                data = fd.read()\n+                fd.close()\n             dummy2.image = NamedImage(data, \'image/jpeg\', u\'image.jpeg\')\n             self.portal._setObject(\'foo2\', dummy2)\n             self.portal.portal_catalog.catalog_object(self.portal.foo2)\n@@ -192,10 +197,10 @@ def test_resolve_uids_fragment(self):\n \n     def test_resolve_uids_in_image_maps(self):\n         text_in = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n </map>""" % self.UID\n         text_out = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="http://nohost/plone/image.jpg" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" coords="1,2,3,4" href="http://nohost/plone/image.jpg" shape="rect"/>\n </map>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -270,30 +275,31 @@ def test_image_captioning_in_news_item(self):\n \n         # Test captioning\n         output = news_item.text.output\n-        self.assertRegexpMatches(output, r"""<span><dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/(.*?)\\.jpeg" alt="Image" title="Image" height="331" width="500"( ?)/></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<span><dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>\n-</span>""")\n+</span>"""\n+        self._assertTransformsTo(output, text_out)\n \n     def test_image_captioning_absolutizes_uncaptioned_image(self):\n         text_in = """<img src="/image.jpg" />"""\n-        text_out = """<img src="http://nohost/plone/image.jpg" alt="My caption" title="Image" />"""\n+        text_out = """<img alt="My caption" src="http://nohost/plone/image.jpg" title="Image"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_absolute_path(self):\n         text_in = """<img class="captioned" src="/image.jpg"/>"""\n-        text_out = """<dl  class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path(self):\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -313,40 +319,40 @@ def test_image_captioning_relative_path_private_folder(self):\n \n         text_in = """<img class="captioned" src="private/image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/private/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My private image caption</dd>\n+<dt><img alt="My private image caption" height="331" src="http://nohost/plone/private/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My private image caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path_scale(self):\n         text_in = """<img class="captioned" src="image.jpg/@@images/image/thumb"/>"""\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid(self):\n         text_in = """<img class="captioned" src="resolveuid/%s"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_new_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -355,13 +361,13 @@ def test_image_captioning_resolveuid_new_scale_plone_namedfile(self):\n             return\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image/thumb"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_no_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n <dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n@@ -371,47 +377,48 @@ def test_image_captioning_resolveuid_no_scale_plone_namedfile(self):\n             return\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_bad_uid(self):\n-        text_in = """<img src="resolveuid/notauid" width="120" height="144" start="fileopen" alt="Duncan\'s picture" class="image-left captioned" loop="1" />"""\n+        text_in = """<img alt="Duncan\'s picture" class="image-left captioned" height="144" loop="1" src="resolveuid/notauid" start="fileopen" width="120"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale(self):\n-        text_in = """<img src="resolveuid/%s/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale_images_view(self):\n-        text_in = """<img src="resolveuid/%s/@@images/image/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/@@images/image/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_external_url(self):\n-        text_in = """<img src="http://example.com/foo" class="captioned" />"""\n+        text_in = """<img class="captioned" src="http://example.com/foo"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_preserves_custom_attributes(self):\n         text_in = """<img class="captioned" width="42" height="42" foo="bar" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="42" width="42" foo="bar" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" foo="bar" height="42" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="42"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_unquoted_attributes(self):\n         text_in = """<img class=captioned height=144 alt="picture alt text" src="resolveuid/%s" width=120 />""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="picture alt text" title="Image" height="144" width="120" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="picture alt text" height="144" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="120"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_preserves_existing_links(self):\n         text_in = """<a href="/xyzzy" class="link"><img class="image-left captioned" src="image.jpg/@@images/image/thumb"/></a>"""\n-        text_out = """<a href="/xyzzy" class="link"><dl class="image-left captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></dt>\n- <dd class="image-caption">My caption</dd>\n-</dl></a>"""\n+        text_out = """<a class="link" href="/xyzzy"><dl class="image-left captioned">\n+<dt><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></dt>\n+<dd class="image-caption">My caption</dd>\n+</dl>\n+</a>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_non_ascii(self):\n@@ -419,9 +426,9 @@ def test_image_captioning_handles_non_ascii(self):\n         self.portal[\'image.jpg\'].setDescription(\n             u\'Kupu Test Image \\xe5\\xe4\\xf6\')\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n-        text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" width="500" /></dt>\n- <dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n+        text_out = u"""<dl class="captioned">\n+<dt><img alt="Kupu Test Image \\xe5\\xe4\\xf6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xe5\\xe4\\xf6" width="500"/></dt>\n+<dd class="image-caption">Kupu Test Image \\xe5\\xe4\\xf6</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -432,7 +439,7 @@ def test_resolve_uids_with_bigU(self):\n \n     def test_singleton_elements(self):\n         self._assertTransformsTo(\n-            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr />\\r\\n<p>foo</p><br />\')\n+            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr/>\\r\\n<p>foo</p><br/>\')\n \n     def test_no_change_when_a_in_script(self):\n         text_in = """<script>a=\'<a href="">test</a>\';</script>"""\ndiff --git a/setup.py b/setup.py\nindex d784892..daaf6f4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -25,6 +25,7 @@\n           "License :: OSI Approved :: GNU General Public License (GPL)",\n           "Programming Language :: Python",\n           "Programming Language :: Python :: 2.7",\n+          "Programming Language :: Python :: 3.6",\n       ],\n       keywords=\'plone transform filter uid caption\',\n       author=\'David Glick, Plone Foundation\',\n@@ -42,7 +43,8 @@\n           \'Products.PortalTransforms>=2.0a1\',\n           \'setuptools\',\n           \'six\',\n-          \'unidecode\',\n+          \'beautifulsoup4\',\n+          \'lxml\',\n       ],\n       extras_require={\n           \'test\': [\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:16:13+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.outputfilters/commit/7ec4eae8729c741f21de76cff320d0ca52b02a12

start dealing with sgmllib in py3 (TODO: port to BS4)

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex ed2d69d..d587af4 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -8,8 +8,6 @@\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n-from sgmllib import SGMLParseError\n-from sgmllib import SGMLParser\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n@@ -28,6 +26,20 @@\n import re\n import six\n \n+try:\n+    from sgmllib import SGMLParseError\n+    from sgmllib import SGMLParser\n+except ImportError:\n+    # This is probably Python 3, which doesn't include sgmllib anymore\n+    _SGML_AVAILABLE = 0\n+\n+    # Mock sgmllib enough to allow subclassing later on\n+    class SGMLParser(object):\n+        pass\n+\n+    class SGMLParseError(object):\n+        pass\n+\n \n HAS_LINGUAPLONE = True\n try:\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:16:13+02:00
Author: Tobias Herp (tobiasherp) <tobias.herp@visaplan.com>
Commit: https://github.com/plone/plone.outputfilters/commit/7dca1ece5a571761499dcb366ff1dfab82d08bdf

updated .gitignore

Added 3 lines

Files changed:
M .gitignore

b'diff --git a/.gitignore b/.gitignore\nindex 67a7ae8..48f1ce2 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -9,3 +9,6 @@ include/\n parts/\n .installed.cfg\n develop-eggs/\n+eggs/\n+local/\n+pip-selfcheck.json\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:16:13+02:00
Author: Tobias Herp (tobiasherp) <tobias.herp@visaplan.com>
Commit: https://github.com/plone/plone.outputfilters/commit/321dbb9e610f7c1656a7b27bef5e934457acc7c4

use BeautifulSoup 4 instead of SGMLParser (WIP)

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py
M setup.py

b'diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex d587af4..21bcd98 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+# reimplementation, based on lxml instead of SGMLParser\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n@@ -8,6 +9,8 @@\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n+from bs4 import BeautifulSoup\n+# ... import exception class \n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n@@ -74,7 +77,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(SGMLParser):\n+class ResolveUIDAndCaptionFilter(HTMLParser):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -83,13 +86,9 @@ class ResolveUIDAndCaptionFilter(SGMLParser):\n         \'source\', \'track\', \'wbr\'])\n \n     def __init__(self, context=None, request=None):\n-        SGMLParser.__init__(self)\n         self.current_status = None\n         self.context = context\n         self.request = request\n-        self.pieces = []\n-        self.in_link = False\n-        self.in_script = False\n \n     # IFilter implementation\n     order = 800\n@@ -127,43 +126,70 @@ def _shorttag_replace(self, match):\n             return \'<\' + tag + \'></\' + tag + \'>\'\n \n     def __call__(self, data):\n+        # from SGMLParser implementation; still necessary?\n         data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        self.feed(data)\n-        self.close()\n-        return self.getResult()\n-\n-    # SGMLParser implementation\n-\n-    def append_data(self, data, add_eol=0):\n-        """Append data unmodified to self.data, add_eol adds a newline\n-        character"""\n-        if add_eol:\n-            data += \'\\n\'\n-        self.pieces.append(data)\n-\n-    def handle_charref(self, ref):\n-        """ Handle characters, just add them again """\n-        self.append_data("&#%s;" % ref)\n-\n-    def handle_entityref(self, ref):\n-        """ Handle html entities, put them back as we get them """\n-        self.append_data("&%s;" % ref)\n-\n-    def handle_data(self, text):\n-        """ Add data unmodified """\n-        self.append_data(text)\n+        soup = BeautifulSoup(data, \'lxml\')\n+\n+        for elem in soup.find_all([\'a\', \'area\'], \'href\'):\n+            attributes = elem.attrs\n+            href = attributes[\'href\']\n+            changed = False\n+            if 1:\n+                scheme = urlsplit(href)[0]\n+                if not scheme and not href.startswith(\'/\') \\\n+                        and not href.startswith(\'mailto<\') \\\n+                        and not href.startswith(\'mailto:\') \\\n+                        and not href.startswith(\'tel:\') \\\n+                        and not href.startswith(\'#\'):\n+                    obj, subpath, appendix = self.resolve_link(href)\n+                    if obj is not None:\n+                        href = obj.absolute_url()\n+                        if subpath:\n+                            href += \'/\' + subpath\n+                        href += appendix\n+                        changed = True\n+                    elif resolveuid_re.match(href) is None:\n+                        # absolutize relative URIs; this text isn\'t necessarily\n+                        # being rendered in the context where it was stored\n+                        relative_root = self.context\n+                        if not getattr(\n+                                self.context, \'isPrincipiaFolderish\', False):\n+                            relative_root = aq_parent(self.context)\n+                        actual_url = relative_root.absolute_url()\n+                        href = urljoin(actual_url + \'/\', subpath) + appendix\n+                        changed = True\n+                    if not changed:\n+                        continue\n+                    attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\', \'src\'):\n+            attributes = elem.attrs\n+            if 1:\n+                src = attributes.get(\'src\', \'\')\n+                image, fullimage, src, description = self.resolve_image(src)\n+                attributes["src"] = src\n \n-    def handle_comment(self, text):\n-        """ Handle comments unmodified """\n-        self.append_data("<!--%s-->" % text)\n+                if fullimage is not None:\n+                    # Check to see if the alt / title tags need setting\n+                    title = aq_acquire(fullimage, \'Title\')()\n+                    if not attributes.get(\'alt\'):\n+                        # XXX alt attribute contains *alternate* text \n+                        attributes[\'alt\'] = description or title\n+                    if \'title\' not in attributes:\n+                        attributes[\'title\'] = title\n \n-    def handle_pi(self, text):\n-        """ Handle processing instructions unmodified"""\n-        self.append_data("<?%s>" % text)\n+                caption = description\n+                # Check if the image needs to be captioned\n+                if (\n+                    self.captioned_images and\n+                    image is not None and\n+                    caption and\n+                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n+                ):\n+                    self.handle_captioned_image(attributes, image, fullimage,\n+                                                elem, soup,\n+                                                caption)\n \n-    def handle_decl(self, text):\n-        """Handle declarations unmodified """\n-        self.append_data("<!%s>" % text)\n+        return six.text_type(soup)\n \n     def lookup_uid(self, uid):\n         context = self.context\n@@ -281,8 +307,13 @@ def traverse_path(base, path):\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n-    def handle_captioned_image(self, attributes, image, fullimage, caption):\n+    def handle_captioned_image(self, attributes, image, fullimage,\n+                               elem, soup,\n+                               caption):\n         """Handle captioned image.\n+\n+        The img element is replaced by a definition list\n+        as created by the template ../browser/captioned_image.pt\n         """\n         klass = attributes[\'class\']\n         del attributes[\'class\']\n@@ -326,9 +357,16 @@ def handle_captioned_image(self, attributes, image, fullimage, caption):\n             options[\'isfullsize\'] = True\n \n         captioned_html = self.captioned_image_template(**options)\n-        if isinstance(captioned_html, six.text_type):\n-            captioned_html = captioned_html.encode(\'utf8\')\n-        self.append_data(captioned_html)\n+        new_elem = soup.new_tag\n+        if not options[\'isfullsize\']:\n+            a_elem = soup.new_tag(\'a\',\n+                                  rel=\'lightbox\',\n+                                  href=options[\'url_path\'])\n+            elem = elem.wrap(a_elem)\n+        dt = elem.wrap(soup.new_tag(\'dt\')\n+        dl = dt.wrap(soup.new_tag(\'dl\', class_=klass))\n+        dl.append(soup.new_tag(\'dd\', options[\'caption\'])\n+        elem.replace_with(dl)\n \n     def unknown_starttag(self, tag, attrs):\n         """Here we\'ve got the actual conversion of links and images.\n@@ -431,8 +469,8 @@ def parse_declaration(self, i):\n             self.append_data("<![CDATA[%s]]>" % data)\n         else:\n             try:\n-                j = SGMLParser.parse_declaration(self, i)\n-            except SGMLParseError:\n+                j = HTMLParser.parse_declaration(self, i)\n+            except HTMLParseError:\n                 toHandle = self.rawdata[i:]\n                 self.handle_data(toHandle)\n                 j = i + len(toHandle)\ndiff --git a/setup.py b/setup.py\nindex 8ae2573..cea698f 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,6 +43,8 @@\n           \'setuptools\',\n           \'six\',\n           \'unidecode\',\n+          \'beautifulsoup4\',\n+          \'lxml\',\n       ],\n       extras_require={\n           \'test\': [\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:27:15+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/60172ab32f40a8619d997fdaeffb0ccd0ccdfd7f

remove sgmllib completely and fix tests

2 failing tests remaining ... WIP

Files changed:
M CHANGES.rst
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 21b953c..c35cad3 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,7 +10,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- remove deprecated sgmllib and move to BeautifulSoup4\n+  [tobiasherp, petschki]\n \n Bug fixes:\n \ndiff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 21bcd98..c8720d1 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -1,48 +1,29 @@\n # -*- coding: utf-8 -*-\n-# reimplementation, based on lxml instead of SGMLParser\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n-from cgi import escape\n from DocumentTemplate.DT_Util import html_quote\n from DocumentTemplate.DT_Var import newline_to_br\n-from plone.outputfilters.browser.resolveuid import uuidToObject\n-from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n from bs4 import BeautifulSoup\n-# ... import exception class \n+from plone.outputfilters.browser.resolveuid import uuidToObject\n+from plone.outputfilters.interfaces import IFilter\n+from ZODB.POSException import ConflictError\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n-from six.moves.urllib.parse import urlunsplit\n-from unidecode import unidecode\n from zExceptions import NotFound\n-from ZODB.POSException import ConflictError\n from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getAllUtilitiesRegisteredFor\n from zope.component.hooks import getSite\n from zope.interface import Attribute\n-from zope.interface import implementer\n from zope.interface import Interface\n+from zope.interface import implementer\n from zope.publisher.interfaces import NotFound as ztkNotFound\n \n import re\n import six\n \n-try:\n-    from sgmllib import SGMLParseError\n-    from sgmllib import SGMLParser\n-except ImportError:\n-    # This is probably Python 3, which doesn\'t include sgmllib anymore\n-    _SGML_AVAILABLE = 0\n-\n-    # Mock sgmllib enough to allow subclassing later on\n-    class SGMLParser(object):\n-        pass\n-\n-    class SGMLParseError(object):\n-        pass\n-\n \n HAS_LINGUAPLONE = True\n try:\n@@ -51,7 +32,7 @@ class SGMLParseError(object):\n     HAS_LINGUAPLONE = False\n \n \n-appendix_re = re.compile(\'^(.*)([\\?#].*)$\')\n+appendix_re = re.compile(\'^(.*)([?#].*)$\')\n resolveuid_re = re.compile(\'^[./]*resolve[Uu]id/([^/]*)/?(.*)$\')\n \n \n@@ -77,7 +58,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(HTMLParser):\n+class ResolveUIDAndCaptionFilter(object):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -126,68 +107,66 @@ def _shorttag_replace(self, match):\n             return \'<\' + tag + \'></\' + tag + \'>\'\n \n     def __call__(self, data):\n-        # from SGMLParser implementation; still necessary?\n         data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        soup = BeautifulSoup(data, \'lxml\')\n+        soup = BeautifulSoup(data, \'html.parser\')\n \n-        for elem in soup.find_all([\'a\', \'area\'], \'href\'):\n+        for elem in soup.find_all([\'a\', \'area\']):\n             attributes = elem.attrs\n-            href = attributes[\'href\']\n+            href = attributes.get(\'href\')\n+            if href is None:\n+                continue\n             changed = False\n-            if 1:\n-                scheme = urlsplit(href)[0]\n-                if not scheme and not href.startswith(\'/\') \\\n-                        and not href.startswith(\'mailto<\') \\\n-                        and not href.startswith(\'mailto:\') \\\n-                        and not href.startswith(\'tel:\') \\\n-                        and not href.startswith(\'#\'):\n-                    obj, subpath, appendix = self.resolve_link(href)\n-                    if obj is not None:\n-                        href = obj.absolute_url()\n-                        if subpath:\n-                            href += \'/\' + subpath\n-                        href += appendix\n-                        changed = True\n-                    elif resolveuid_re.match(href) is None:\n-                        # absolutize relative URIs; this text isn\'t necessarily\n-                        # being rendered in the context where it was stored\n-                        relative_root = self.context\n-                        if not getattr(\n-                                self.context, \'isPrincipiaFolderish\', False):\n-                            relative_root = aq_parent(self.context)\n-                        actual_url = relative_root.absolute_url()\n-                        href = urljoin(actual_url + \'/\', subpath) + appendix\n-                        changed = True\n-                    if not changed:\n-                        continue\n-                    attributes[\'href\'] = href\n-        for elem in soup.find_all(\'img\', \'src\'):\n+            scheme = urlsplit(href)[0]\n+            if not scheme and not href.startswith(\'/\') \\\n+                    and not href.startswith(\'mailto<\') \\\n+                    and not href.startswith(\'mailto:\') \\\n+                    and not href.startswith(\'tel:\') \\\n+                    and not href.startswith(\'#\'):\n+                obj, subpath, appendix = self.resolve_link(href)\n+                if obj is not None:\n+                    href = obj.absolute_url()\n+                    if subpath:\n+                        href += \'/\' + subpath\n+                    href += appendix\n+                    changed = True\n+                elif resolveuid_re.match(href) is None:\n+                    # absolutize relative URIs; this text isn\'t necessarily\n+                    # being rendered in the context where it was stored\n+                    relative_root = self.context\n+                    if not getattr(\n+                            self.context, \'isPrincipiaFolderish\', False):\n+                        relative_root = aq_parent(self.context)\n+                    actual_url = relative_root.absolute_url()\n+                    href = urljoin(actual_url + \'/\', subpath) + appendix\n+                    changed = True\n+                if not changed:\n+                    continue\n+                attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\'):\n             attributes = elem.attrs\n-            if 1:\n-                src = attributes.get(\'src\', \'\')\n-                image, fullimage, src, description = self.resolve_image(src)\n-                attributes["src"] = src\n-\n-                if fullimage is not None:\n-                    # Check to see if the alt / title tags need setting\n-                    title = aq_acquire(fullimage, \'Title\')()\n-                    if not attributes.get(\'alt\'):\n-                        # XXX alt attribute contains *alternate* text \n-                        attributes[\'alt\'] = description or title\n-                    if \'title\' not in attributes:\n-                        attributes[\'title\'] = title\n-\n-                caption = description\n-                # Check if the image needs to be captioned\n-                if (\n-                    self.captioned_images and\n-                    image is not None and\n-                    caption and\n-                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n-                ):\n-                    self.handle_captioned_image(attributes, image, fullimage,\n-                                                elem, soup,\n-                                                caption)\n+            src = attributes.get(\'src\', \'\')\n+            image, fullimage, src, description = self.resolve_image(src)\n+            attributes["src"] = src\n+\n+            if fullimage is not None:\n+                # Check to see if the alt / title tags need setting\n+                title = aq_acquire(fullimage, \'Title\')()\n+                if not attributes.get(\'alt\'):\n+                    # XXX alt attribute contains *alternate* text\n+                    attributes[\'alt\'] = description or title\n+                if \'title\' not in attributes:\n+                    attributes[\'title\'] = title\n+\n+            caption = description\n+            # Check if the image needs to be captioned\n+            if (\n+                self.captioned_images and\n+                image is not None and\n+                caption and\n+                \'captioned\' in attributes.get(\'class\', [])\n+            ):\n+                self.handle_captioned_image(\n+                    attributes, image, fullimage, elem, caption)\n \n         return six.text_type(soup)\n \n@@ -301,21 +280,18 @@ def traverse_path(base, path):\n             url = image.absolute_url()\n         except AttributeError:\n             return None, None, src, description\n-        if isinstance(url, six.text_type):\n-            url = url.encode(\'utf8\')\n         src = url + appendix\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n     def handle_captioned_image(self, attributes, image, fullimage,\n-                               elem, soup,\n-                               caption):\n+                               elem, caption):\n         """Handle captioned image.\n \n         The img element is replaced by a definition list\n         as created by the template ../browser/captioned_image.pt\n         """\n-        klass = attributes[\'class\']\n+        klass = \' \'.join(attributes[\'class\'])\n         del attributes[\'class\']\n         del attributes[\'src\']\n         if \'width\' in attributes:\n@@ -351,133 +327,7 @@ def handle_captioned_image(self, attributes, image, fullimage,\n                 image.height == original_height),\n             \'width\': attributes.get(\'width\', width),\n         }\n-        if self.in_link:\n-            # Must preserve original link, don\'t overwrite\n-            # with a link to the image\n-            options[\'isfullsize\'] = True\n-\n-        captioned_html = self.captioned_image_template(**options)\n-        new_elem = soup.new_tag\n-        if not options[\'isfullsize\']:\n-            a_elem = soup.new_tag(\'a\',\n-                                  rel=\'lightbox\',\n-                                  href=options[\'url_path\'])\n-            elem = elem.wrap(a_elem)\n-        dt = elem.wrap(soup.new_tag(\'dt\')\n-        dl = dt.wrap(soup.new_tag(\'dl\', class_=klass))\n-        dl.append(soup.new_tag(\'dd\', options[\'caption\'])\n-        elem.replace_with(dl)\n-\n-    def unknown_starttag(self, tag, attrs):\n-        """Here we\'ve got the actual conversion of links and images.\n-\n-        Convert UUID\'s to absolute URLs, and process captioned images to HTML.\n-        """\n-        if tag == \'script\':\n-            self.in_script = True\n-        if tag in [\'a\', \'img\', \'area\'] and not self.in_script:\n-            # Only do something if tag is a link, image, or image map area.\n-\n-            attributes = dict(attrs)\n-            if tag == \'a\':\n-                self.in_link = True\n-            if (tag == \'a\' or tag == \'area\') and \'href\' in attributes:\n-                href = attributes[\'href\']\n-                url_parts = urlsplit(href)\n-                scheme = url_parts[0]\n-                # we are only interested in path and beyond /foo/bar?x=2#abc\n-                path_parts = urlunsplit([\'\', \'\'] + list(url_parts[2:]))\n-                if not href.startswith(\'mailto<\') \\\n-                        and not href.startswith(\'mailto:\') \\\n-                        and not href.startswith(\'tel:\') \\\n-                        and not href.startswith(\'#\'):\n-                    obj, subpath, appendix = self.resolve_link(path_parts)\n-                    if obj is not None:\n-                        href = obj.absolute_url()\n-                        if subpath:\n-                            href += \'/\' + subpath\n-                        href += appendix\n-                    elif resolveuid_re.match(href) is None \\\n-                            and not scheme \\\n-                            and not href.startswith(\'/\'):\n-                        # absolutize relative URIs; this text isn\'t necessarily\n-                        # being rendered in the context where it was stored\n-                        relative_root = self.context\n-                        if not getattr(\n-                                self.context, \'isPrincipiaFolderish\', False):\n-                            relative_root = aq_parent(self.context)\n-                        actual_url = relative_root.absolute_url()\n-                        href = urljoin(actual_url + \'/\', subpath) + appendix\n-                    attributes[\'href\'] = href\n-                    attrs = six.iteritems(attributes)\n-            elif tag == \'img\':\n-                src = attributes.get(\'src\', \'\')\n-                image, fullimage, src, description = self.resolve_image(src)\n-                attributes["src"] = src\n-                caption = description\n-                # Check if the image needs to be captioned\n-                if (\n-                    self.captioned_images and\n-                    image is not None and\n-                    caption and\n-                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n-                ):\n-                    self.handle_captioned_image(attributes, image, fullimage,\n-                                                caption)\n-                    return True\n-                if fullimage is not None:\n-                    # Check to see if the alt / title tags need setting\n-                    title = aq_acquire(fullimage, \'Title\')()\n-                    if not attributes.get(\'alt\'):\n-                        attributes[\'alt\'] = description or title\n-                    if \'title\' not in attributes:\n-                        attributes[\'title\'] = title\n-                    attrs = six.iteritems(attributes)\n-\n-        # Add the tag to the result\n-        strattrs = ""\n-        for key, value in attrs:\n-            try:\n-                strattrs += \' %s="%s"\' % (key, escape(value, quote=True))\n-            except UnicodeDecodeError:\n-                strattrs += \' %s="%s"\' % (unidecode(key),\n-                                          escape(unidecode(value), quote=True))\n \n-        if tag in self.singleton_tags:\n-            self.append_data("<%s%s />" % (tag, strattrs))\n-        else:\n-            self.append_data("<%s%s>" % (tag, strattrs))\n-\n-    def unknown_endtag(self, tag):\n-        """Add the endtag unmodified"""\n-        if tag == \'a\':\n-            self.in_link = False\n-        if tag == \'script\':\n-            self.in_script = False\n-        self.append_data("</%s>" % tag)\n-\n-    def parse_declaration(self, i):\n-        """Fix handling of CDATA sections. Code borrowed from BeautifulSoup.\n-        """\n-        j = None\n-        if self.rawdata[i:i + 9] == \'<![CDATA[\':\n-            k = self.rawdata.find(\']]>\', i)\n-            if k == -1:\n-                k = len(self.rawdata)\n-            data = self.rawdata[i + 9:k]\n-            j = k + 3\n-            self.append_data("<![CDATA[%s]]>" % data)\n-        else:\n-            try:\n-                j = HTMLParser.parse_declaration(self, i)\n-            except HTMLParseError:\n-                toHandle = self.rawdata[i:]\n-                self.handle_data(toHandle)\n-                j = i + len(toHandle)\n-        return j\n-\n-    def getResult(self):\n-        """Return the parsed result and flush it"""\n-        result = "".join(self.pieces)\n-        self.pieces = None\n-        return result\n+        captioned = BeautifulSoup(\n+            self.captioned_image_template(**options), \'html.parser\')\n+        elem.replace_with(captioned)\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex 0de8bf5..fbc8562 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -182,10 +182,10 @@ def test_resolve_uids_fragment(self):\n \n     def test_resolve_uids_in_image_maps(self):\n         text_in = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n </map>""" % self.UID\n         text_out = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="http://nohost/plone/image.jpg" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" coords="1,2,3,4" href="http://nohost/plone/image.jpg" shape="rect"/>\n </map>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -260,30 +260,31 @@ def test_image_captioning_in_news_item(self):\n \n         # Test captioning\n         output = news_item.text.output\n-        self.assertRegexpMatches(output, r"""<span><dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/(.*?)\\.jpeg" alt="Image" title="Image" height="331" width="500"( ?)/></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<span><dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>\n-</span>""")\n+</span>"""\n+        self._assertTransformsTo(output, text_out)\n \n     def test_image_captioning_absolutizes_uncaptioned_image(self):\n         text_in = """<img src="/image.jpg" />"""\n-        text_out = """<img src="http://nohost/plone/image.jpg" alt="My caption" title="Image" />"""\n+        text_out = """<img alt="My caption" src="http://nohost/plone/image.jpg" title="Image"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_absolute_path(self):\n         text_in = """<img class="captioned" src="/image.jpg"/>"""\n-        text_out = """<dl  class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path(self):\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -303,53 +304,53 @@ def test_image_captioning_relative_path_private_folder(self):\n \n         text_in = """<img class="captioned" src="private/image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/private/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My private image caption</dd>\n+<dt><img alt="My private image caption" height="331" src="http://nohost/plone/private/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My private image caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path_scale(self):\n         text_in = """<img class="captioned" src="image.jpg/@@images/image/thumb"/>"""\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid(self):\n         text_in = """<img class="captioned" src="resolveuid/%s"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_new_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_new_scale_plone_namedfile(self):\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image/thumb"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_no_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n <dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n@@ -357,46 +358,46 @@ def test_image_captioning_resolveuid_no_scale(self):\n     def test_image_captioning_resolveuid_no_scale_plone_namedfile(self):\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_bad_uid(self):\n-        text_in = """<img src="resolveuid/notauid" width="120" height="144" start="fileopen" alt="Duncan\'s picture" class="image-left captioned" loop="1" />"""\n+        text_in = """<img alt="Duncan\'s picture" class="image-left captioned" height="144" loop="1" src="resolveuid/notauid" start="fileopen" width="120"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale(self):\n-        text_in = """<img src="resolveuid/%s/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale_images_view(self):\n-        text_in = """<img src="resolveuid/%s/@@images/image/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/@@images/image/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_external_url(self):\n-        text_in = """<img src="http://example.com/foo" class="captioned" />"""\n+        text_in = """<img class="captioned" src="http://example.com/foo"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_preserves_custom_attributes(self):\n         text_in = """<img class="captioned" width="42" height="42" foo="bar" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="42" width="42" foo="bar" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" foo="bar" height="42" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="42"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_unquoted_attributes(self):\n         text_in = """<img class=captioned height=144 alt="picture alt text" src="resolveuid/%s" width=120 />""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="picture alt text" title="Image" height="144" width="120" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="picture alt text" height="144" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="120"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_preserves_existing_links(self):\n         text_in = """<a href="/xyzzy" class="link"><img class="image-left captioned" src="image.jpg/@@images/image/thumb"/></a>"""\n         text_out = """<a href="/xyzzy" class="link"><dl class="image-left captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl></a>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -405,9 +406,9 @@ def test_image_captioning_handles_non_ascii(self):\n         self.portal[\'image.jpg\'].setDescription(\n             u\'Kupu Test Image \\xe5\\xe4\\xf6\')\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n-        text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" width="500" /></dt>\n- <dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n+        text_out = u"""<dl class="captioned">\n+<dt><img alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" width="500" /></dt>\n+<dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -418,7 +419,7 @@ def test_resolve_uids_with_bigU(self):\n \n     def test_singleton_elements(self):\n         self._assertTransformsTo(\n-            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr />\\r\\n<p>foo</p><br />\')\n+            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr/>\\r\\n<p>foo</p><br/>\')\n \n     def test_no_change_when_a_in_script(self):\n         text_in = """<script>a=\'<a href="">test</a>\';</script>"""\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:27:15+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/f1bbf66b18f89a07fab7c04235827f011cfb7aaa

fix failing tests in py2 and py3

Files changed:
M plone/outputfilters/filters/example.py
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b'diff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex e119fd8..9a79ff0 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r\'--\')\n \n     def __call__(self, data):\n-        return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+        return self.pattern.sub(u\'\xe2\x80\x94\', data)\ndiff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex c8720d1..d524b63 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -330,4 +330,10 @@ def handle_captioned_image(self, attributes, image, fullimage,\n \n         captioned = BeautifulSoup(\n             self.captioned_image_template(**options), \'html.parser\')\n+\n+        # if we are a captioned image within a link, remove and occurrences\n+        # of a tags inside caption template to preserve the outer link\n+        if bool(elem.find_parent(\'a\')):\n+            captioned.a.unwrap()\n+\n         elem.replace_with(captioned)\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex fbc8562..3a969ce 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -395,10 +395,11 @@ def test_image_captioning_handles_unquoted_attributes(self):\n \n     def test_image_captioning_preserves_existing_links(self):\n         text_in = """<a href="/xyzzy" class="link"><img class="image-left captioned" src="image.jpg/@@images/image/thumb"/></a>"""\n-        text_out = """<a href="/xyzzy" class="link"><dl class="image-left captioned">\n+        text_out = """<a class="link" href="/xyzzy"><dl class="image-left captioned">\n <dt><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></dt>\n <dd class="image-caption">My caption</dd>\n-</dl></a>"""\n+</dl>\n+</a>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_non_ascii(self):\n@@ -407,8 +408,8 @@ def test_image_captioning_handles_non_ascii(self):\n             u\'Kupu Test Image \\xe5\\xe4\\xf6\')\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n         text_out = u"""<dl class="captioned">\n-<dt><img alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" width="500" /></dt>\n-<dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n+<dt><img alt="Kupu Test Image \\xe5\\xe4\\xf6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xe5\\xe4\\xf6" width="500"/></dt>\n+<dd class="image-caption">Kupu Test Image \\xe5\\xe4\\xf6</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:27:16+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/eb619fd03e1103dff59f3430ab7bbeebff650c9b

try to fix failing doctest for py2 and py3

py2 - fail
py3 - pass

Files changed:
M plone/outputfilters/filters/example.py

b"diff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex 9a79ff0..928d3ca 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r'--')\n \n     def __call__(self, data):\n-        return self.pattern.sub(u'\xe2\x80\x94', data)\n+        return self.pattern.sub(u'\\xe2\\x80\\x94', data)\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:29:51+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/5b061211649cf09699b73752e235ca613fa704d4

fix `ResourceWarning: unclosed file` in tests

Files changed:
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex 3a969ce..ce3abe1 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -21,7 +21,10 @@\n \n def dummy_image():\n     filename = join(PREFIX, u'image.jpg')\n-    data = open(filename, 'rb').read()\n+    data = None\n+    with open(filename, 'rb') as fd:\n+        data = fd.read()\n+        fd.close()\n     return NamedBlobImage(data=data, filename=filename)\n \n \n@@ -61,7 +64,9 @@ def UID(self):\n         self.portal.portal_catalog.catalog_object(self.portal.foo)\n \n         dummy2 = DummyContent2('foo2')\n-        data = open(join(PREFIX, self.image_id), 'rb').read()\n+        with open(join(PREFIX, self.image_id), 'rb') as fd:\n+            data = fd.read()\n+            fd.close()\n         dummy2.image = NamedImage(data, 'image/jpeg', u'image.jpeg')\n         self.portal._setObject('foo2', dummy2)\n         self.portal.portal_catalog.catalog_object(self.portal.foo2)\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:29:51+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/289fb784d54ebd1871ca8879a0e5a82cdb439e4b

test non ascii transforms for py2 and py3

Files changed:
A plone/outputfilters/tests/README_py2.rst
M plone/outputfilters/README.rst
M plone/outputfilters/filters/example.py
M plone/outputfilters/tests/test_docs.py

b'diff --git a/plone/outputfilters/README.rst b/plone/outputfilters/README.rst\nindex bca160d..454b166 100644\n--- a/plone/outputfilters/README.rst\n+++ b/plone/outputfilters/README.rst\n@@ -28,7 +28,7 @@ Example::\n         pattern = re.compile(r\'--\')\n \n         def __call__(self, data):\n-            return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+            return self.pattern.sub(\'\xe2\x80\x94\', data)\n \n The ``order`` attribute may be used to affect the order in which filters are\n applied (higher values run later). The is_enabled method should return a boolean\n@@ -62,7 +62,7 @@ be applied::\n     >>> portal = layer[\'portal\']\n     >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n     ...     \'test--test\', mimetype=\'text/html\', context=portal))\n-    \'test\\xe2\\x80\\x94test\'\n+    \'test\xe2\x80\x94test\'\n \n \n How it works\ndiff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex 928d3ca..9a79ff0 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r\'--\')\n \n     def __call__(self, data):\n-        return self.pattern.sub(u\'\\xe2\\x80\\x94\', data)\n+        return self.pattern.sub(u\'\xe2\x80\x94\', data)\ndiff --git a/plone/outputfilters/tests/README_py2.rst b/plone/outputfilters/tests/README_py2.rst\nnew file mode 100644\nindex 0000000..0e7dca9\n--- /dev/null\n+++ b/plone/outputfilters/tests/README_py2.rst\n@@ -0,0 +1,85 @@\n+Adding a custom filter\n+======================\n+\n+As an example, the following filter replaces all doubled hyphens ("--") with em\n+dashes ("-"). (Don\'t use the example verbatim, because it doesn\'t parse HTML to\n+apply itself only to text nodes, so will mangle HTML comments.)\n+\n+A filter is a callable which accepts a UTF-8-encoded HTML string as input, and\n+returns a modified UTF-8-encoded HTML string. A return value of ``None`` may be\n+used to indicate that the input should not be modified.\n+\n+Example::\n+\n+    import re\n+    from zope.interface import implements\n+    from plone.outputfilters.interfaces import IFilter\n+\n+    class EmDashAdder(object):\n+        implements(IFilter)\n+        order = 1000\n+\n+        def __init__(self, context, request):\n+            pass\n+\n+        def is_enabled(self):\n+            return True\n+\n+        pattern = re.compile(r\'--\')\n+\n+        def __call__(self, data):\n+            return self.pattern.sub(u\'\\xe2\\x80\\x94\', data)\n+\n+The ``order`` attribute may be used to affect the order in which filters are\n+applied (higher values run later). The is_enabled method should return a boolean\n+indicating whether the filter should be applied.\n+\n+Filters are registered in ZCML as a named multi-adapter of the context and\n+request to IFilter::\n+\n+    >>> from Zope2.App import zcml\n+    >>> import Products.Five\n+    >>> configure = """\n+    ... <configure\n+    ...     xmlns="http://namespaces.zope.org/zope">\n+    ...\n+    ...   <adapter\n+    ...     name="em_dash_adder"\n+    ...     provides="plone.outputfilters.interfaces.IFilter"\n+    ...     for="* *"\n+    ...     factory="plone.outputfilters.filters.example.EmDashAdder"\n+    ...     />\n+    ...\n+    ... </configure>\n+    ... """\n+    >>> zcml.load_config("configure.zcml", Products.Five)\n+    >>> zcml.load_string(configure)\n+\n+Now when text is transformed from text/html to text/x-html-safe, the filter will\n+be applied::\n+\n+    >>> app = layer[\'app\']\n+    >>> portal = layer[\'portal\']\n+    >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n+    ...     \'test--test\', mimetype=\'text/html\', context=portal))\n+    \'test\\xe2\\x80\\x94test\'\n+\n+\n+How it works\n+============\n+\n+``plone.outputfilters`` hooks into the PortalTransforms machinery by installing:\n+\n+1. a new mimetype ("text/x-plone-outputfilters-html")\n+2. a transform from text/html to text/x-plone-outputfilters-html\n+3. a null transform from text/x-plone-outputfilters-html back to text/html\n+4. a "transform policy" for the text/x-html-safe mimetype, which says that text\n+   being transformed to text/x-html-safe must first be transformed to\n+   text/x-plone-outputfilters-html\n+\n+The filter adapters are looked up and applied during the execution of the\n+transform from step #2.\n+\n+This should be considered an implementation detail and may change at some point\n+in the future.\n+\ndiff --git a/plone/outputfilters/tests/test_docs.py b/plone/outputfilters/tests/test_docs.py\nindex 211461f..df7327e 100644\n--- a/plone/outputfilters/tests/test_docs.py\n+++ b/plone/outputfilters/tests/test_docs.py\n@@ -4,17 +4,23 @@\n \n import doctest\n import pprint\n+import six\n import unittest\n \n-\n optionflags = (\n     doctest.ELLIPSIS |\n     doctest.NORMALIZE_WHITESPACE |\n     doctest.REPORT_ONLY_FIRST_FAILURE\n )\n-normal_testfiles = [\n-    \'../README.rst\'\n-]\n+\n+if six.PY3:\n+    normal_testfiles = [\n+        \'../README.rst\'\n+    ]\n+else:\n+    normal_testfiles = [\n+        \'./README_py2.rst\',\n+    ]\n \n \n def test_suite():\n@@ -23,7 +29,7 @@ def test_suite():\n         layered(doctest.DocFileSuite(test,\n                                      optionflags=optionflags,\n                                      globs={\'pprint\': pprint.pprint,\n-                                            }\n+                                            },\n                                      ),\n                 layer=PLONE_OUTPUTFILTERS_FUNCTIONAL_TESTING)\n         for test in normal_testfiles])\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:29:51+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/c01492b598dbf311af28b60998128370f1007d61

update classifier

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex cea698f..3d79e26 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -25,6 +25,7 @@\n           "License :: OSI Approved :: GNU General Public License (GPL)",\n           "Programming Language :: Python",\n           "Programming Language :: Python :: 2.7",\n+          "Programming Language :: Python :: 3.6",\n       ],\n       keywords=\'plone transform filter uid caption\',\n       author=\'David Glick, Plone Foundation\',\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:34:07+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/57ea66afdb2aa4b574b1ffcb50123d742ee213b5

rebase python3

Files changed:


b''

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T09:43:21+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/4bfa045499cf733690324552455b1e5bc60b0cff

fix failing tests after rebasing

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py

b'diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex d524b63..4024b94 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -117,11 +117,13 @@ def __call__(self, data):\n                 continue\n             changed = False\n             scheme = urlsplit(href)[0]\n-            if not scheme and not href.startswith(\'/\') \\\n-                    and not href.startswith(\'mailto<\') \\\n-                    and not href.startswith(\'mailto:\') \\\n-                    and not href.startswith(\'tel:\') \\\n-                    and not href.startswith(\'#\'):\n+            if (\n+                not scheme\n+                and not href.startswith(\'mailto<\')\n+                and not href.startswith(\'mailto:\')\n+                and not href.startswith(\'tel:\')\n+                and not href.startswith(\'#\')\n+            ):\n                 obj, subpath, appendix = self.resolve_link(href)\n                 if obj is not None:\n                     href = obj.absolute_url()\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex ce3abe1..ecf4f2a 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -207,7 +207,7 @@ def test_resolve_uids_handles_junk(self):\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_resolve_uids_entities(self):\n-        text_in = """<a href="http://www.example.org/foo?a=1&amp;b=2" class="external-link">example.org</a>"""\n+        text_in = """<a class="external-link" href="http://www.example.org/foo?a=1&amp;b=2">example.org</a>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_resolveuid_view(self):\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-07-18T10:09:19+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.outputfilters/commit/39d8501195dcb6c6bc341a691ef15e4473a2f821

fix resolving absolute /resolveuid/xxx links

changes in https://github.com/plone/plone.outputfilters/commit/d6bf9065018e25b99af1e97c0757e9b2ad3eb5b5 by @tomgross were lost during rebase ... I've took them over ...

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 4024b94..37aefd7 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -12,6 +12,7 @@\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n+from six.moves.urllib.parse import urlunsplit\n from zExceptions import NotFound\n from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getAllUtilitiesRegisteredFor\n@@ -112,26 +113,24 @@ def __call__(self, data):\n \n         for elem in soup.find_all(['a', 'area']):\n             attributes = elem.attrs\n-            href = attributes.get('href')\n-            if href is None:\n-                continue\n-            changed = False\n-            scheme = urlsplit(href)[0]\n-            if (\n-                not scheme\n-                and not href.startswith('mailto<')\n-                and not href.startswith('mailto:')\n-                and not href.startswith('tel:')\n-                and not href.startswith('#')\n-            ):\n-                obj, subpath, appendix = self.resolve_link(href)\n+            href = attributes['href']\n+            url_parts = urlsplit(href)\n+            scheme = url_parts[0]\n+            # we are only interested in path and beyond /foo/bar?x=2#abc\n+            path_parts = urlunsplit(['', ''] + list(url_parts[2:]))\n+            if not href.startswith('mailto<') \\\n+                    and not href.startswith('mailto:') \\\n+                    and not href.startswith('tel:') \\\n+                    and not href.startswith('#'):\n+                obj, subpath, appendix = self.resolve_link(path_parts)\n                 if obj is not None:\n                     href = obj.absolute_url()\n                     if subpath:\n                         href += '/' + subpath\n                     href += appendix\n-                    changed = True\n-                elif resolveuid_re.match(href) is None:\n+                elif resolveuid_re.match(href) is None \\\n+                        and not scheme \\\n+                        and not href.startswith('/'):\n                     # absolutize relative URIs; this text isn't necessarily\n                     # being rendered in the context where it was stored\n                     relative_root = self.context\n@@ -140,9 +139,6 @@ def __call__(self, data):\n                         relative_root = aq_parent(self.context)\n                     actual_url = relative_root.absolute_url()\n                     href = urljoin(actual_url + '/', subpath) + appendix\n-                    changed = True\n-                if not changed:\n-                    continue\n                 attributes['href'] = href\n         for elem in soup.find_all('img'):\n             attributes = elem.attrs\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-10-02T11:34:38+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.outputfilters/commit/0f90bd4c66b054a13d5502df1ab926de98d0fadc

BeautifulSoup needs to be feeded unicode in order to work properly with non-ascii

Files changed:
M plone/outputfilters/filters/resolveuid_and_caption.py

b"diff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex 37aefd7..096266d 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -2,24 +2,25 @@\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n+from bs4 import BeautifulSoup\n from DocumentTemplate.DT_Util import html_quote\n from DocumentTemplate.DT_Var import newline_to_br\n-from Products.CMFCore.interfaces import IContentish\n-from bs4 import BeautifulSoup\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n-from ZODB.POSException import ConflictError\n+from Products.CMFCore.interfaces import IContentish\n+from Products.CMFPlone.utils import safe_unicode\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n from six.moves.urllib.parse import urlunsplit\n from zExceptions import NotFound\n+from ZODB.POSException import ConflictError\n from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getAllUtilitiesRegisteredFor\n from zope.component.hooks import getSite\n from zope.interface import Attribute\n-from zope.interface import Interface\n from zope.interface import implementer\n+from zope.interface import Interface\n from zope.publisher.interfaces import NotFound as ztkNotFound\n \n import re\n@@ -109,7 +110,7 @@ def _shorttag_replace(self, match):\n \n     def __call__(self, data):\n         data = re.sub(r'<([^<>\\s]+?)\\s*/>', self._shorttag_replace, data)\n-        soup = BeautifulSoup(data, 'html.parser')\n+        soup = BeautifulSoup(safe_unicode(data), 'html.parser')\n \n         for elem in soup.find_all(['a', 'area']):\n             attributes = elem.attrs\n@@ -165,7 +166,6 @@ def __call__(self, data):\n             ):\n                 self.handle_captioned_image(\n                     attributes, image, fullimage, elem, caption)\n-\n         return six.text_type(soup)\n \n     def lookup_uid(self, uid):\n"

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-10-17T11:35:38+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.outputfilters/commit/3a329d0cb58aba641061df1ab306e0d1d30ea1e3

mark version as feature change

Files changed:
M CHANGES.rst
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex c35cad3..b3d79c7 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,7 +1,7 @@\n Changelog\n =========\n \n-3.0.6 (unreleased)\n+3.1.x (unreleased)\n ------------------\n \n Breaking changes:\ndiff --git a/setup.py b/setup.py\nindex 3d79e26..05090a1 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,60 +5,64 @@\n import os\n \n \n-version = \'3.0.6.dev0\'\n+version = \'3.1.0.dev0\'\n \n-setup(name=\'plone.outputfilters\',\n-      version=version,\n-      description=("Transformations applied to HTML in "\n-                   "Plone text fields as they are rendered"),\n-      long_description=(\n-          open("README.rst").read() + "\\n" +\n-          open(os.path.join("plone", "outputfilters",\n-                            "README.rst")).read() + "\\n" +\n-          open("CHANGES.rst").read()),\n-      # Get more strings from\n-      # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n-      classifiers=[\n-          "Framework :: Plone",\n-          "Framework :: Plone :: 5.0",\n-          "Framework :: Plone :: 5.1",\n-          "License :: OSI Approved :: GNU General Public License (GPL)",\n-          "Programming Language :: Python",\n-          "Programming Language :: Python :: 2.7",\n-          "Programming Language :: Python :: 3.6",\n-      ],\n-      keywords=\'plone transform filter uid caption\',\n-      author=\'David Glick, Plone Foundation\',\n-      author_email=\'davidglick@groundwire.org\',\n-      url=\'http://github.com/plone/plone.outputfilters\',\n-      license=\'GPL\',\n-      packages=find_packages(exclude=[\'ez_setup\']),\n-      namespace_packages=[\'plone\'],\n-      include_package_data=True,\n-      zip_safe=False,\n-      install_requires=[\n-          \'Products.CMFCore\',\n-          \'Products.GenericSetup\',\n-          \'Products.MimetypesRegistry\',\n-          \'Products.PortalTransforms>=2.0a1\',\n-          \'setuptools\',\n-          \'six\',\n-          \'unidecode\',\n-          \'beautifulsoup4\',\n-          \'lxml\',\n-      ],\n-      extras_require={\n-          \'test\': [\n-              \'plone.app.contenttypes\',\n-              \'plone.app.testing\',\n-              \'plone.app.robotframework\',\n-              \'plone.namedfile\',\n-          ],\n-      },\n-      entry_points="""\n+setup(\n+    name=\'plone.outputfilters\',\n+    version=version,\n+    description=(\n+        "Transformations applied to HTML in "\n+        "Plone text fields as they are rendered"\n+    ),\n+    long_description=(\n+        open("README.rst").read()\n+        + "\\n"\n+        + open(os.path.join("plone", "outputfilters", "README.rst")).read()\n+        + "\\n"\n+        + open("CHANGES.rst").read()\n+    ),\n+    # Get more strings from\n+    # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n+    classifiers=[\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.2",\n+        "License :: OSI Approved :: GNU General Public License (GPL)",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+    ],\n+    keywords=\'plone transform filter uid caption\',\n+    author=\'David Glick, Plone Foundation\',\n+    author_email=\'davidglick@groundwire.org\',\n+    url=\'http://github.com/plone/plone.outputfilters\',\n+    license=\'GPL\',\n+    packages=find_packages(exclude=[\'ez_setup\']),\n+    namespace_packages=[\'plone\'],\n+    include_package_data=True,\n+    zip_safe=False,\n+    install_requires=[\n+        \'Products.CMFCore\',\n+        \'Products.GenericSetup\',\n+        \'Products.MimetypesRegistry\',\n+        \'Products.PortalTransforms>=2.0a1\',\n+        \'setuptools\',\n+        \'six\',\n+        \'unidecode\',\n+        \'beautifulsoup4\',\n+        \'lxml\',\n+    ],\n+    extras_require={\n+        \'test\': [\n+            \'plone.app.contenttypes\',\n+            \'plone.app.testing\',\n+            \'plone.app.robotframework\',\n+            \'plone.namedfile\',\n+        ]\n+    },\n+    entry_points="""\n       # -*- Entry points: -*-\n \n       [z3c.autoinclude.plugin]\n       target = plone\n       """,\n-      )\n+)\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-10-17T11:40:59+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.outputfilters/commit/735e8cd4067c98c38d00170668fd6f23cf6d8139

merge master

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 05090a1..8f6765b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -21,8 +21,7 @@\n         + "\\n"\n         + open("CHANGES.rst").read()\n     ),\n-    # Get more strings from\n-    # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n+    # Get more strings from https://pypi.org/classifiers/\n     classifiers=[\n         "Framework :: Plone",\n         "Framework :: Plone :: 5.2",\n@@ -36,7 +35,7 @@\n     author_email=\'davidglick@groundwire.org\',\n     url=\'http://github.com/plone/plone.outputfilters\',\n     license=\'GPL\',\n-    packages=find_packages(exclude=[\'ez_setup\']),\n+    packages=find_packages(),\n     namespace_packages=[\'plone\'],\n     include_package_data=True,\n     zip_safe=False,\n'

Repository: plone.outputfilters


Branch: refs/heads/master
Date: 2018-10-17T11:41:29+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.outputfilters/commit/8bf98b659bd4b88968e2cb8ff6bb6c3225a08275

Merge pull request #31 from plone/python3

Python3

Files changed:
A plone/outputfilters/tests/README_py2.rst
M .gitignore
M CHANGES.rst
M plone/outputfilters/README.rst
M plone/outputfilters/filters/example.py
M plone/outputfilters/filters/resolveuid_and_caption.py
M plone/outputfilters/tests/test_docs.py
M plone/outputfilters/tests/test_resolveuid_and_caption.py
M setup.py

b'diff --git a/.gitignore b/.gitignore\nindex 67a7ae8..48f1ce2 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -9,3 +9,6 @@ include/\n parts/\n .installed.cfg\n develop-eggs/\n+eggs/\n+local/\n+pip-selfcheck.json\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 21b953c..b3d79c7 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,7 +1,7 @@\n Changelog\n =========\n \n-3.0.6 (unreleased)\n+3.1.x (unreleased)\n ------------------\n \n Breaking changes:\n@@ -10,7 +10,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- remove deprecated sgmllib and move to BeautifulSoup4\n+  [tobiasherp, petschki]\n \n Bug fixes:\n \ndiff --git a/plone/outputfilters/README.rst b/plone/outputfilters/README.rst\nindex bca160d..454b166 100644\n--- a/plone/outputfilters/README.rst\n+++ b/plone/outputfilters/README.rst\n@@ -28,7 +28,7 @@ Example::\n         pattern = re.compile(r\'--\')\n \n         def __call__(self, data):\n-            return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+            return self.pattern.sub(\'\xe2\x80\x94\', data)\n \n The ``order`` attribute may be used to affect the order in which filters are\n applied (higher values run later). The is_enabled method should return a boolean\n@@ -62,7 +62,7 @@ be applied::\n     >>> portal = layer[\'portal\']\n     >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n     ...     \'test--test\', mimetype=\'text/html\', context=portal))\n-    \'test\\xe2\\x80\\x94test\'\n+    \'test\xe2\x80\x94test\'\n \n \n How it works\ndiff --git a/plone/outputfilters/filters/example.py b/plone/outputfilters/filters/example.py\nindex e119fd8..9a79ff0 100644\n--- a/plone/outputfilters/filters/example.py\n+++ b/plone/outputfilters/filters/example.py\n@@ -18,4 +18,4 @@ def is_enabled(self):\n     pattern = re.compile(r\'--\')\n \n     def __call__(self, data):\n-        return self.pattern.sub(\'\\xe2\\x80\\x94\', data)\n+        return self.pattern.sub(u\'\xe2\x80\x94\', data)\ndiff --git a/plone/outputfilters/filters/resolveuid_and_caption.py b/plone/outputfilters/filters/resolveuid_and_caption.py\nindex ed2d69d..096266d 100644\n--- a/plone/outputfilters/filters/resolveuid_and_caption.py\n+++ b/plone/outputfilters/filters/resolveuid_and_caption.py\n@@ -2,19 +2,17 @@\n from Acquisition import aq_acquire\n from Acquisition import aq_base\n from Acquisition import aq_parent\n-from cgi import escape\n+from bs4 import BeautifulSoup\n from DocumentTemplate.DT_Util import html_quote\n from DocumentTemplate.DT_Var import newline_to_br\n from plone.outputfilters.browser.resolveuid import uuidToObject\n from plone.outputfilters.interfaces import IFilter\n from Products.CMFCore.interfaces import IContentish\n-from sgmllib import SGMLParseError\n-from sgmllib import SGMLParser\n+from Products.CMFPlone.utils import safe_unicode\n from six.moves.urllib.parse import unquote\n from six.moves.urllib.parse import urljoin\n from six.moves.urllib.parse import urlsplit\n from six.moves.urllib.parse import urlunsplit\n-from unidecode import unidecode\n from zExceptions import NotFound\n from ZODB.POSException import ConflictError\n from zope.cachedescriptors.property import Lazy as lazy_property\n@@ -36,7 +34,7 @@\n     HAS_LINGUAPLONE = False\n \n \n-appendix_re = re.compile(\'^(.*)([\\?#].*)$\')\n+appendix_re = re.compile(\'^(.*)([?#].*)$\')\n resolveuid_re = re.compile(\'^[./]*resolve[Uu]id/([^/]*)/?(.*)$\')\n \n \n@@ -62,7 +60,7 @@ def tag(img, **attributes):\n \n \n @implementer(IFilter)\n-class ResolveUIDAndCaptionFilter(SGMLParser):\n+class ResolveUIDAndCaptionFilter(object):\n     """ Parser to convert UUID links and captioned images """\n \n     singleton_tags = set([\n@@ -71,13 +69,9 @@ class ResolveUIDAndCaptionFilter(SGMLParser):\n         \'source\', \'track\', \'wbr\'])\n \n     def __init__(self, context=None, request=None):\n-        SGMLParser.__init__(self)\n         self.current_status = None\n         self.context = context\n         self.request = request\n-        self.pieces = []\n-        self.in_link = False\n-        self.in_script = False\n \n     # IFilter implementation\n     order = 800\n@@ -116,42 +110,63 @@ def _shorttag_replace(self, match):\n \n     def __call__(self, data):\n         data = re.sub(r\'<([^<>\\s]+?)\\s*/>\', self._shorttag_replace, data)\n-        self.feed(data)\n-        self.close()\n-        return self.getResult()\n-\n-    # SGMLParser implementation\n-\n-    def append_data(self, data, add_eol=0):\n-        """Append data unmodified to self.data, add_eol adds a newline\n-        character"""\n-        if add_eol:\n-            data += \'\\n\'\n-        self.pieces.append(data)\n-\n-    def handle_charref(self, ref):\n-        """ Handle characters, just add them again """\n-        self.append_data("&#%s;" % ref)\n-\n-    def handle_entityref(self, ref):\n-        """ Handle html entities, put them back as we get them """\n-        self.append_data("&%s;" % ref)\n-\n-    def handle_data(self, text):\n-        """ Add data unmodified """\n-        self.append_data(text)\n-\n-    def handle_comment(self, text):\n-        """ Handle comments unmodified """\n-        self.append_data("<!--%s-->" % text)\n-\n-    def handle_pi(self, text):\n-        """ Handle processing instructions unmodified"""\n-        self.append_data("<?%s>" % text)\n-\n-    def handle_decl(self, text):\n-        """Handle declarations unmodified """\n-        self.append_data("<!%s>" % text)\n+        soup = BeautifulSoup(safe_unicode(data), \'html.parser\')\n+\n+        for elem in soup.find_all([\'a\', \'area\']):\n+            attributes = elem.attrs\n+            href = attributes[\'href\']\n+            url_parts = urlsplit(href)\n+            scheme = url_parts[0]\n+            # we are only interested in path and beyond /foo/bar?x=2#abc\n+            path_parts = urlunsplit([\'\', \'\'] + list(url_parts[2:]))\n+            if not href.startswith(\'mailto<\') \\\n+                    and not href.startswith(\'mailto:\') \\\n+                    and not href.startswith(\'tel:\') \\\n+                    and not href.startswith(\'#\'):\n+                obj, subpath, appendix = self.resolve_link(path_parts)\n+                if obj is not None:\n+                    href = obj.absolute_url()\n+                    if subpath:\n+                        href += \'/\' + subpath\n+                    href += appendix\n+                elif resolveuid_re.match(href) is None \\\n+                        and not scheme \\\n+                        and not href.startswith(\'/\'):\n+                    # absolutize relative URIs; this text isn\'t necessarily\n+                    # being rendered in the context where it was stored\n+                    relative_root = self.context\n+                    if not getattr(\n+                            self.context, \'isPrincipiaFolderish\', False):\n+                        relative_root = aq_parent(self.context)\n+                    actual_url = relative_root.absolute_url()\n+                    href = urljoin(actual_url + \'/\', subpath) + appendix\n+                attributes[\'href\'] = href\n+        for elem in soup.find_all(\'img\'):\n+            attributes = elem.attrs\n+            src = attributes.get(\'src\', \'\')\n+            image, fullimage, src, description = self.resolve_image(src)\n+            attributes["src"] = src\n+\n+            if fullimage is not None:\n+                # Check to see if the alt / title tags need setting\n+                title = aq_acquire(fullimage, \'Title\')()\n+                if not attributes.get(\'alt\'):\n+                    # XXX alt attribute contains *alternate* text\n+                    attributes[\'alt\'] = description or title\n+                if \'title\' not in attributes:\n+                    attributes[\'title\'] = title\n+\n+            caption = description\n+            # Check if the image needs to be captioned\n+            if (\n+                self.captioned_images and\n+                image is not None and\n+                caption and\n+                \'captioned\' in attributes.get(\'class\', [])\n+            ):\n+                self.handle_captioned_image(\n+                    attributes, image, fullimage, elem, caption)\n+        return six.text_type(soup)\n \n     def lookup_uid(self, uid):\n         context = self.context\n@@ -263,16 +278,18 @@ def traverse_path(base, path):\n             url = image.absolute_url()\n         except AttributeError:\n             return None, None, src, description\n-        if isinstance(url, six.text_type):\n-            url = url.encode(\'utf8\')\n         src = url + appendix\n         description = aq_acquire(fullimage, \'Description\')()\n         return image, fullimage, src, description\n \n-    def handle_captioned_image(self, attributes, image, fullimage, caption):\n+    def handle_captioned_image(self, attributes, image, fullimage,\n+                               elem, caption):\n         """Handle captioned image.\n+\n+        The img element is replaced by a definition list\n+        as created by the template ../browser/captioned_image.pt\n         """\n-        klass = attributes[\'class\']\n+        klass = \' \'.join(attributes[\'class\'])\n         del attributes[\'class\']\n         del attributes[\'src\']\n         if \'width\' in attributes:\n@@ -308,126 +325,13 @@ def handle_captioned_image(self, attributes, image, fullimage, caption):\n                 image.height == original_height),\n             \'width\': attributes.get(\'width\', width),\n         }\n-        if self.in_link:\n-            # Must preserve original link, don\'t overwrite\n-            # with a link to the image\n-            options[\'isfullsize\'] = True\n \n-        captioned_html = self.captioned_image_template(**options)\n-        if isinstance(captioned_html, six.text_type):\n-            captioned_html = captioned_html.encode(\'utf8\')\n-        self.append_data(captioned_html)\n+        captioned = BeautifulSoup(\n+            self.captioned_image_template(**options), \'html.parser\')\n \n-    def unknown_starttag(self, tag, attrs):\n-        """Here we\'ve got the actual conversion of links and images.\n-\n-        Convert UUID\'s to absolute URLs, and process captioned images to HTML.\n-        """\n-        if tag == \'script\':\n-            self.in_script = True\n-        if tag in [\'a\', \'img\', \'area\'] and not self.in_script:\n-            # Only do something if tag is a link, image, or image map area.\n-\n-            attributes = dict(attrs)\n-            if tag == \'a\':\n-                self.in_link = True\n-            if (tag == \'a\' or tag == \'area\') and \'href\' in attributes:\n-                href = attributes[\'href\']\n-                url_parts = urlsplit(href)\n-                scheme = url_parts[0]\n-                # we are only interested in path and beyond /foo/bar?x=2#abc\n-                path_parts = urlunsplit([\'\', \'\'] + list(url_parts[2:]))\n-                if not href.startswith(\'mailto<\') \\\n-                        and not href.startswith(\'mailto:\') \\\n-                        and not href.startswith(\'tel:\') \\\n-                        and not href.startswith(\'#\'):\n-                    obj, subpath, appendix = self.resolve_link(path_parts)\n-                    if obj is not None:\n-                        href = obj.absolute_url()\n-                        if subpath:\n-                            href += \'/\' + subpath\n-                        href += appendix\n-                    elif resolveuid_re.match(href) is None \\\n-                            and not scheme \\\n-                            and not href.startswith(\'/\'):\n-                        # absolutize relative URIs; this text isn\'t necessarily\n-                        # being rendered in the context where it was stored\n-                        relative_root = self.context\n-                        if not getattr(\n-                                self.context, \'isPrincipiaFolderish\', False):\n-                            relative_root = aq_parent(self.context)\n-                        actual_url = relative_root.absolute_url()\n-                        href = urljoin(actual_url + \'/\', subpath) + appendix\n-                    attributes[\'href\'] = href\n-                    attrs = six.iteritems(attributes)\n-            elif tag == \'img\':\n-                src = attributes.get(\'src\', \'\')\n-                image, fullimage, src, description = self.resolve_image(src)\n-                attributes["src"] = src\n-                caption = description\n-                # Check if the image needs to be captioned\n-                if (\n-                    self.captioned_images and\n-                    image is not None and\n-                    caption and\n-                    \'captioned\' in attributes.get(\'class\', \'\').split(\' \')\n-                ):\n-                    self.handle_captioned_image(attributes, image, fullimage,\n-                                                caption)\n-                    return True\n-                if fullimage is not None:\n-                    # Check to see if the alt / title tags need setting\n-                    title = aq_acquire(fullimage, \'Title\')()\n-                    if not attributes.get(\'alt\'):\n-                        attributes[\'alt\'] = description or title\n-                    if \'title\' not in attributes:\n-                        attributes[\'title\'] = title\n-                    attrs = six.iteritems(attributes)\n-\n-        # Add the tag to the result\n-        strattrs = ""\n-        for key, value in attrs:\n-            try:\n-                strattrs += \' %s="%s"\' % (key, escape(value, quote=True))\n-            except UnicodeDecodeError:\n-                strattrs += \' %s="%s"\' % (unidecode(key),\n-                                          escape(unidecode(value), quote=True))\n+        # if we are a captioned image within a link, remove and occurrences\n+        # of a tags inside caption template to preserve the outer link\n+        if bool(elem.find_parent(\'a\')):\n+            captioned.a.unwrap()\n \n-        if tag in self.singleton_tags:\n-            self.append_data("<%s%s />" % (tag, strattrs))\n-        else:\n-            self.append_data("<%s%s>" % (tag, strattrs))\n-\n-    def unknown_endtag(self, tag):\n-        """Add the endtag unmodified"""\n-        if tag == \'a\':\n-            self.in_link = False\n-        if tag == \'script\':\n-            self.in_script = False\n-        self.append_data("</%s>" % tag)\n-\n-    def parse_declaration(self, i):\n-        """Fix handling of CDATA sections. Code borrowed from BeautifulSoup.\n-        """\n-        j = None\n-        if self.rawdata[i:i + 9] == \'<![CDATA[\':\n-            k = self.rawdata.find(\']]>\', i)\n-            if k == -1:\n-                k = len(self.rawdata)\n-            data = self.rawdata[i + 9:k]\n-            j = k + 3\n-            self.append_data("<![CDATA[%s]]>" % data)\n-        else:\n-            try:\n-                j = SGMLParser.parse_declaration(self, i)\n-            except SGMLParseError:\n-                toHandle = self.rawdata[i:]\n-                self.handle_data(toHandle)\n-                j = i + len(toHandle)\n-        return j\n-\n-    def getResult(self):\n-        """Return the parsed result and flush it"""\n-        result = "".join(self.pieces)\n-        self.pieces = None\n-        return result\n+        elem.replace_with(captioned)\ndiff --git a/plone/outputfilters/tests/README_py2.rst b/plone/outputfilters/tests/README_py2.rst\nnew file mode 100644\nindex 0000000..0e7dca9\n--- /dev/null\n+++ b/plone/outputfilters/tests/README_py2.rst\n@@ -0,0 +1,85 @@\n+Adding a custom filter\n+======================\n+\n+As an example, the following filter replaces all doubled hyphens ("--") with em\n+dashes ("-"). (Don\'t use the example verbatim, because it doesn\'t parse HTML to\n+apply itself only to text nodes, so will mangle HTML comments.)\n+\n+A filter is a callable which accepts a UTF-8-encoded HTML string as input, and\n+returns a modified UTF-8-encoded HTML string. A return value of ``None`` may be\n+used to indicate that the input should not be modified.\n+\n+Example::\n+\n+    import re\n+    from zope.interface import implements\n+    from plone.outputfilters.interfaces import IFilter\n+\n+    class EmDashAdder(object):\n+        implements(IFilter)\n+        order = 1000\n+\n+        def __init__(self, context, request):\n+            pass\n+\n+        def is_enabled(self):\n+            return True\n+\n+        pattern = re.compile(r\'--\')\n+\n+        def __call__(self, data):\n+            return self.pattern.sub(u\'\\xe2\\x80\\x94\', data)\n+\n+The ``order`` attribute may be used to affect the order in which filters are\n+applied (higher values run later). The is_enabled method should return a boolean\n+indicating whether the filter should be applied.\n+\n+Filters are registered in ZCML as a named multi-adapter of the context and\n+request to IFilter::\n+\n+    >>> from Zope2.App import zcml\n+    >>> import Products.Five\n+    >>> configure = """\n+    ... <configure\n+    ...     xmlns="http://namespaces.zope.org/zope">\n+    ...\n+    ...   <adapter\n+    ...     name="em_dash_adder"\n+    ...     provides="plone.outputfilters.interfaces.IFilter"\n+    ...     for="* *"\n+    ...     factory="plone.outputfilters.filters.example.EmDashAdder"\n+    ...     />\n+    ...\n+    ... </configure>\n+    ... """\n+    >>> zcml.load_config("configure.zcml", Products.Five)\n+    >>> zcml.load_string(configure)\n+\n+Now when text is transformed from text/html to text/x-html-safe, the filter will\n+be applied::\n+\n+    >>> app = layer[\'app\']\n+    >>> portal = layer[\'portal\']\n+    >>> str(portal.portal_transforms.convertTo(\'text/x-html-safe\',\n+    ...     \'test--test\', mimetype=\'text/html\', context=portal))\n+    \'test\\xe2\\x80\\x94test\'\n+\n+\n+How it works\n+============\n+\n+``plone.outputfilters`` hooks into the PortalTransforms machinery by installing:\n+\n+1. a new mimetype ("text/x-plone-outputfilters-html")\n+2. a transform from text/html to text/x-plone-outputfilters-html\n+3. a null transform from text/x-plone-outputfilters-html back to text/html\n+4. a "transform policy" for the text/x-html-safe mimetype, which says that text\n+   being transformed to text/x-html-safe must first be transformed to\n+   text/x-plone-outputfilters-html\n+\n+The filter adapters are looked up and applied during the execution of the\n+transform from step #2.\n+\n+This should be considered an implementation detail and may change at some point\n+in the future.\n+\ndiff --git a/plone/outputfilters/tests/test_docs.py b/plone/outputfilters/tests/test_docs.py\nindex 211461f..df7327e 100644\n--- a/plone/outputfilters/tests/test_docs.py\n+++ b/plone/outputfilters/tests/test_docs.py\n@@ -4,17 +4,23 @@\n \n import doctest\n import pprint\n+import six\n import unittest\n \n-\n optionflags = (\n     doctest.ELLIPSIS |\n     doctest.NORMALIZE_WHITESPACE |\n     doctest.REPORT_ONLY_FIRST_FAILURE\n )\n-normal_testfiles = [\n-    \'../README.rst\'\n-]\n+\n+if six.PY3:\n+    normal_testfiles = [\n+        \'../README.rst\'\n+    ]\n+else:\n+    normal_testfiles = [\n+        \'./README_py2.rst\',\n+    ]\n \n \n def test_suite():\n@@ -23,7 +29,7 @@ def test_suite():\n         layered(doctest.DocFileSuite(test,\n                                      optionflags=optionflags,\n                                      globs={\'pprint\': pprint.pprint,\n-                                            }\n+                                            },\n                                      ),\n                 layer=PLONE_OUTPUTFILTERS_FUNCTIONAL_TESTING)\n         for test in normal_testfiles])\ndiff --git a/plone/outputfilters/tests/test_resolveuid_and_caption.py b/plone/outputfilters/tests/test_resolveuid_and_caption.py\nindex 0de8bf5..ecf4f2a 100644\n--- a/plone/outputfilters/tests/test_resolveuid_and_caption.py\n+++ b/plone/outputfilters/tests/test_resolveuid_and_caption.py\n@@ -21,7 +21,10 @@\n \n def dummy_image():\n     filename = join(PREFIX, u\'image.jpg\')\n-    data = open(filename, \'rb\').read()\n+    data = None\n+    with open(filename, \'rb\') as fd:\n+        data = fd.read()\n+        fd.close()\n     return NamedBlobImage(data=data, filename=filename)\n \n \n@@ -61,7 +64,9 @@ def UID(self):\n         self.portal.portal_catalog.catalog_object(self.portal.foo)\n \n         dummy2 = DummyContent2(\'foo2\')\n-        data = open(join(PREFIX, self.image_id), \'rb\').read()\n+        with open(join(PREFIX, self.image_id), \'rb\') as fd:\n+            data = fd.read()\n+            fd.close()\n         dummy2.image = NamedImage(data, \'image/jpeg\', u\'image.jpeg\')\n         self.portal._setObject(\'foo2\', dummy2)\n         self.portal.portal_catalog.catalog_object(self.portal.foo2)\n@@ -182,10 +187,10 @@ def test_resolve_uids_fragment(self):\n \n     def test_resolve_uids_in_image_maps(self):\n         text_in = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" href="resolveuid/%s" coords="1,2,3,4" shape="rect" />\n </map>""" % self.UID\n         text_out = """<map id="the_map" name="the_map">\n- <area alt="alpha" href="http://nohost/plone/image.jpg" coords="1,2,3,4" shape="rect" />\n+<area alt="alpha" coords="1,2,3,4" href="http://nohost/plone/image.jpg" shape="rect"/>\n </map>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -202,7 +207,7 @@ def test_resolve_uids_handles_junk(self):\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_resolve_uids_entities(self):\n-        text_in = """<a href="http://www.example.org/foo?a=1&amp;b=2" class="external-link">example.org</a>"""\n+        text_in = """<a class="external-link" href="http://www.example.org/foo?a=1&amp;b=2">example.org</a>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_resolveuid_view(self):\n@@ -260,30 +265,31 @@ def test_image_captioning_in_news_item(self):\n \n         # Test captioning\n         output = news_item.text.output\n-        self.assertRegexpMatches(output, r"""<span><dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/(.*?)\\.jpeg" alt="Image" title="Image" height="331" width="500"( ?)/></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<span><dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>\n-</span>""")\n+</span>"""\n+        self._assertTransformsTo(output, text_out)\n \n     def test_image_captioning_absolutizes_uncaptioned_image(self):\n         text_in = """<img src="/image.jpg" />"""\n-        text_out = """<img src="http://nohost/plone/image.jpg" alt="My caption" title="Image" />"""\n+        text_out = """<img alt="My caption" src="http://nohost/plone/image.jpg" title="Image"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_absolute_path(self):\n         text_in = """<img class="captioned" src="/image.jpg"/>"""\n-        text_out = """<dl  class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+        text_out = """<dl class="captioned">\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path(self):\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -303,53 +309,53 @@ def test_image_captioning_relative_path_private_folder(self):\n \n         text_in = """<img class="captioned" src="private/image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/private/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My private image caption</dd>\n+<dt><img alt="My private image caption" height="331" src="http://nohost/plone/private/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My private image caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_relative_path_scale(self):\n         text_in = """<img class="captioned" src="image.jpg/@@images/image/thumb"/>"""\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid(self):\n         text_in = """<img class="captioned" src="resolveuid/%s"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_new_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image/thumb"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><a rel="lightbox" href="/plone/image.jpg"><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></a></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><a href="/plone/image.jpg" rel="lightbox"><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></a></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_new_scale_plone_namedfile(self):\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image/thumb"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_resolveuid_no_scale(self):\n         text_in = """<img class="captioned" src="resolveuid/%s/@@images/image"/>""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="331" width="500" /></dt>\n+<dt><img alt="My caption" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="500"/></dt>\n <dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n@@ -357,47 +363,48 @@ def test_image_captioning_resolveuid_no_scale(self):\n     def test_image_captioning_resolveuid_no_scale_plone_namedfile(self):\n         self._makeDummyContent()\n         text_in = """<img class="captioned" src="resolveuid/foo2/@@images/image"/>"""\n-        text_out = """<img src="http://nohost/plone/foo2/@@images/....jpeg" alt="foo2" class="captioned" title="foo2" />"""\n+        text_out = """<img alt="foo2" class="captioned" src="http://nohost/plone/foo2/@@images/...jpeg" title="foo2"/>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_bad_uid(self):\n-        text_in = """<img src="resolveuid/notauid" width="120" height="144" start="fileopen" alt="Duncan\'s picture" class="image-left captioned" loop="1" />"""\n+        text_in = """<img alt="Duncan\'s picture" class="image-left captioned" height="144" loop="1" src="resolveuid/notauid" start="fileopen" width="120"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale(self):\n-        text_in = """<img src="resolveuid/%s/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_unknown_scale_images_view(self):\n-        text_in = """<img src="resolveuid/%s/@@images/image/madeup" />""" % self.UID\n+        text_in = """<img src="resolveuid/%s/@@images/image/madeup"/>""" % self.UID\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_external_url(self):\n-        text_in = """<img src="http://example.com/foo" class="captioned" />"""\n+        text_in = """<img class="captioned" src="http://example.com/foo"/>"""\n         self._assertTransformsTo(text_in, text_in)\n \n     def test_image_captioning_preserves_custom_attributes(self):\n         text_in = """<img class="captioned" width="42" height="42" foo="bar" src="image.jpg"/>"""\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="42" width="42" foo="bar" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="My caption" foo="bar" height="42" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="42"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_unquoted_attributes(self):\n         text_in = """<img class=captioned height=144 alt="picture alt text" src="resolveuid/%s" width=120 />""" % self.UID\n         text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="picture alt text" title="Image" height="144" width="120" /></dt>\n- <dd class="image-caption">My caption</dd>\n+<dt><img alt="picture alt text" height="144" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="120"/></dt>\n+<dd class="image-caption">My caption</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_preserves_existing_links(self):\n         text_in = """<a href="/xyzzy" class="link"><img class="image-left captioned" src="image.jpg/@@images/image/thumb"/></a>"""\n-        text_out = """<a href="/xyzzy" class="link"><dl class="image-left captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/....jpeg" alt="Image" title="Image" height="84" width="128" /></dt>\n- <dd class="image-caption">My caption</dd>\n-</dl></a>"""\n+        text_out = """<a class="link" href="/xyzzy"><dl class="image-left captioned">\n+<dt><img alt="My caption" height="84" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Image" width="128"/></dt>\n+<dd class="image-caption">My caption</dd>\n+</dl>\n+</a>"""\n         self._assertTransformsTo(text_in, text_out)\n \n     def test_image_captioning_handles_non_ascii(self):\n@@ -405,9 +412,9 @@ def test_image_captioning_handles_non_ascii(self):\n         self.portal[\'image.jpg\'].setDescription(\n             u\'Kupu Test Image \\xe5\\xe4\\xf6\')\n         text_in = """<img class="captioned" src="image.jpg"/>"""\n-        text_out = """<dl class="captioned">\n-<dt><img src="http://nohost/plone/image.jpg/@@images/...jpeg" alt="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" title="Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6" height="331" width="500" /></dt>\n- <dd class="image-caption">Kupu Test Image \\xc3\\xa5\\xc3\\xa4\\xc3\\xb6</dd>\n+        text_out = u"""<dl class="captioned">\n+<dt><img alt="Kupu Test Image \\xe5\\xe4\\xf6" height="331" src="http://nohost/plone/image.jpg/@@images/...jpeg" title="Kupu Test Image \\xe5\\xe4\\xf6" width="500"/></dt>\n+<dd class="image-caption">Kupu Test Image \\xe5\\xe4\\xf6</dd>\n </dl>"""\n         self._assertTransformsTo(text_in, text_out)\n \n@@ -418,7 +425,7 @@ def test_resolve_uids_with_bigU(self):\n \n     def test_singleton_elements(self):\n         self._assertTransformsTo(\n-            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr />\\r\\n<p>foo</p><br />\')\n+            \'<hr/>\\r\\n<p>foo</p><br/>\', \'<hr/>\\r\\n<p>foo</p><br/>\')\n \n     def test_no_change_when_a_in_script(self):\n         text_in = """<script>a=\'<a href="">test</a>\';</script>"""\ndiff --git a/setup.py b/setup.py\nindex c877fbb..8f6765b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,58 +5,63 @@\n import os\n \n \n-version = \'3.0.6.dev0\'\n+version = \'3.1.0.dev0\'\n \n-setup(name=\'plone.outputfilters\',\n-      version=version,\n-      description=("Transformations applied to HTML in "\n-                   "Plone text fields as they are rendered"),\n-      long_description=(\n-          open("README.rst").read() + "\\n" +\n-          open(os.path.join("plone", "outputfilters",\n-                            "README.rst")).read() + "\\n" +\n-          open("CHANGES.rst").read()),\n-      # Get more strings from\n-      # https://pypi.org/classifiers/\n-      classifiers=[\n-          "Framework :: Plone",\n-          "Framework :: Plone :: 5.0",\n-          "Framework :: Plone :: 5.1",\n-          "Framework :: Plone :: 5.2",\n-          "License :: OSI Approved :: GNU General Public License (GPL)",\n-          "Programming Language :: Python",\n-          "Programming Language :: Python :: 2.7",\n-      ],\n-      keywords=\'plone transform filter uid caption\',\n-      author=\'David Glick, Plone Foundation\',\n-      author_email=\'davidglick@groundwire.org\',\n-      url=\'http://github.com/plone/plone.outputfilters\',\n-      license=\'GPL\',\n-      packages=find_packages(),\n-      namespace_packages=[\'plone\'],\n-      include_package_data=True,\n-      zip_safe=False,\n-      install_requires=[\n-          \'Products.CMFCore\',\n-          \'Products.GenericSetup\',\n-          \'Products.MimetypesRegistry\',\n-          \'Products.PortalTransforms>=2.0a1\',\n-          \'setuptools\',\n-          \'six\',\n-          \'unidecode\',\n-      ],\n-      extras_require={\n-          \'test\': [\n-              \'plone.app.contenttypes\',\n-              \'plone.app.testing\',\n-              \'plone.app.robotframework\',\n-              \'plone.namedfile\',\n-          ],\n-      },\n-      entry_points="""\n+setup(\n+    name=\'plone.outputfilters\',\n+    version=version,\n+    description=(\n+        "Transformations applied to HTML in "\n+        "Plone text fields as they are rendered"\n+    ),\n+    long_description=(\n+        open("README.rst").read()\n+        + "\\n"\n+        + open(os.path.join("plone", "outputfilters", "README.rst")).read()\n+        + "\\n"\n+        + open("CHANGES.rst").read()\n+    ),\n+    # Get more strings from https://pypi.org/classifiers/\n+    classifiers=[\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.2",\n+        "License :: OSI Approved :: GNU General Public License (GPL)",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+    ],\n+    keywords=\'plone transform filter uid caption\',\n+    author=\'David Glick, Plone Foundation\',\n+    author_email=\'davidglick@groundwire.org\',\n+    url=\'http://github.com/plone/plone.outputfilters\',\n+    license=\'GPL\',\n+    packages=find_packages(),\n+    namespace_packages=[\'plone\'],\n+    include_package_data=True,\n+    zip_safe=False,\n+    install_requires=[\n+        \'Products.CMFCore\',\n+        \'Products.GenericSetup\',\n+        \'Products.MimetypesRegistry\',\n+        \'Products.PortalTransforms>=2.0a1\',\n+        \'setuptools\',\n+        \'six\',\n+        \'unidecode\',\n+        \'beautifulsoup4\',\n+        \'lxml\',\n+    ],\n+    extras_require={\n+        \'test\': [\n+            \'plone.app.contenttypes\',\n+            \'plone.app.testing\',\n+            \'plone.app.robotframework\',\n+            \'plone.namedfile\',\n+        ]\n+    },\n+    entry_points="""\n       # -*- Entry points: -*-\n \n       [z3c.autoinclude.plugin]\n       target = plone\n       """,\n-      )\n+)\n'

