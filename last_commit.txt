Repository: plone.dexterity


Branch: refs/heads/2.6.x
Date: 2020-02-03T15:46:59+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.dexterity/commit/984f8f8eead3866f2a9f7785c910d7540ac3a9a1

Backport https://github.com/plone/plone.dexterity/pull/119/ for 2.6.x

Files changed:
A news/120.bugfix
M plone/dexterity/content.py

b"diff --git a/news/120.bugfix b/news/120.bugfix\nnew file mode 100644\nindex 0000000..0bf0f63\n--- /dev/null\n+++ b/news/120.bugfix\n@@ -0,0 +1 @@\n+- Fix thread safe recursion detection. This fixes an issue in plone.restapi: https://github.com/plone/plone.dexterity/issues/120. (Backport of https://github.com/plone/plone.dexterity/pull/119) [jensens]\ndiff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex 7f08793..8751f90 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -48,10 +48,12 @@\n from zope.security.interfaces import IPermission\n \n import six\n+import threading\n \n \n _marker = object()\n _zone = DateTime().timezone()\n+_recursion_detection = threading.local()\n FLOOR_DATE = DateTime(1970, 0)  # always effective\n CEILING_DATE = DateTime(2500, 0)  # never expires\n \n@@ -84,13 +86,12 @@ def __get__(self, inst, cls=None):\n         if inst is None:\n             return getObjectSpecification(cls)\n \n-        direct_spec = getattr(inst, '__provides__', None)\n+        # get direct specification\n+        spec = getattr(inst, '__provides__', None)\n \n         # avoid recursion - fall back on default\n-        if getattr(self, '__recursion__', False):\n-            return direct_spec\n-\n-        spec = direct_spec\n+        if getattr(_recursion_detection, 'blocked', False):\n+            return spec\n \n         # If the instance doesn't have a __provides__ attribute, get the\n         # interfaces implied by the class as a starting point.\n@@ -117,7 +118,7 @@ def __get__(self, inst, cls=None):\n             inst._p_mtime,\n             SCHEMA_CACHE.modified(portal_type),\n             SCHEMA_CACHE.invalidations,\n-            hash(direct_spec)\n+            hash(spec)\n         )\n         if cache is not None and cache[:-1] == updated:\n             if cache[-1] is not None:\n@@ -131,7 +132,7 @@ def __get__(self, inst, cls=None):\n             dynamically_provided = []\n \n         # block recursion\n-        self.__recursion__ = True\n+        setattr(_recursion_detection, 'blocked', True)\n         try:\n             assignable = IBehaviorAssignable(inst, None)\n             if assignable is not None:\n@@ -141,7 +142,7 @@ def __get__(self, inst, cls=None):\n                             behavior_registration.marker\n                         )\n         finally:\n-            del self.__recursion__\n+            setattr(_recursion_detection, 'blocked', False)\n \n         if not dynamically_provided:\n             # rare case if no schema nor behaviors with markers are set\n"

