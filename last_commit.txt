Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2020-02-11T14:15:58+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/027e27d62ddad88798dd18bd73b3601104471c13

Integrate PloneHotFix20200121: add more permission checks.

See https://plone.org/security/hotfix/20200121/privilege-escalation-for-overwriting-content

Files changed:
A news/3021.bugfix
A plone/app/contenttypes/tests/test_security.py
M plone/app/contenttypes/content.py

b'diff --git a/news/3021.bugfix b/news/3021.bugfix\nnew file mode 100644\nindex 00000000..d59b64e0\n--- /dev/null\n+++ b/news/3021.bugfix\n@@ -0,0 +1,3 @@\n+Integrate PloneHotFix20200121: add more permission checks.\n+See https://plone.org/security/hotfix/20200121/privilege-escalation-for-overwriting-content\n+[maurits]\ndiff --git a/plone/app/contenttypes/content.py b/plone/app/contenttypes/content.py\nindex d191da2e..d4f8537b 100644\n--- a/plone/app/contenttypes/content.py\n+++ b/plone/app/contenttypes/content.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from AccessControl.SecurityInfo import ClassSecurityInfo\n from email.feedparser import headerRE\n from plone.app.contenttypes.interfaces import ICollection\n from plone.app.contenttypes.interfaces import IDocument\n@@ -12,6 +13,7 @@\n from plone.dexterity.content import Item\n from plone.namedfile.file import NamedBlobFile\n from plone.namedfile.file import NamedBlobImage\n+from Products.CMFCore import permissions\n from Products.CMFPlone.utils import safe_text\n from zope.deprecation import deprecation\n from zope.interface import implementer\n@@ -25,8 +27,11 @@\n class Collection(Item):\n     """Convenience subclass for ``Collection`` portal type\n     """\n+    security = ClassSecurityInfo()\n+\n     # BBB\n \n+    @security.protected(permissions.View)\n     def listMetaDataFields(self, exclude=True):\n         """Return a list of all metadata fields from portal_catalog.\n \n@@ -34,6 +39,7 @@ def listMetaDataFields(self, exclude=True):\n         """\n         return []\n \n+    @security.protected(permissions.View)\n     def selectedViewFields(self):\n         """Returns a list of all metadata fields from the catalog that were\n            selected.\n@@ -42,9 +48,11 @@ def selectedViewFields(self):\n             ICollection as ICollection_behavior\n         return ICollection_behavior(self).selectedViewFields()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def setQuery(self, query):\n         self.query = query\n \n+    @security.protected(permissions.View)\n     def getQuery(self):\n         """Return the query as a list of dict; note that this method\n         returns a list of CatalogContentListingObject in\n@@ -53,21 +61,26 @@ def getQuery(self):\n         return self.query\n \n     @deprecation.deprecate(\'getRawQuery() is deprecated; use getQuery().\')\n+    @security.protected(permissions.View)\n     def getRawQuery(self):\n         return self.getQuery()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def setSort_on(self, sort_on):\n         self.sort_on = sort_on\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def setSort_reversed(self, sort_reversed):\n         self.sort_reversed = sort_reversed\n \n+    @security.protected(permissions.View)\n     def queryCatalog(self, batch=True, b_start=0, b_size=30, sort_on=None):\n         from plone.app.contenttypes.behaviors.collection import \\\n             ICollection as ICollection_behavior\n         return ICollection_behavior(self).results(\n             batch, b_start, b_size, sort_on=sort_on)\n \n+    @security.protected(permissions.View)\n     def results(self, **kwargs):\n         from plone.app.contenttypes.behaviors.collection import \\\n             ICollection as ICollection_behavior\n@@ -78,6 +91,9 @@ def results(self, **kwargs):\n class Document(Item):\n     """Convenience subclass for ``Document`` portal type\n     """\n+    security = ClassSecurityInfo()\n+\n+    @security.protected(permissions.View)\n     def Format(self):\n         \'\'\' Provide a proper accessor for the format attribute\n         See https://github.com/plone/Products.CMFPlone/issues/2540\n@@ -92,7 +108,9 @@ def Format(self):\n class File(Item):\n     """Convenience subclass for ``File`` portal type\n     """\n+    security = ClassSecurityInfo()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def PUT(self, REQUEST=None, RESPONSE=None):\n         """DAV method to replace the file field with a new resource."""\n         request = REQUEST if REQUEST is not None else self.REQUEST\n@@ -114,9 +132,11 @@ def PUT(self, REQUEST=None, RESPONSE=None):\n         else:\n             return super(File, self).PUT(REQUEST=request, RESPONSE=response)\n \n+    @security.protected(permissions.View)\n     def get_size(self):\n         return getattr(self.file, \'size\', 0)\n \n+    @security.protected(permissions.View)\n     def content_type(self):\n         return getattr(self.file, \'contentType\', None)\n \n@@ -131,7 +151,9 @@ class Folder(Container):\n class Image(Item):\n     """Convenience subclass for ``Image`` portal type\n     """\n+    security = ClassSecurityInfo()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def PUT(self, REQUEST=None, RESPONSE=None):\n         """DAV method to replace image field with a new resource."""\n         request = REQUEST if REQUEST is not None else self.REQUEST\n@@ -154,9 +176,11 @@ def PUT(self, REQUEST=None, RESPONSE=None):\n         else:\n             return super(Image, self).PUT(REQUEST=request, RESPONSE=response)\n \n+    @security.protected(permissions.View)\n     def get_size(self):\n         return getattr(self.image, \'size\', 0)\n \n+    @security.protected(permissions.View)\n     def content_type(self):\n         return getattr(self.image, \'contentType\', None)\n \ndiff --git a/plone/app/contenttypes/tests/test_security.py b/plone/app/contenttypes/tests/test_security.py\nnew file mode 100644\nindex 00000000..ce3a83de\n--- /dev/null\n+++ b/plone/app/contenttypes/tests/test_security.py\n@@ -0,0 +1,258 @@\n+# -*- coding: utf-8 -*-\n+from io import BytesIO\n+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa\n+from plone.app.testing import login\n+from plone.app.testing import logout\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from plone.testing.z2 import Browser\n+\n+import base64\n+import os\n+import pkg_resources\n+import re\n+import sys\n+import transaction\n+import unittest\n+\n+\n+# List various possibly read methods.\n+# Not all classes have all of them.\n+# Some may be inherited.\n+READ_METHODS = (\n+    "content_type",\n+    "Format",\n+    "get_size",\n+    "getFoldersAndImages",\n+    "getQuery",\n+    "getRawQuery",\n+    "index_html",\n+    "listMetaDataFields",\n+    "manage_DAVget",\n+    "manage_FTPget",\n+    "queryCatalog",\n+    "results",\n+    "selectedViewFields",\n+)\n+WRITE_METHODS = ("setQuery", "setSort_on", "setSort_reversed", "PUT")\n+\n+\n+class ResponseWrapper:\n+    """Decorates a response object with additional introspective methods."""\n+\n+    _bodyre = re.compile("\\r\\n\\r\\n(.*)", re.MULTILINE | re.DOTALL)\n+\n+    def __init__(self, response, outstream, path):\n+        self._response = response\n+        self._outstream = outstream\n+        self._path = path\n+\n+    def __getattr__(self, name):\n+        return getattr(self._response, name)\n+\n+    def getOutput(self):\n+        """Returns the complete output, headers and all."""\n+        return self._outstream.getvalue()\n+\n+    def getBody(self):\n+        """Returns the page body, i.e. the output par headers."""\n+        body = self._bodyre.search(self.getOutput())\n+        if body is not None:\n+            body = body.group(1)\n+        return body\n+\n+    def getPath(self):\n+        """Returns the path used by the request."""\n+        return self._path\n+\n+    def getHeader(self, name):\n+        """Returns the value of a response header."""\n+        return self.headers.get(name.lower())\n+\n+    def getCookie(self, name):\n+        """Returns a response cookie."""\n+        return self.cookies.get(name)\n+\n+\n+class TestSecurity(unittest.TestCase):\n+    layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+        # self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+\n+    def publish(\n+        self,\n+        path,\n+        basic=None,\n+        env=None,\n+        extra=None,\n+        request_method="GET",\n+        stdin=None,\n+        handle_errors=True,\n+    ):\n+        """\n+        Mostly pulled from Testing.functional\n+        """\n+        from ZPublisher.Request import Request\n+        from ZPublisher.Response import Response\n+\n+        # Note: the next import fail in Python 3, because it needs ZServer.\n+        from ZPublisher.Publish import publish_module\n+\n+        transaction.commit()\n+\n+        if env is None:\n+            env = {}\n+\n+        env["SERVER_NAME"] = self.request["SERVER_NAME"]\n+        env["SERVER_PORT"] = self.request["SERVER_PORT"]\n+        env["REQUEST_METHOD"] = request_method\n+\n+        p = path.split("?")\n+        if len(p) == 1:\n+            env["PATH_INFO"] = p[0]\n+        elif len(p) == 2:\n+            [env["PATH_INFO"], env["QUERY_STRING"]] = p\n+        else:\n+            raise TypeError("")\n+\n+        if basic:\n+            env["HTTP_AUTHORIZATION"] = "Basic %s" % base64.encodestring(basic)\n+\n+        if stdin is None:\n+            stdin = BytesIO()\n+\n+        outstream = BytesIO()\n+        response = Response(stdout=outstream, stderr=sys.stderr)\n+        request = Request(stdin, env, response)\n+\n+        publish_module(\n+            "Zope2", debug=not handle_errors, request=request, response=response\n+        )\n+\n+        return ResponseWrapper(response, outstream, path)\n+\n+    def test_put_gives_401(self):\n+        try:\n+            # pkg_resources.get_distribution("ZServer") is not good enough,\n+            # because ZServer may be included in the Zope2 package.\n+            import ZServer  # noqa\n+        except ImportError:\n+            print("Ignoring PUT request method tests, as we miss the ZServer.")\n+            return\n+\n+        login(self.portal, TEST_USER_NAME)\n+        self.portal.invokeFactory("Collection", id="collection")\n+        self.portal.invokeFactory("Document", id="page")\n+        self.portal.invokeFactory("File", id="file")\n+        self.portal.invokeFactory("Folder", id="folder")\n+        self.portal.invokeFactory("Image", id="image")\n+        collection = self.portal.collection\n+        fi = self.portal.file\n+        folder = self.portal.folder\n+        image = self.portal.image\n+        page = self.portal.page\n+        logout()\n+\n+        # from zope.publisher.browser import TestRequest\n+\n+        # import pdb; pdb.set_trace()\n+        # request = TestRequest(request_method="PUT")\n+        # collection.REQUEST = request\n+        # x = collection()\n+\n+        path = "/" + collection.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + fi.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + folder.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + image.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + page.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+    def DISABLED_test_listDAVobjects_gives_401(self):\n+        # This actually gives 302, both with and without the patch.  It is\n+        # protected with AccessControl.Permissions.webdav_access.\n+        login(self.portal, TEST_USER_NAME)\n+        # only defined for folderish items\n+        self.portal.invokeFactory("Folder", id="folder")\n+        folder = self.portal.folder\n+        logout()\n+\n+        folder_path = "/" + folder.absolute_url(relative=True)\n+        path = folder_path + "/listDAVObjects"\n+        response = self.publish(path=path, env={}, request_method="GET")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+    def get_permission_mapping(self, klass):\n+        permissions = klass.__ac_permissions__\n+        mapping = {}\n+        for permission in permissions:\n+            # permission can have two or three items:\n+            # (\'WebDAV access\',\n+            #  (\'PROPFIND\', \'listDAVObjects\', \'manage_DAVget\'),\n+            #  (\'Manager\', \'Authenticated\'))\n+            perm, methods = list(permission)[:2]\n+            for method in methods:\n+                mapping[method] = perm\n+        return mapping\n+\n+    def _test_class_protected(self, klass):\n+        mapping = self.get_permission_mapping(klass)\n+        for method in READ_METHODS:\n+            if method in klass.__dict__.keys():\n+                self.assertEqual(\n+                    mapping.get(method),\n+                    "View",\n+                    "Method {0} missing view protection".format(method),\n+                )\n+        for method in WRITE_METHODS:\n+            if method in klass.__dict__.keys():\n+                self.assertEqual(\n+                    mapping.get(method),\n+                    "Modify portal content",\n+                    "Method {0} missing edit protection".format(method),\n+                )\n+\n+    def testCollection_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import Collection\n+        except ImportError:\n+            return\n+        self._test_class_protected(Collection)\n+\n+    def testDocument_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import Document\n+        except ImportError:\n+            return\n+        self._test_class_protected(Document)\n+\n+    def testFile_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import File\n+        except ImportError:\n+            return\n+        self._test_class_protected(File)\n+\n+    def testImage_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import Image\n+        except ImportError:\n+            return\n+        self._test_class_protected(Image)\n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2020-02-11T20:03:50+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.contenttypes/commit/ad41c45312215d72ce1a6df6447a271c0e46ff89

Merge pull request #543 from plone/maurits-plonehotfix2020-master

Integrate PloneHotFix20200121: add more permission checks. [maurits]

Files changed:
A news/3021.bugfix
A plone/app/contenttypes/tests/test_security.py
M plone/app/contenttypes/content.py

b'diff --git a/news/3021.bugfix b/news/3021.bugfix\nnew file mode 100644\nindex 00000000..d59b64e0\n--- /dev/null\n+++ b/news/3021.bugfix\n@@ -0,0 +1,3 @@\n+Integrate PloneHotFix20200121: add more permission checks.\n+See https://plone.org/security/hotfix/20200121/privilege-escalation-for-overwriting-content\n+[maurits]\ndiff --git a/plone/app/contenttypes/content.py b/plone/app/contenttypes/content.py\nindex d191da2e..d4f8537b 100644\n--- a/plone/app/contenttypes/content.py\n+++ b/plone/app/contenttypes/content.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from AccessControl.SecurityInfo import ClassSecurityInfo\n from email.feedparser import headerRE\n from plone.app.contenttypes.interfaces import ICollection\n from plone.app.contenttypes.interfaces import IDocument\n@@ -12,6 +13,7 @@\n from plone.dexterity.content import Item\n from plone.namedfile.file import NamedBlobFile\n from plone.namedfile.file import NamedBlobImage\n+from Products.CMFCore import permissions\n from Products.CMFPlone.utils import safe_text\n from zope.deprecation import deprecation\n from zope.interface import implementer\n@@ -25,8 +27,11 @@\n class Collection(Item):\n     """Convenience subclass for ``Collection`` portal type\n     """\n+    security = ClassSecurityInfo()\n+\n     # BBB\n \n+    @security.protected(permissions.View)\n     def listMetaDataFields(self, exclude=True):\n         """Return a list of all metadata fields from portal_catalog.\n \n@@ -34,6 +39,7 @@ def listMetaDataFields(self, exclude=True):\n         """\n         return []\n \n+    @security.protected(permissions.View)\n     def selectedViewFields(self):\n         """Returns a list of all metadata fields from the catalog that were\n            selected.\n@@ -42,9 +48,11 @@ def selectedViewFields(self):\n             ICollection as ICollection_behavior\n         return ICollection_behavior(self).selectedViewFields()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def setQuery(self, query):\n         self.query = query\n \n+    @security.protected(permissions.View)\n     def getQuery(self):\n         """Return the query as a list of dict; note that this method\n         returns a list of CatalogContentListingObject in\n@@ -53,21 +61,26 @@ def getQuery(self):\n         return self.query\n \n     @deprecation.deprecate(\'getRawQuery() is deprecated; use getQuery().\')\n+    @security.protected(permissions.View)\n     def getRawQuery(self):\n         return self.getQuery()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def setSort_on(self, sort_on):\n         self.sort_on = sort_on\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def setSort_reversed(self, sort_reversed):\n         self.sort_reversed = sort_reversed\n \n+    @security.protected(permissions.View)\n     def queryCatalog(self, batch=True, b_start=0, b_size=30, sort_on=None):\n         from plone.app.contenttypes.behaviors.collection import \\\n             ICollection as ICollection_behavior\n         return ICollection_behavior(self).results(\n             batch, b_start, b_size, sort_on=sort_on)\n \n+    @security.protected(permissions.View)\n     def results(self, **kwargs):\n         from plone.app.contenttypes.behaviors.collection import \\\n             ICollection as ICollection_behavior\n@@ -78,6 +91,9 @@ def results(self, **kwargs):\n class Document(Item):\n     """Convenience subclass for ``Document`` portal type\n     """\n+    security = ClassSecurityInfo()\n+\n+    @security.protected(permissions.View)\n     def Format(self):\n         \'\'\' Provide a proper accessor for the format attribute\n         See https://github.com/plone/Products.CMFPlone/issues/2540\n@@ -92,7 +108,9 @@ def Format(self):\n class File(Item):\n     """Convenience subclass for ``File`` portal type\n     """\n+    security = ClassSecurityInfo()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def PUT(self, REQUEST=None, RESPONSE=None):\n         """DAV method to replace the file field with a new resource."""\n         request = REQUEST if REQUEST is not None else self.REQUEST\n@@ -114,9 +132,11 @@ def PUT(self, REQUEST=None, RESPONSE=None):\n         else:\n             return super(File, self).PUT(REQUEST=request, RESPONSE=response)\n \n+    @security.protected(permissions.View)\n     def get_size(self):\n         return getattr(self.file, \'size\', 0)\n \n+    @security.protected(permissions.View)\n     def content_type(self):\n         return getattr(self.file, \'contentType\', None)\n \n@@ -131,7 +151,9 @@ class Folder(Container):\n class Image(Item):\n     """Convenience subclass for ``Image`` portal type\n     """\n+    security = ClassSecurityInfo()\n \n+    @security.protected(permissions.ModifyPortalContent)\n     def PUT(self, REQUEST=None, RESPONSE=None):\n         """DAV method to replace image field with a new resource."""\n         request = REQUEST if REQUEST is not None else self.REQUEST\n@@ -154,9 +176,11 @@ def PUT(self, REQUEST=None, RESPONSE=None):\n         else:\n             return super(Image, self).PUT(REQUEST=request, RESPONSE=response)\n \n+    @security.protected(permissions.View)\n     def get_size(self):\n         return getattr(self.image, \'size\', 0)\n \n+    @security.protected(permissions.View)\n     def content_type(self):\n         return getattr(self.image, \'contentType\', None)\n \ndiff --git a/plone/app/contenttypes/tests/test_security.py b/plone/app/contenttypes/tests/test_security.py\nnew file mode 100644\nindex 00000000..ce3a83de\n--- /dev/null\n+++ b/plone/app/contenttypes/tests/test_security.py\n@@ -0,0 +1,258 @@\n+# -*- coding: utf-8 -*-\n+from io import BytesIO\n+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa\n+from plone.app.testing import login\n+from plone.app.testing import logout\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from plone.testing.z2 import Browser\n+\n+import base64\n+import os\n+import pkg_resources\n+import re\n+import sys\n+import transaction\n+import unittest\n+\n+\n+# List various possibly read methods.\n+# Not all classes have all of them.\n+# Some may be inherited.\n+READ_METHODS = (\n+    "content_type",\n+    "Format",\n+    "get_size",\n+    "getFoldersAndImages",\n+    "getQuery",\n+    "getRawQuery",\n+    "index_html",\n+    "listMetaDataFields",\n+    "manage_DAVget",\n+    "manage_FTPget",\n+    "queryCatalog",\n+    "results",\n+    "selectedViewFields",\n+)\n+WRITE_METHODS = ("setQuery", "setSort_on", "setSort_reversed", "PUT")\n+\n+\n+class ResponseWrapper:\n+    """Decorates a response object with additional introspective methods."""\n+\n+    _bodyre = re.compile("\\r\\n\\r\\n(.*)", re.MULTILINE | re.DOTALL)\n+\n+    def __init__(self, response, outstream, path):\n+        self._response = response\n+        self._outstream = outstream\n+        self._path = path\n+\n+    def __getattr__(self, name):\n+        return getattr(self._response, name)\n+\n+    def getOutput(self):\n+        """Returns the complete output, headers and all."""\n+        return self._outstream.getvalue()\n+\n+    def getBody(self):\n+        """Returns the page body, i.e. the output par headers."""\n+        body = self._bodyre.search(self.getOutput())\n+        if body is not None:\n+            body = body.group(1)\n+        return body\n+\n+    def getPath(self):\n+        """Returns the path used by the request."""\n+        return self._path\n+\n+    def getHeader(self, name):\n+        """Returns the value of a response header."""\n+        return self.headers.get(name.lower())\n+\n+    def getCookie(self, name):\n+        """Returns a response cookie."""\n+        return self.cookies.get(name)\n+\n+\n+class TestSecurity(unittest.TestCase):\n+    layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+        # self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+\n+    def publish(\n+        self,\n+        path,\n+        basic=None,\n+        env=None,\n+        extra=None,\n+        request_method="GET",\n+        stdin=None,\n+        handle_errors=True,\n+    ):\n+        """\n+        Mostly pulled from Testing.functional\n+        """\n+        from ZPublisher.Request import Request\n+        from ZPublisher.Response import Response\n+\n+        # Note: the next import fail in Python 3, because it needs ZServer.\n+        from ZPublisher.Publish import publish_module\n+\n+        transaction.commit()\n+\n+        if env is None:\n+            env = {}\n+\n+        env["SERVER_NAME"] = self.request["SERVER_NAME"]\n+        env["SERVER_PORT"] = self.request["SERVER_PORT"]\n+        env["REQUEST_METHOD"] = request_method\n+\n+        p = path.split("?")\n+        if len(p) == 1:\n+            env["PATH_INFO"] = p[0]\n+        elif len(p) == 2:\n+            [env["PATH_INFO"], env["QUERY_STRING"]] = p\n+        else:\n+            raise TypeError("")\n+\n+        if basic:\n+            env["HTTP_AUTHORIZATION"] = "Basic %s" % base64.encodestring(basic)\n+\n+        if stdin is None:\n+            stdin = BytesIO()\n+\n+        outstream = BytesIO()\n+        response = Response(stdout=outstream, stderr=sys.stderr)\n+        request = Request(stdin, env, response)\n+\n+        publish_module(\n+            "Zope2", debug=not handle_errors, request=request, response=response\n+        )\n+\n+        return ResponseWrapper(response, outstream, path)\n+\n+    def test_put_gives_401(self):\n+        try:\n+            # pkg_resources.get_distribution("ZServer") is not good enough,\n+            # because ZServer may be included in the Zope2 package.\n+            import ZServer  # noqa\n+        except ImportError:\n+            print("Ignoring PUT request method tests, as we miss the ZServer.")\n+            return\n+\n+        login(self.portal, TEST_USER_NAME)\n+        self.portal.invokeFactory("Collection", id="collection")\n+        self.portal.invokeFactory("Document", id="page")\n+        self.portal.invokeFactory("File", id="file")\n+        self.portal.invokeFactory("Folder", id="folder")\n+        self.portal.invokeFactory("Image", id="image")\n+        collection = self.portal.collection\n+        fi = self.portal.file\n+        folder = self.portal.folder\n+        image = self.portal.image\n+        page = self.portal.page\n+        logout()\n+\n+        # from zope.publisher.browser import TestRequest\n+\n+        # import pdb; pdb.set_trace()\n+        # request = TestRequest(request_method="PUT")\n+        # collection.REQUEST = request\n+        # x = collection()\n+\n+        path = "/" + collection.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + fi.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + folder.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + image.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+        path = "/" + page.absolute_url(relative=True)\n+        response = self.publish(path=path, env={}, request_method="PUT")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+    def DISABLED_test_listDAVobjects_gives_401(self):\n+        # This actually gives 302, both with and without the patch.  It is\n+        # protected with AccessControl.Permissions.webdav_access.\n+        login(self.portal, TEST_USER_NAME)\n+        # only defined for folderish items\n+        self.portal.invokeFactory("Folder", id="folder")\n+        folder = self.portal.folder\n+        logout()\n+\n+        folder_path = "/" + folder.absolute_url(relative=True)\n+        path = folder_path + "/listDAVObjects"\n+        response = self.publish(path=path, env={}, request_method="GET")\n+        self.assertEqual(response.getStatus(), 401)\n+\n+    def get_permission_mapping(self, klass):\n+        permissions = klass.__ac_permissions__\n+        mapping = {}\n+        for permission in permissions:\n+            # permission can have two or three items:\n+            # (\'WebDAV access\',\n+            #  (\'PROPFIND\', \'listDAVObjects\', \'manage_DAVget\'),\n+            #  (\'Manager\', \'Authenticated\'))\n+            perm, methods = list(permission)[:2]\n+            for method in methods:\n+                mapping[method] = perm\n+        return mapping\n+\n+    def _test_class_protected(self, klass):\n+        mapping = self.get_permission_mapping(klass)\n+        for method in READ_METHODS:\n+            if method in klass.__dict__.keys():\n+                self.assertEqual(\n+                    mapping.get(method),\n+                    "View",\n+                    "Method {0} missing view protection".format(method),\n+                )\n+        for method in WRITE_METHODS:\n+            if method in klass.__dict__.keys():\n+                self.assertEqual(\n+                    mapping.get(method),\n+                    "Modify portal content",\n+                    "Method {0} missing edit protection".format(method),\n+                )\n+\n+    def testCollection_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import Collection\n+        except ImportError:\n+            return\n+        self._test_class_protected(Collection)\n+\n+    def testDocument_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import Document\n+        except ImportError:\n+            return\n+        self._test_class_protected(Document)\n+\n+    def testFile_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import File\n+        except ImportError:\n+            return\n+        self._test_class_protected(File)\n+\n+    def testImage_protected(self):\n+        try:\n+            from plone.app.contenttypes.content import Image\n+        except ImportError:\n+            return\n+        self._test_class_protected(Image)\n'

