Repository: plone.dexterity


Branch: refs/heads/master
Date: 2019-12-26T02:14:31+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.dexterity/commit/15b91978018cb1a207d3d95a678d743653c6251b

fix: reset fti cache on request

Files changed:
A news/122.bugfix
M plone/dexterity/schema.py

b'diff --git a/news/122.bugfix b/news/122.bugfix\nnew file mode 100644\nindex 0000000..3331e48\n--- /dev/null\n+++ b/news/122.bugfix\n@@ -0,0 +1 @@\n+Invalidate cached FTIs on request to allow complex/long running auto-installations. [jensens]\n\\ No newline at end of file\ndiff --git a/plone/dexterity/schema.py b/plone/dexterity/schema.py\nindex 60edfa4..9f0d83b 100644\n--- a/plone/dexterity/schema.py\n+++ b/plone/dexterity/schema.py\n@@ -48,31 +48,23 @@ def invalidate_cache(fti):\n     fti.__dict__.pop(\'_v_schema_schema_interfaces\', None)\n     fti.__dict__.pop(\'_v_schema_modified\', None)\n     fti.__dict__.pop(\'_v_schema_behavior_schema_interfaces\', None)\n+    request = getRequest()\n+    if request:\n+        setattr(request, FTI_CACHE_KEY, None)\n \n \n-def volatile(func):\n-    @functools.wraps(func)\n-    def decorator(self, portal_type):\n-        """lookup fti from portal_type and cache\n-\n-        input can be either a portal_type as string or as the utility instance.\n-        return value is always a FTI-ultiliy or None\n-        """\n-        # this function is called very often\n-\n-        # shortcut None input\n-        if portal_type is None:\n-            return func(self, None)\n-        # if its a string lookup fti\n-        if isinstance(portal_type, six.string_types):\n-            # looking up a utility is expensive, using the global request as\n-            # cache is twice as fast\n+def lookup_fti(portal_type, cache=True):\n+    # if its a string lookup fti\n+    if isinstance(portal_type, six.string_types):\n+        # looking up a utility is expensive, using the global request as\n+        # cache is twice as fast\n+        if cache:\n             request = getRequest()\n             if request:\n                 fti_cache = getattr(request, FTI_CACHE_KEY, None)\n                 if fti_cache is None:\n                     fti_cache = dict()\n-                    setattr(request, FTI_CACHE_KEY, dict())\n+                    setattr(request, FTI_CACHE_KEY, fti_cache)\n                 if portal_type in fti_cache:\n                     fti = fti_cache[portal_type]\n                 else:\n@@ -80,18 +72,33 @@ def decorator(self, portal_type):\n                         IDexterityFTI,\n                         name=portal_type\n                     )\n-            else:\n-                fti = queryUtility(IDexterityFTI, name=portal_type)\n-            if fti is None:\n-                return func(self, None)\n-        elif IDexterityFTI.providedBy(portal_type):\n-            # its already an IDexterityFTI instance\n-            fti = portal_type\n-        else:\n-            raise ValueError(\n-                \'portal_type has to either string or IDexterityFTI instance but is \'\n-                \'{0!r}\'.format(portal_type)\n-            )\n+                return fti\n+        return queryUtility(IDexterityFTI, name=portal_type)\n+    if IDexterityFTI.providedBy(portal_type):\n+        # its already an IDexterityFTI instance\n+        return portal_type\n+    raise ValueError(\n+        \'portal_type has to either string or IDexterityFTI instance but is \'\n+        \'{0!r}\'.format(portal_type)\n+    )\n+\n+\n+\n+def volatile(func):\n+    @functools.wraps(func)\n+    def decorator(self, portal_type):\n+        """lookup fti from portal_type and cache\n+\n+        input can be either a portal_type as string or as the utility instance.\n+        return value is always a FTI-ultiliy or None\n+        """\n+        # this function is called very often!\n+        # shortcut None input\n+        if portal_type is None:\n+            return func(self, None)\n+        fti = lookup_fti(portal_type, cache=self.cache_enabled)\n+        if fti is None:\n+            return func(self, None)\n         if self.cache_enabled:\n             key = \'_v_schema_%s\' % func.__name__\n             cache = getattr(fti, key, _MARKER)\n'

Repository: plone.dexterity


Branch: refs/heads/master
Date: 2019-12-26T10:43:52+01:00
Author: Timo Stollenwerk (tisto) <tisto@users.noreply.github.com>
Commit: https://github.com/plone/plone.dexterity/commit/237de0b988a6f0ab27cb7dee7703b0f5cf402f28

Merge pull request #122 from plone/jensens-fix-fti-not-updated

fix: reset fti cache on request

Files changed:
A news/122.bugfix
M plone/dexterity/schema.py

b'diff --git a/news/122.bugfix b/news/122.bugfix\nnew file mode 100644\nindex 0000000..3331e48\n--- /dev/null\n+++ b/news/122.bugfix\n@@ -0,0 +1 @@\n+Invalidate cached FTIs on request to allow complex/long running auto-installations. [jensens]\n\\ No newline at end of file\ndiff --git a/plone/dexterity/schema.py b/plone/dexterity/schema.py\nindex 60edfa4..9f0d83b 100644\n--- a/plone/dexterity/schema.py\n+++ b/plone/dexterity/schema.py\n@@ -48,31 +48,23 @@ def invalidate_cache(fti):\n     fti.__dict__.pop(\'_v_schema_schema_interfaces\', None)\n     fti.__dict__.pop(\'_v_schema_modified\', None)\n     fti.__dict__.pop(\'_v_schema_behavior_schema_interfaces\', None)\n+    request = getRequest()\n+    if request:\n+        setattr(request, FTI_CACHE_KEY, None)\n \n \n-def volatile(func):\n-    @functools.wraps(func)\n-    def decorator(self, portal_type):\n-        """lookup fti from portal_type and cache\n-\n-        input can be either a portal_type as string or as the utility instance.\n-        return value is always a FTI-ultiliy or None\n-        """\n-        # this function is called very often\n-\n-        # shortcut None input\n-        if portal_type is None:\n-            return func(self, None)\n-        # if its a string lookup fti\n-        if isinstance(portal_type, six.string_types):\n-            # looking up a utility is expensive, using the global request as\n-            # cache is twice as fast\n+def lookup_fti(portal_type, cache=True):\n+    # if its a string lookup fti\n+    if isinstance(portal_type, six.string_types):\n+        # looking up a utility is expensive, using the global request as\n+        # cache is twice as fast\n+        if cache:\n             request = getRequest()\n             if request:\n                 fti_cache = getattr(request, FTI_CACHE_KEY, None)\n                 if fti_cache is None:\n                     fti_cache = dict()\n-                    setattr(request, FTI_CACHE_KEY, dict())\n+                    setattr(request, FTI_CACHE_KEY, fti_cache)\n                 if portal_type in fti_cache:\n                     fti = fti_cache[portal_type]\n                 else:\n@@ -80,18 +72,33 @@ def decorator(self, portal_type):\n                         IDexterityFTI,\n                         name=portal_type\n                     )\n-            else:\n-                fti = queryUtility(IDexterityFTI, name=portal_type)\n-            if fti is None:\n-                return func(self, None)\n-        elif IDexterityFTI.providedBy(portal_type):\n-            # its already an IDexterityFTI instance\n-            fti = portal_type\n-        else:\n-            raise ValueError(\n-                \'portal_type has to either string or IDexterityFTI instance but is \'\n-                \'{0!r}\'.format(portal_type)\n-            )\n+                return fti\n+        return queryUtility(IDexterityFTI, name=portal_type)\n+    if IDexterityFTI.providedBy(portal_type):\n+        # its already an IDexterityFTI instance\n+        return portal_type\n+    raise ValueError(\n+        \'portal_type has to either string or IDexterityFTI instance but is \'\n+        \'{0!r}\'.format(portal_type)\n+    )\n+\n+\n+\n+def volatile(func):\n+    @functools.wraps(func)\n+    def decorator(self, portal_type):\n+        """lookup fti from portal_type and cache\n+\n+        input can be either a portal_type as string or as the utility instance.\n+        return value is always a FTI-ultiliy or None\n+        """\n+        # this function is called very often!\n+        # shortcut None input\n+        if portal_type is None:\n+            return func(self, None)\n+        fti = lookup_fti(portal_type, cache=self.cache_enabled)\n+        if fti is None:\n+            return func(self, None)\n         if self.cache_enabled:\n             key = \'_v_schema_%s\' % func.__name__\n             cache = getattr(fti, key, _MARKER)\n'

