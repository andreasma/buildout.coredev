Repository: collective.monkeypatcher


Branch: refs/heads/master
Date: 2018-10-23T12:57:05+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/collective.monkeypatcher/commit/06db22662449f33428517ab9f1a7e2e54081886b

fix deprecation message and some pep8

Files changed:
M CHANGES.rst
M collective/__init__.py
M collective/monkeypatcher/interfaces.py
M collective/monkeypatcher/meta.py
M collective/monkeypatcher/tests/dummypatch.py
M collective/monkeypatcher/tests/test_monkeypatcher.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex a3dbc33..d692263 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -17,6 +17,9 @@ Bug fixes:\n - Prepare for Python 2 / 3 compatibility\n   [frapell]\n \n+- pep8, fix deprecation messages.\n+  [jensens]\n+\n \n 1.1.5 (2018-06-18)\n ------------------\ndiff --git a/collective/__init__.py b/collective/__init__.py\nindex f48ad10..d8f9659 100644\n--- a/collective/__init__.py\n+++ b/collective/__init__.py\n@@ -1,6 +1,2 @@\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-    __path__ = extend_path(__path__, __name__)\n+# -*- coding: utf-8 -*-\n+__path__ = __import__(\'pkgutil\').extend_path(__path__, __name__)\ndiff --git a/collective/monkeypatcher/interfaces.py b/collective/monkeypatcher/interfaces.py\nindex 0e17c97..30faa9a 100644\n--- a/collective/monkeypatcher/interfaces.py\n+++ b/collective/monkeypatcher/interfaces.py\n@@ -15,4 +15,5 @@ class IMonkeyPatchEvent(Interface):\n         * \'zcml_info\': A text about the ZCML portion that made the patch\n         * \'original\': Dotted name of the original method/function.\n         * \'replacement\': Dotted name of the new function\n-        """)\n+        """,\n+    )\ndiff --git a/collective/monkeypatcher/meta.py b/collective/monkeypatcher/meta.py\nindex e270fee..17a8e33 100644\n--- a/collective/monkeypatcher/meta.py\n+++ b/collective/monkeypatcher/meta.py\n@@ -24,39 +24,87 @@ class IMonkeyPatchDirective(Interface):\n \n     class_ = GlobalObject(title=u"The class being patched", required=False)\n     module = GlobalObject(title=u"The module being patched", required=False)\n-    handler = GlobalObject(title=u"A function to perform the patching.",\n-                           description=u"Must take three parameters: class/module, original (string), and replacement",\n-                           required=False)\n+    handler = GlobalObject(\n+        title=u"A function to perform the patching.",\n+        description=(\n+            u"Must take three parameters: class/module, original "\n+            u"(string), and replacement"\n+        ),\n+        required=False,\n+    )\n     original = PythonIdentifier(title=u"Method or function to replace")\n     replacement = GlobalObject(title=u"Method to function to replace with")\n-    preservedoc = Bool(title=u"Preserve docstrings?", required=False, default=True)\n-    preserveOriginal = Bool(title=u\'Preserve the original function so that it is reachable view prefix _old_. Only works for def handler.\',\n-                            default=False, required=False)\n-    preconditions = Text(title=u\'Preconditions (multiple, separated by space) to be satisified before applying this patch. Example: Products.LinguaPlone<=1.4.3\',\n-                         required=False, default=u\'\')\n-    ignoreOriginal = Bool(title=u"Ignore if the orginal function isn\'t present on the class/module being patched",\n-                          default=False)\n-    docstringWarning = Bool(title=u"Add monkey patch warning in docstring", required=False, default=True)\n-    description = Text(title=u\'Some comments about your monkey patch\', required=False, default=u"(No comment)")\n+    preservedoc = Bool(\n+        title=u"Preserve docstrings?", required=False, default=True\n+    )\n+    preserveOriginal = Bool(\n+        title=(\n+            u\'Preserve the original function so that it is \'\n+            u\'reachable view prefix _old_. Only works for def handler.\'\n+        ),\n+        default=False,\n+        required=False,\n+    )\n+    preconditions = Text(\n+        title=(\n+            u\'Preconditions (multiple, separated by space) to be satisified \'\n+            u\'before applying this patch. Example: Products.LinguaPlone<=1.4.3\'\n+        ),\n+        required=False,\n+        default=u\'\',\n+    )\n+    ignoreOriginal = Bool(\n+        title=(\n+            u"Ignore if the orginal function isn\'t present on the "\n+            u"class/module being patched"\n+        ),\n+        default=False,\n+    )\n+    docstringWarning = Bool(\n+        title=u"Add monkey patch warning in docstring",\n+        required=False,\n+        default=True,\n+    )\n+    description = Text(\n+        title=u\'Some comments about your monkey patch\',\n+        required=False,\n+        default=u"(No comment)",\n+    )\n     order = Int(title=u"Execution order", required=False, default=1000)\n \n \n-def replace(_context, original, replacement, class_=None, module=None, handler=None, preservedoc=True,\n-            docstringWarning=True, description=u"(No comment)", order=1000, ignoreOriginal=False,\n-            preserveOriginal=False, preconditions=u\'\'):\n+def replace(\n+    _context,\n+    original,\n+    replacement,\n+    class_=None,\n+    module=None,\n+    handler=None,\n+    preservedoc=True,\n+    docstringWarning=True,\n+    description=u"(No comment)",\n+    order=1000,\n+    ignoreOriginal=False,\n+    preserveOriginal=False,\n+    preconditions=u\'\',\n+):\n     """ZCML directive handler"""\n \n     if class_ is None and module is None:\n         raise ConfigurationError(u"You must specify \'class\' or \'module\'")\n     if class_ is not None and module is not None:\n-        raise ConfigurationError(u"You must specify one of \'class\' or \'module\', but not both.")\n+        raise ConfigurationError(\n+            u"You must specify one of \'class\' or \'module\', but not both."\n+        )\n \n     scope = class_ or module\n \n     to_be_replaced = getattr(scope, original, None)\n \n     if to_be_replaced is None and not ignoreOriginal:\n-        raise ConfigurationError("Original %s in %s not found" % (original, str(scope)))\n+        raise ConfigurationError(\n+            "Original %s in %s not found" % (original, str(scope))\n+        )\n \n     if preservedoc:\n         try:\n@@ -66,7 +114,10 @@ def replace(_context, original, replacement, class_=None, module=None, handler=N\n \n     if docstringWarning:\n         try:\n-            patch_warning = "\\n**Monkey patched by** \'%s.%s\'" % (getattr(replacement, \'__module__\', \'\'), replacement.__name__)\n+            patch_warning = "\\n**Monkey patched by** \'%s.%s\'" % (\n+                getattr(replacement, \'__module__\', \'\'),\n+                replacement.__name__,\n+            )\n             if replacement.__doc__ is None:\n                 replacement.__doc__ = \'\'\n             replacement.__doc__ += patch_warning\n@@ -76,7 +127,10 @@ def replace(_context, original, replacement, class_=None, module=None, handler=N\n     # check version\n     if preconditions != u\'\':\n         if not _preconditions_matching(preconditions):\n-            log.info(\'Preconditions for patching scope %s not met (%s)!\' % (scope, preconditions))\n+            log.info(\n+                \'Preconditions for patching scope %s not met (%s)!\'\n+                % (scope, preconditions)\n+            )\n             return  # fail silently\n \n     if handler is None:\n@@ -89,15 +143,27 @@ def replace(_context, original, replacement, class_=None, module=None, handler=N\n         discriminator=None,\n         callable=_do_patch,\n         order=order,\n-        args=(handler, scope, original, replacement, repr(_context.info), description))\n+        args=(\n+            handler,\n+            scope,\n+            original,\n+            replacement,\n+            repr(_context.info),\n+            description,\n+        ),\n+    )\n     return\n \n \n def _preconditions_matching(preconditions):\n     """ Returns True if preconditions matching """\n \n-    matcher_r = re.compile(r\'^(.*?)([-+!=]+)(.*)$\', re.DOTALL | re.IGNORECASE | re.MULTILINE)\n-    version_r = re.compile(r\'^([0-9]+)\\.([0-9]+)\\.?([0-9]?).*$\', re.IGNORECASE | re.MULTILINE)\n+    matcher_r = re.compile(\n+        r\'^(.*?)([-+!=]+)(.*)$\', re.DOTALL | re.IGNORECASE | re.MULTILINE\n+    )\n+    version_r = re.compile(\n+        r\'^([0-9]+)\\.([0-9]+)\\.?([0-9]?).*$\', re.IGNORECASE | re.MULTILINE\n+    )\n     ev = pkg_resources.Environment()\n \n     # split all preconds\n@@ -112,11 +178,32 @@ def _preconditions_matching(preconditions):\n \n         # fill versions - we assume having s/th like\n         # 1.2.3a2 or 1.2a1 or 1.2.0 - look at regexp\n-        p_v = list(map(int, [x for x in version_r.search(version).groups() if x and int(x) or 0]))\n-        p_i = list(map(int, [y for y in version_r.search(dp[0].version).groups() if y and int(y) or 0]))\n+        p_v = list(\n+            map(\n+                int,\n+                [\n+                    x\n+                    for x in version_r.search(version).groups()\n+                    if x and int(x) or 0\n+                ],\n+            )\n+        )\n+        p_i = list(\n+            map(\n+                int,\n+                [\n+                    y\n+                    for y in version_r.search(dp[0].version).groups()\n+                    if y and int(y) or 0\n+                ],\n+            )\n+        )\n \n         if not p_v or not p_i:\n-            log.error(\'Could not patch because version not recognized. Wanted: %s, Installed: %s\' % (p_v, p_i))\n+            log.error(\n+                \'Could not patch because version not recognized. Wanted: %s, Installed: %s\'\n+                % (p_v, p_i)\n+            )\n             return False\n \n         # compare operators - dumb if check - could be better\n@@ -147,12 +234,19 @@ def _do_patch(handler, scope, original, replacement, zcml_info, description):\n     """Apply the monkey patch through preferred method"""\n \n     try:\n-        org_dotted_name = \'%s.%s.%s\' % (scope.__module__, scope.__name__, original)\n+        org_dotted_name = \'%s.%s.%s\' % (\n+            scope.__module__,\n+            scope.__name__,\n+            original,\n+        )\n     except AttributeError:\n         org_dotted_name = \'%s.%s\' % (scope.__name__, original)\n \n     try:\n-        new_dotted_name = "%s.%s" % (getattr(replacement, \'__module__\', \'\'), replacement.__name__)\n+        new_dotted_name = "%s.%s" % (\n+            getattr(replacement, \'__module__\', \'\'),\n+            replacement.__name__,\n+        )\n     except AttributeError:\n         # builtins don\'t have __module__ and __name__\n         new_dotted_name = str(replacement)\n@@ -161,13 +255,17 @@ def _do_patch(handler, scope, original, replacement, zcml_info, description):\n     if handler != _default_patch:\n         handler_info = " using custom handler %s" % handler\n \n-    log.debug("Monkey patching %s with %s" % (org_dotted_name, new_dotted_name,) + handler_info)\n+    log.debug(\n+        "Monkey patching %s with %s" % (org_dotted_name, new_dotted_name)\n+        + handler_info\n+    )\n \n     info = {\n         \'description\': description,\n         \'zcml_info\': zcml_info,\n         \'original\': org_dotted_name,\n-        \'replacement\': new_dotted_name}\n+        \'replacement\': new_dotted_name,\n+    }\n \n     notify(MonkeyPatchEvent(info))\n     handler(scope, original, replacement)\n@@ -190,4 +288,3 @@ def _default_preserve_handler(scope, original, replacement):\n         setattr(scope, OLD_NAME, getattr(scope, original))\n \n     setattr(scope, original, replacement)\n-    return\ndiff --git a/collective/monkeypatcher/tests/dummypatch.py b/collective/monkeypatcher/tests/dummypatch.py\nindex e7a0e51..dd75850 100644\n--- a/collective/monkeypatcher/tests/dummypatch.py\n+++ b/collective/monkeypatcher/tests/dummypatch.py\n@@ -7,7 +7,7 @@ class Dummy(object):\n \n     def someMethod(self):\n         """someMethod docstring"""\n-        return"original"\n+        return "original"\n \n \n def patchedMethod(self):\ndiff --git a/collective/monkeypatcher/tests/test_monkeypatcher.py b/collective/monkeypatcher/tests/test_monkeypatcher.py\nindex 761dbc4..4f1d48d 100644\n--- a/collective/monkeypatcher/tests/test_monkeypatcher.py\n+++ b/collective/monkeypatcher/tests/test_monkeypatcher.py\n@@ -14,38 +14,41 @@ def test_patchedClass(self):\n \n         # Testing applyed patch\n         ob = dummypatch.Dummy()\n-        self.failUnlessEqual(ob.someMethod(), "patched")\n+        self.assertEqual(ob.someMethod(), "patched")\n \n         # Testing docstring preservation\n         docstring = dummypatch.Dummy.someMethod.__doc__\n-        self.failUnlessEqual(docstring, "someMethod docstring")\n+        self.assertEqual(docstring, "someMethod docstring")\n         return\n \n     def test_patchedFunction(self):\n         """We have our someFunction patched"""\n \n         # Testing applyed patch\n-        self.failUnlessEqual(dummypatch.someFunction(1), 2)\n+        self.assertEqual(dummypatch.someFunction(1), 2)\n \n         # Testing docstring monkeypatch note\n         docstring = dummypatch.someFunction.__doc__\n         self.failUnless(docstring.startswith("someFunction docstring"))\n-        self.failUnless(docstring.endswith(\n-            "\'collective.monkeypatcher.tests.dummypatch.patchedFunction\'"))\n+        self.failUnless(\n+            docstring.endswith(\n+                "\'collective.monkeypatcher.tests.dummypatch.patchedFunction\'"\n+            )\n+        )\n         return\n \n     def test_patchWithHandler(self):\n         """Patch applied with personal handler"""\n \n         ob = dummypatch.Foo()\n-        self.failUnlessEqual(ob.someFooMethod(), "patchedFooMethod result")\n+        self.assertEqual(ob.someFooMethod(), "patchedFooMethod result")\n         return\n \n     def test_patchWithBuiltin(self):\n         """see https://github.com/plone/collective.monkeypatcher/pull/2\n         """\n         ob = dummypatch.Foo()\n-        self.failUnlessEqual(ob.config, (1, 2))\n+        self.assertEqual(ob.config, (1, 2))\n         return\n \n     def test_monkeyPatchEvent(self):\n@@ -53,8 +56,9 @@ def test_monkeyPatchEvent(self):\n \n         events = dummypatch.all_patches\n         expected_keys = set(\n-            (\'description\', \'original\', \'replacement\', \'zcml_info\'))\n-        self.failUnlessEqual(len(events), 4)\n+            (\'description\', \'original\', \'replacement\', \'zcml_info\')\n+        )\n+        self.assertEqual(len(events), 4)\n         for event in events:\n \n             # Interface conformance\n@@ -62,12 +66,13 @@ def test_monkeyPatchEvent(self):\n \n             # Checking available infos\n             info_keys = set(event.patch_info.keys())\n-            self.failUnlessEqual(info_keys, expected_keys)\n+            self.assertEqual(info_keys, expected_keys)\n         return\n \n \n def test_suite():\n     from unittest import TestSuite, makeSuite\n+\n     suite = TestSuite()\n     suite.addTest(makeSuite(TestMonkeyPatcher))\n     return suite\ndiff --git a/setup.py b/setup.py\nindex 040efd1..3a263fb 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,24 +3,25 @@\n from setuptools import setup\n \n \n-version = \'1.1.6.dev0\'\n+version = \'1.2.6.dev0\'\n \n setup(\n     name=\'collective.monkeypatcher\',\n     version=version,\n-    description=("Support for applying monkey patches late in the startup "\n-                 "cycle by using ZCML configuration actions"),\n-    long_description=\'\\n\'.join([\n-        open("README.rst").read(),\n-        open("CHANGES.rst").read()]),\n+    description=(\n+        "Support for applying monkey patches late in the startup "\n+        "cycle by using ZCML configuration actions"\n+    ),\n+    long_description=\'\\n\'.join(\n+        [open("README.rst").read(), open("CHANGES.rst").read()]\n+    ),\n     classifiers=[\n         "License :: OSI Approved :: BSD License",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.6",\n         "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3.6",\n         "Programming Language :: Python :: 3.7",\n-        ],\n+    ],\n     keywords=\'zope monkey patch\',\n     author=\'Martin Aspeli\',\n     author_email=\'optilude@gmail.com\',\n@@ -30,8 +31,5 @@\n     namespace_packages=[\'collective\'],\n     include_package_data=True,\n     zip_safe=False,\n-    install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-    ],\n-    )\n+    install_requires=[\'setuptools\', \'six\'],\n+)\n'

