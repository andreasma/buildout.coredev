Repository: Products.CMFPlone


Branch: refs/heads/4.3.x
Date: 2020-01-22T21:55:54+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/5989716e7523dba603f8d0b055b7900dc254db0d

Merge Hotfix20200121 with tests

The isURLInPortal check that is done to avoid linking to an external
site could be tricked into accepting malicious links.

Files changed:
A news/3021.bugfix.2
M Products/CMFPlone/URLTool.py
M Products/CMFPlone/tests/testURLTool.py

b'diff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py\nindex dabdf23221..bb98640b32 100644\n--- a/Products/CMFPlone/URLTool.py\n+++ b/Products/CMFPlone/URLTool.py\n@@ -8,6 +8,8 @@\n from posixpath import normpath\n from urlparse import urlparse, urljoin\n import re\n+import string\n+import unicodedata\n \n \n hp = HTMLParser()\n@@ -28,6 +30,62 @@\n     \'javascript%3a\',\n ]\n \n+# Determine allowed ascii characters.\n+# We want to allow most printable characters,\n+# but no whitespace, and no punctuation, except for a few exceptions.\n+# This boils down to ascii letters plus digits plus exceptions.\n+# Exceptions:\n+# - dot and slash for relative or absolute paths.\n+# - @ because we have views starting with @@\n+# - + because we have ++resource++ urls\n+allowed_ascii = string.ascii_letters + string.digits + "./@+"\n+\n+def safe_url_first_char(url):\n+    # For character code points higher than 127, the bytes representation of a character\n+    # is longer than the unicode representation, so url[0] may give different results\n+    # for bytes and unicode.  On Python 2:\n+    # >>> unichr(128)\n+    # u\'\\x80\'\n+    # >>> len(unichr(128))\n+    # 1\n+    # >>> unichr(128).encode("latin-1")\n+    # \'\\x80\'\n+    # >>> len(unichr(128).encode("latin-1"))\n+    # 1\n+    # >>> unichr(128).encode("utf-8")\n+    # \'\\xc2\\x80\'\n+    # >>> len(unichr(128).encode("utf-8"))\n+    # 2\n+    # >>> unichr(128).encode("utf-8")[0]\n+    # \'\\xc2\'\n+    # So make sure we have unicode here for comparing the first character.\n+    if isinstance(url, bytes):\n+        # Remember, on Python 2, bytes == str.\n+        try:\n+            first = url.decode("utf-8")[0]\n+        except UnicodeDecodeError:\n+            # We don\'t trust this\n+            return False\n+    else:\n+        first = url[0]\n+    if ord(first) < 128:\n+        if first not in allowed_ascii:\n+            # The first character of the url is ascii but not in the allowed range.\n+            return False\n+    else:\n+        # This is non-ascii, which has lots of control characters, which may be dangerous.\n+        # Check taken from django.utils.http._is_safe_url.  See\n+        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n+        # Forbid URLs that start with control characters. Some browsers (like\n+        # Chrome) ignore quite a few control characters at the start of a\n+        # URL and might consider the URL as scheme relative.\n+        # For categories, see 5.7.1 General Category Values here:\n+        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n+        # We look for Control categories here.\n+        if unicodedata.category(first)[0] == "C":\n+            return False\n+    return True\n+\n \n class URLTool(PloneBaseTool, BaseTool):\n \n@@ -48,6 +106,9 @@ def isURLInPortal(self, url, context=None):\n         # site_properties are also considered within the portal to allow for\n         # single sign on.\n \n+        if url and not safe_url_first_char(url):\n+            return False\n+\n         # sanitize url\n         url = re.sub(\'^[\\x00-\\x20]+\', \'\', url).strip()\n         cmp_url = url.lower()\ndiff --git a/Products/CMFPlone/tests/testURLTool.py b/Products/CMFPlone/tests/testURLTool.py\nindex a132636343..d65286eb87 100644\n--- a/Products/CMFPlone/tests/testURLTool.py\n+++ b/Products/CMFPlone/tests/testURLTool.py\n@@ -56,6 +56,7 @@ def test_isURLInPortal(self):\n         self.assertTrue(iURLiP(\'https://www.foobar.com/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com:8080/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com/bar\'))\n+        self.assertTrue(iURLiP(\'//www.foobar.com/bar/foo\'))\n         self.assertFalse(iURLiP(\'/images\'))\n         self.assertTrue(iURLiP(\'/bar/foo/foo\'))\n \n@@ -125,6 +126,15 @@ def test_double_back_slash(self):\n         iURLiP = url_tool.isURLInPortal\n         self.assertFalse(iURLiP(\'\\\\\\\\www.example.com\'))\n \n+    def test_escape(self):\n+        url_tool = self._makeOne()\n+        iURLiP = url_tool.isURLInPortal\n+        self.assertFalse(iURLiP(\'\\/\\/www.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2F\\%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2f\\%2fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2F%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2f%2fwww.example.com\'))\n+\n     def test_regression_absolute_url_in_portal(self):\n         url_tool = self._makeOne()\n         iURLiP = url_tool.isURLInPortal\ndiff --git a/news/3021.bugfix.2 b/news/3021.bugfix.2\nnew file mode 100644\nindex 0000000000..b48698a2db\n--- /dev/null\n+++ b/news/3021.bugfix.2\n@@ -0,0 +1 @@\n+Merge Hotfix20200121: isURLInPortal could be tricked into accepting malicious links.\n'

Repository: Products.CMFPlone


Branch: refs/heads/4.3.x
Date: 2020-02-11T12:47:11+01:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/Products.CMFPlone/commit/49277de01f41f120a3bd6a28fd3bbac585780e40

Merge pull request #3024 from plone/merge-hotfix-20200121-4.3.x-in-portal

4.3.x Hotfix20200121 isURLInPortal

Files changed:
A news/3021.bugfix.2
M Products/CMFPlone/URLTool.py
M Products/CMFPlone/tests/testURLTool.py

b'diff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py\nindex dabdf23221..bb98640b32 100644\n--- a/Products/CMFPlone/URLTool.py\n+++ b/Products/CMFPlone/URLTool.py\n@@ -8,6 +8,8 @@\n from posixpath import normpath\n from urlparse import urlparse, urljoin\n import re\n+import string\n+import unicodedata\n \n \n hp = HTMLParser()\n@@ -28,6 +30,62 @@\n     \'javascript%3a\',\n ]\n \n+# Determine allowed ascii characters.\n+# We want to allow most printable characters,\n+# but no whitespace, and no punctuation, except for a few exceptions.\n+# This boils down to ascii letters plus digits plus exceptions.\n+# Exceptions:\n+# - dot and slash for relative or absolute paths.\n+# - @ because we have views starting with @@\n+# - + because we have ++resource++ urls\n+allowed_ascii = string.ascii_letters + string.digits + "./@+"\n+\n+def safe_url_first_char(url):\n+    # For character code points higher than 127, the bytes representation of a character\n+    # is longer than the unicode representation, so url[0] may give different results\n+    # for bytes and unicode.  On Python 2:\n+    # >>> unichr(128)\n+    # u\'\\x80\'\n+    # >>> len(unichr(128))\n+    # 1\n+    # >>> unichr(128).encode("latin-1")\n+    # \'\\x80\'\n+    # >>> len(unichr(128).encode("latin-1"))\n+    # 1\n+    # >>> unichr(128).encode("utf-8")\n+    # \'\\xc2\\x80\'\n+    # >>> len(unichr(128).encode("utf-8"))\n+    # 2\n+    # >>> unichr(128).encode("utf-8")[0]\n+    # \'\\xc2\'\n+    # So make sure we have unicode here for comparing the first character.\n+    if isinstance(url, bytes):\n+        # Remember, on Python 2, bytes == str.\n+        try:\n+            first = url.decode("utf-8")[0]\n+        except UnicodeDecodeError:\n+            # We don\'t trust this\n+            return False\n+    else:\n+        first = url[0]\n+    if ord(first) < 128:\n+        if first not in allowed_ascii:\n+            # The first character of the url is ascii but not in the allowed range.\n+            return False\n+    else:\n+        # This is non-ascii, which has lots of control characters, which may be dangerous.\n+        # Check taken from django.utils.http._is_safe_url.  See\n+        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n+        # Forbid URLs that start with control characters. Some browsers (like\n+        # Chrome) ignore quite a few control characters at the start of a\n+        # URL and might consider the URL as scheme relative.\n+        # For categories, see 5.7.1 General Category Values here:\n+        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n+        # We look for Control categories here.\n+        if unicodedata.category(first)[0] == "C":\n+            return False\n+    return True\n+\n \n class URLTool(PloneBaseTool, BaseTool):\n \n@@ -48,6 +106,9 @@ def isURLInPortal(self, url, context=None):\n         # site_properties are also considered within the portal to allow for\n         # single sign on.\n \n+        if url and not safe_url_first_char(url):\n+            return False\n+\n         # sanitize url\n         url = re.sub(\'^[\\x00-\\x20]+\', \'\', url).strip()\n         cmp_url = url.lower()\ndiff --git a/Products/CMFPlone/tests/testURLTool.py b/Products/CMFPlone/tests/testURLTool.py\nindex a132636343..d65286eb87 100644\n--- a/Products/CMFPlone/tests/testURLTool.py\n+++ b/Products/CMFPlone/tests/testURLTool.py\n@@ -56,6 +56,7 @@ def test_isURLInPortal(self):\n         self.assertTrue(iURLiP(\'https://www.foobar.com/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com:8080/bar/foo/folder\'))\n         self.assertFalse(iURLiP(\'http://www.foobar.com/bar\'))\n+        self.assertTrue(iURLiP(\'//www.foobar.com/bar/foo\'))\n         self.assertFalse(iURLiP(\'/images\'))\n         self.assertTrue(iURLiP(\'/bar/foo/foo\'))\n \n@@ -125,6 +126,15 @@ def test_double_back_slash(self):\n         iURLiP = url_tool.isURLInPortal\n         self.assertFalse(iURLiP(\'\\\\\\\\www.example.com\'))\n \n+    def test_escape(self):\n+        url_tool = self._makeOne()\n+        iURLiP = url_tool.isURLInPortal\n+        self.assertFalse(iURLiP(\'\\/\\/www.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2F\\%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'\\%2f\\%2fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2F%2Fwww.example.com\'))\n+        self.assertFalse(iURLiP(\'%2f%2fwww.example.com\'))\n+\n     def test_regression_absolute_url_in_portal(self):\n         url_tool = self._makeOne()\n         iURLiP = url_tool.isURLInPortal\ndiff --git a/news/3021.bugfix.2 b/news/3021.bugfix.2\nnew file mode 100644\nindex 0000000000..b48698a2db\n--- /dev/null\n+++ b/news/3021.bugfix.2\n@@ -0,0 +1 @@\n+Merge Hotfix20200121: isURLInPortal could be tricked into accepting malicious links.\n'

