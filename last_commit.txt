Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-12-22T07:46:47+01:00
Author: David Erni (deiferni) <david.erni@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/257234cfafcba996cfcefba10660c7350cc428d0

Prevent converting bytestring ids to unicode ids when reordering on python2. (#828)

* Failing test reorder unicode conversion on PY2.

Document that reordering content on python 2 converts ids returned
by `contentIds` to unicode.

* Prevent changing id to unicode by ordering in PY2.

Prevent that ordering ids are converted to unicode on PY2 when
reordering via the api. The ordering is stored separately in object
annotations but returned by the `objectIds` or `keys` methods.

* Add helper to fix incorrect ordering ids for PY2.

* Add changelog.

* Add view to fix ordering ids for all content.

By default will fix ordering object ids for every object that considers
itself folderish.

* Add upgrade-guide to fix ordering type conversion.

Files changed:
A news/827.bugfix
A src/plone/restapi/tests/test_upgrade_ordering.py
A src/plone/restapi/upgrades/ordering.py
M docs/source/upgrade-guide.rst
M src/plone/restapi/deserializer/mixins.py
M src/plone/restapi/tests/mixin_ordering.py
M src/plone/restapi/upgrades/configure.zcml

b'diff --git a/docs/source/upgrade-guide.rst b/docs/source/upgrade-guide.rst\nindex b90018a1..056f3381 100644\n--- a/docs/source/upgrade-guide.rst\n+++ b/docs/source/upgrade-guide.rst\n@@ -3,6 +3,33 @@ Upgrade Guide\n \n This upgrade guide lists all breaking changes in plone.restapi and explains the necessary steps that are needed to upgrade to the lastest version.\n \n+\n+Upgrading to plone.restapi X.y\n+------------------------------\n+\n+All versions before plone.restapi x.y.z are potentially affected by an issue\n+that converts ids of reordered content to unicode from a bytestring when\n+running on python2.\n+\n+You may be affected by this issue and should run the fix if:\n+\n+- You used the PATCH "ordering" functionality of plone.restapi\n+- Were using Python 2 at that point\n+- Are seeing issues with objectIds() returning mixed string types\n+\n+If you need to fix object ids you can do one of the following:\n+\n+- Use the browser-view ``@@plone-restapi-upgrade-fix-ordering`` as a "Manager"\n+  to fix all folderish content types in your Plone site.\n+- Run the helper function\n+  ``ensure_child_ordering_object_ids_are_native_strings``\n+  from ``plone.restapi.upgrades.ordering`` for all affected objects. You could\n+  do this in a custom upgrade-step implemented in your policy.\n+\n+We expect that most content won\'t actually be affected. See\n+https://github.com/plone/plone.restapi/issues/827 for more details.\n+\n+\n Upgrading to plone.restapi 5.x\n ------------------------------\n \ndiff --git a/news/827.bugfix b/news/827.bugfix\nnew file mode 100644\nindex 00000000..0ace470b\n--- /dev/null\n+++ b/news/827.bugfix\n@@ -0,0 +1,2 @@\n+Prevent converting bytestring ids to unicode ids when reordering (see upgrade guide for potential migration).\n+[deiferni]\ndiff --git a/src/plone/restapi/deserializer/mixins.py b/src/plone/restapi/deserializer/mixins.py\nindex 45ae1f2c..39e34c8b 100644\n--- a/src/plone/restapi/deserializer/mixins.py\n+++ b/src/plone/restapi/deserializer/mixins.py\n@@ -3,6 +3,8 @@\n from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot\n from zExceptions import BadRequest\n \n+import six\n+\n \n class OrderingMixin(object):\n     def handle_ordering(self, data):\n@@ -33,6 +35,16 @@ def reorderItems(self, obj_id, delta, subset_ids):\n             if subset_ids != [i for position, i in position_id]:\n                 raise BadRequest("Client/server ordering mismatch")\n \n+        # Make sure we use bytestring ids for PY2.\n+        if six.PY2:\n+            if isinstance(obj_id, six.text_type):\n+                obj_id = obj_id.encode(\'utf-8\')\n+            if subset_ids:\n+                subset_ids = [\n+                    id_.encode(\'utf-8\') if isinstance(id_, six.text_type)\n+                    else id_ for id_ in subset_ids\n+                ]\n+\n         # All movement is relative to the subset of ids, if passed in.\n         if delta == "top":\n             ordering.moveObjectsToTop([obj_id], subset_ids=subset_ids)\ndiff --git a/src/plone/restapi/tests/mixin_ordering.py b/src/plone/restapi/tests/mixin_ordering.py\nindex 365eff43..bfb13c5a 100644\n--- a/src/plone/restapi/tests/mixin_ordering.py\n+++ b/src/plone/restapi/tests/mixin_ordering.py\n@@ -195,6 +195,38 @@ def test_reorder(self):\n             self.folder.contentIds(),\n         )\n \n+    def test_ordering_preserves_native_string_obj_id(self):\n+        # sanity check, initial situation\n+        for id_ in self.folder.objectIds():\n+            self.assertIsInstance(id_, str)\n+\n+        # reorder\n+        data = {"ordering": {"delta": "top", "obj_id": "doc9"}}\n+        self.deserialize(body=json.dumps(data), context=self.folder)\n+\n+        # reordering should preserve bytestring ids in PY2 and unicode ids in PY3\n+        for id_ in self.folder.objectIds():\n+            self.assertIsInstance(id_, str)\n+\n+    def test_ordering_preserves_native_string_subset_ids(self):\n+        # sanity check, initial situation\n+        for id_ in self.folder.objectIds():\n+            self.assertIsInstance(id_, str)\n+\n+        # reorder and also provide subset_ids\n+        data = {\n+            "ordering": {\n+                "delta": "bottom",\n+                "obj_id": "doc1",\n+                "subset_ids": ["doc1", "doc2", "doc3"],\n+            }\n+        }  # noqa\n+        self.deserialize(body=json.dumps(data), context=self.folder)\n+\n+        # reordering should preserve bytestring ids in PY2 and unicode ids in PY3\n+        for id_ in self.folder.objectIds():\n+            self.assertIsInstance(id_, str)\n+\n     def test_reorder_subsetids(self):\n         # sanity check, initial situation\n         self.assertEqual(\ndiff --git a/src/plone/restapi/tests/test_upgrade_ordering.py b/src/plone/restapi/tests/test_upgrade_ordering.py\nnew file mode 100644\nindex 00000000..412cf030\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_upgrade_ordering.py\n@@ -0,0 +1,79 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.restapi.testing import PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+from plone.restapi.upgrades.ordering import ensure_child_ordering_object_ids_are_native_strings\n+\n+import unittest\n+import six\n+\n+\n+class TestUpgradeOrdering(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        self.folder = self.portal[\n+            self.portal.invokeFactory("Folder", id="folder1", title="Folder")\n+        ]\n+        for x in range(1, 4):\n+            self.folder.invokeFactory(\n+                "Document", id="doc" + str(x), title="Test doc " + str(x)\n+            )\n+\n+    def test_upgrade_ensure_child_ordering_object_ids_are_native_strings(self):\n+        ordering = self.folder.getOrdering()\n+\n+        # use incorrect type for ordering, results in mixed type ordering ids\n+        # on folder\n+        ordering.moveObjectsToBottom([six.text_type(\'doc1\')])\n+\n+        ensure_child_ordering_object_ids_are_native_strings(self.folder)\n+\n+        self.assertEqual(\n+            [\n+                "doc2",\n+                "doc3",\n+                "doc1",\n+            ],  # noqa\n+            self.folder.objectIds(),\n+        )\n+\n+        # upgrade helper should ensure bytestring ids in python2 and do nothing\n+        # on python3\n+        for id_ in self.folder.objectIds():\n+            self.assertIsInstance(id_, str)\n+\n+    def test_upgrade_can_be_called_with_nonetype(self):\n+        ensure_child_ordering_object_ids_are_native_strings(None)\n+\n+    def test_upgrade_can_be_called_with_not_annotatable(self):\n+        ensure_child_ordering_object_ids_are_native_strings(object())\n+\n+    def test_upgrade_view(self):\n+        ordering = self.folder.getOrdering()\n+        # use incorrect type for ordering, results in mixed type ordering ids\n+        # on folder\n+        ordering.moveObjectsToBottom([six.text_type(\'doc1\')])\n+\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        view = self.portal.restrictedTraverse(\n+            \'@@plone-restapi-upgrade-fix-ordering\')\n+        view()\n+\n+        self.assertEqual(\n+            [\n+                "doc2",\n+                "doc3",\n+                "doc1",\n+            ],  # noqa\n+            self.folder.objectIds(),\n+        )\n+\n+        # upgrade helper should ensure bytestring ids in python2 and do nothing\n+        # on python3\n+        for id_ in self.folder.objectIds():\n+            self.assertIsInstance(id_, str)\ndiff --git a/src/plone/restapi/upgrades/configure.zcml b/src/plone/restapi/upgrades/configure.zcml\nindex ca6bb951..d96c1b37 100644\n--- a/src/plone/restapi/upgrades/configure.zcml\n+++ b/src/plone/restapi/upgrades/configure.zcml\n@@ -1,8 +1,17 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n+    xmlns:browser="http://namespaces.zope.org/browser"\n     xmlns:genericsetup="http://namespaces.zope.org/genericsetup"\n     i18n_domain="plone.restapi">\n \n+    <!-- Upgrade to fix ordering, call manually via this browser-view if necessary -->\n+    <browser:page\n+        for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+        name="plone-restapi-upgrade-fix-ordering"\n+        class=".ordering.FixOrderingView"\n+        permission="cmf.ManagePortal"\n+        />\n+\n     <!-- 0001 -> 0002 -->\n     <genericsetup:upgradeStep\n         title="Assign \'plone.restapi: Use REST API\' permission to Anonymous"\ndiff --git a/src/plone/restapi/upgrades/ordering.py b/src/plone/restapi/upgrades/ordering.py\nnew file mode 100644\nindex 00000000..a7c08ed1\n--- /dev/null\n+++ b/src/plone/restapi/upgrades/ordering.py\n@@ -0,0 +1,70 @@\n+# -*- coding: utf-8 -*-\n+from persistent.list import PersistentList\n+from plone import api\n+from plone.folder.default import DefaultOrdering\n+from Products.Five.browser import BrowserView\n+from zope.annotation.interfaces import IAnnotatable\n+from zope.annotation.interfaces import IAnnotations\n+\n+import six\n+\n+\n+ORDER_KEY = DefaultOrdering.ORDER_KEY\n+QUERY = {\'is_folderish\': True}\n+\n+\n+def safe_utf8(to_utf8):\n+    if isinstance(to_utf8, six.text_type):\n+        to_utf8 = to_utf8.encode(\'utf-8\')\n+    return to_utf8\n+\n+\n+def ensure_child_ordering_object_ids_are_native_strings(container):\n+    """Make sure the ordering stored on parent contains only native_string\n+    object ids.\n+\n+    This function can be used to fix ordering object ids stored on a parent\n+    object in a `DefaultOrdering` ordering adapter. When changing object\n+    ordering via PATCH request we used to incorrectly store ids of reordered\n+    resouces as unicode instead of a bytestring (on python 2). This\n+    lead to mixed types being stored in the ordering annotations and\n+    subsequently mixed types being returned when calling `objectIds` of a\n+    container.\n+\n+    The problem only exists with python 2 so we do nothing when we are\n+    called on python 3 by mistake.\n+    """\n+    if six.PY3:\n+        return\n+\n+    if not IAnnotatable.providedBy(container):\n+        return\n+\n+    annotations = IAnnotations(container)\n+    if ORDER_KEY not in annotations:\n+        return\n+\n+    fixed_ordering = PersistentList(\n+        safe_utf8(item_id) for item_id in annotations[ORDER_KEY])\n+    annotations[ORDER_KEY] = fixed_ordering\n+\n+\n+class FixOrderingView(BrowserView):\n+    """Attempt to fix ordering for all potentially affected objects.\n+\n+    By default will fix ordering object ids for every object that considers\n+    itself folderish.\n+\n+    The problem only exists with python 2 so we do nothing when we are\n+    called on python 3 by mistake.\n+    """\n+    def __call__(self):\n+        if six.PY3:\n+            return "Aborted, fixing ordering is only necessary on python 2."\n+\n+        catalog = api.portal.get_tool("portal_catalog")\n+        for brain in catalog.unrestrictedSearchResults(QUERY):\n+            folderish = brain.getObject()\n+            ensure_child_ordering_object_ids_are_native_strings(folderish)\n+\n+        return "Done."\n'

