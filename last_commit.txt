Repository: plone.namedfile


Branch: refs/heads/master
Date: 2019-12-07T19:41:51+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/d92d7a54bfaa92f230f4311d8e3a806f7d04e7e1

fix tiff support

Files changed:
A plone/namedfile/tests/image.tif
M plone/namedfile/tests/test_image.py
M plone/namedfile/utils/__init__.py
D plone/namedfile/utils/tiff_utils.py

b'diff --git a/plone/namedfile/tests/image.tif b/plone/namedfile/tests/image.tif\nnew file mode 100644\nindex 0000000..687a26e\nBinary files /dev/null and b/plone/namedfile/tests/image.tif differ\ndiff --git a/plone/namedfile/tests/test_image.py b/plone/namedfile/tests/test_image.py\nindex c4420fc..643793c 100644\n--- a/plone/namedfile/tests/test_image.py\n+++ b/plone/namedfile/tests/test_image.py\n@@ -75,6 +75,12 @@ def test_get_contenttype(self):\n                     getFile(\'image.gif\'),\n                     filename=u\'image.gif\')),\n             \'image/gif\')\n+        self.assertEqual(\n+            get_contenttype(\n+                NamedImage(\n+                    getFile(\'image.tif\'),\n+                    filename=u\'image.tif\')),\n+            \'image/tiff\')\n         self.assertEqual(get_contenttype(\n             NamedImage(getFile(\'notimage.doc\'),\n                        filename=u\'notimage.doc\')),\ndiff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex cf2d48f..68a96ed 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -4,7 +4,6 @@\n from plone.namedfile.utils.jpeg_utils import process_jpeg\n from plone.namedfile.utils.png_utils import process_png\n from plone.namedfile.utils.svg_utils import process_svg\n-from plone.namedfile.utils.tiff_utils import process_tiff\n from plone.registry.interfaces import IRegistry\n from six import BytesIO\n from six.moves import urllib\n@@ -138,10 +137,6 @@ def getImageInfo(data):\n             content_type = \'image/x-ms-bmp\'\n             width, height = struct.unpack(\'<LL\', data[18:26])\n \n-    elif (size >= 4) and data[:4] in [b\'MM\\x00*\', b\'II*\\x00\']:\n-        # handle TIFFs\n-        content_type, width, height = process_tiff(data)\n-\n     elif size and b\'http://www.w3.org/2000/svg\' in data:\n         # handle SVGs\n         content_type, width, height = process_svg(data)\n@@ -151,7 +146,7 @@ def getImageInfo(data):\n         try:\n             img = PIL.Image.open(BytesIO(data))\n             width, height = img.size\n-            content_type = img.format\n+            content_type = PIL.Image.MIME[img.format]\n         except Exception:\n             # TODO: determ wich error really happens\n             # Should happen if data is to short --> first_bytes\ndiff --git a/plone/namedfile/utils/tiff_utils.py b/plone/namedfile/utils/tiff_utils.py\ndeleted file mode 100644\nindex bfdd01c..0000000\n--- a/plone/namedfile/utils/tiff_utils.py\n+++ /dev/null\n@@ -1,97 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from logging import getLogger\n-from six import BytesIO\n-\n-import struct\n-\n-\n-log = getLogger(__name__)\n-\n-\n-def process_tiff(data):\n-    """handle Tiff Images\n-    --> Doc http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n-\n-    """\n-    content_type = None\n-    w = -1\n-    h = -1\n-    # check for \'42\' as flag for tiff:\n-    # TODO: implement correct Image Length and Image Width lookup --> Page 14ff\n-    # Page 18: Tags:\n-    # ImageLength: Tag: 257 (101.H) Short or Long\n-    # ImageWidth: Tag: 256 (100.H) Short or Long\n-\n-    try:\n-        # Image File Header (Page 13-14):\n-        # First 2 Bytes: Determ Byte Order\n-        # --> II (4949.H) --> little-endian\n-        # --> MM (4D4D.H) --> big-endian\n-        # next 2 Bytes always Number: 42\n-        endian = None\n-        if data[:2] == \'MM\' and struct.unpack(\'>I\', data[2:4])[0] == 42:\n-            content_type = \'image/tiff\'\n-            endian = \'>\'  # big-endian encoding for the whole data stream\n-            log.info(\'Tiff Image in big-endian encoding\')\n-        elif data[:2] == \'II\' and struct.unpack(\'<I\', data[2:4])[0] == 42:\n-            content_type = \'image/tiff\'\n-            endian = \'<\'  # little-endian encoding for the whole data stream\n-            log.info(\'Tiff Image in little-endian encoding\')\n-        else:\n-            # not a tiff image\n-            log.info(\'Endian or 42 Check failed\')\n-\n-        if endian:\n-            tiff = BytesIO(data)\n-            tiff.read(4)  # Magic Header, could be skipped, already processed\n-            offset = struct.unpack_from(endian + \'I\', tiff)  # first IFD offset\n-            b = tiff.read(offset)\n-            # Process Image File Directory\n-            while (b and ord(b) != 0xDA):\n-                field_tag = struct.unpack_from(endian + \'I\', tiff)\n-                field_type = struct.unpack_from(endian + \'I\', tiff)\n-                field_type = translate_field_type.get(field_type, field_type)\n-                field_value = struct.unpack_from(endian + field_type, tiff)\n-                if field_tag == \'256\':  # ImageWidth\n-                    w = field_value\n-                elif field_tag == \'257\':  # ImageLength\n-                    h = field_value\n-                    # as fields has to appear in ascending order\n-                    # we could skip all other fields\n-                    break\n-                next_offset = struct.unpack_from(endian + \'I\', tiff)\n-                b.read(next_offset)\n-    except struct.error:\n-        pass\n-    except ValueError:\n-        pass\n-    except TypeError:\n-        pass\n-\n-    width = int(w)\n-    height = int(h)\n-    return content_type, width, height\n-\n-\n-translate_field_type = {\n-    """handle Tiff Image File Directory Types\n-    --> Doc http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n-    page 14-16\n-    """\n-    # TODO: translate to correct python struct mapping\n-    # TODO: check mappings\n-    \'1\': \'I\',  # BYTE: 8-bit unsigned Integer\n-    \'2\': \'c\',  # \'b\' \'B\'\n-               # ASCII: 8-bit byte that contains a 7-bit ASCII code\n-    \'3\': \'H\',  # SHORT: 16-bit (2-byte) unsigned integer\n-    \'4\': \'L\',  # LONG: 32-bit (4-byte) unsigned integer\n-    \'5\': \'\',  # RATIONAL, two LONGs: the first represents the numerator\n-              # of a fraction; the second, the donominator\n-    \'6\': \'\',  # SBYTE: An 8-bit signed (twos-complement) integer\n-    \'7\': \'\',  # UNDEFINED\n-    \'8\': \'\',  # SSHORT: A 16-bit (2-byte) signed (twos-complement) integer\n-    \'9\': \'\',   # SLONG: A 32-bit (4-byte) signed (twos-complement) integer\n-    \'10\': \'\',  # SRATIONAL: Two SLONG\'s (mutator, denominator)\n-    \'11\': \'\',  # FLOAT: Single precision (4-byte) IEEE format.\n-    \'12\': \'\',  # DOUBLE: Double precision (8-byte) IEEE format.\n-}\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2019-12-07T20:41:19+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/c0d2b13434579e2d8d351b58293f5d779edb6ebc

changelog

Files changed:
A news/85.bugfix

b'diff --git a/news/85.bugfix b/news/85.bugfix\nnew file mode 100644\nindex 0000000..a398680\n--- /dev/null\n+++ b/news/85.bugfix\n@@ -0,0 +1,5 @@\n+Fix tiff support. Remove process_tiff and let the PIL do the work.\n+[mamico]\n+\n+Fix content_type in getImageInfo when using PIL.\n+[mamicp]\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2019-12-08T10:55:46+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/baabb78eda79c5651dacfe90cc2fc6369b8a9276

Merge pull request #85 from plone/tiff

tiff support

Files changed:
A news/85.bugfix
A plone/namedfile/tests/image.tif
M plone/namedfile/tests/test_image.py
M plone/namedfile/utils/__init__.py
D plone/namedfile/utils/tiff_utils.py

b'diff --git a/news/85.bugfix b/news/85.bugfix\nnew file mode 100644\nindex 0000000..a398680\n--- /dev/null\n+++ b/news/85.bugfix\n@@ -0,0 +1,5 @@\n+Fix tiff support. Remove process_tiff and let the PIL do the work.\n+[mamico]\n+\n+Fix content_type in getImageInfo when using PIL.\n+[mamicp]\ndiff --git a/plone/namedfile/tests/image.tif b/plone/namedfile/tests/image.tif\nnew file mode 100644\nindex 0000000..687a26e\nBinary files /dev/null and b/plone/namedfile/tests/image.tif differ\ndiff --git a/plone/namedfile/tests/test_image.py b/plone/namedfile/tests/test_image.py\nindex c4420fc..643793c 100644\n--- a/plone/namedfile/tests/test_image.py\n+++ b/plone/namedfile/tests/test_image.py\n@@ -75,6 +75,12 @@ def test_get_contenttype(self):\n                     getFile(\'image.gif\'),\n                     filename=u\'image.gif\')),\n             \'image/gif\')\n+        self.assertEqual(\n+            get_contenttype(\n+                NamedImage(\n+                    getFile(\'image.tif\'),\n+                    filename=u\'image.tif\')),\n+            \'image/tiff\')\n         self.assertEqual(get_contenttype(\n             NamedImage(getFile(\'notimage.doc\'),\n                        filename=u\'notimage.doc\')),\ndiff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex cf2d48f..68a96ed 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -4,7 +4,6 @@\n from plone.namedfile.utils.jpeg_utils import process_jpeg\n from plone.namedfile.utils.png_utils import process_png\n from plone.namedfile.utils.svg_utils import process_svg\n-from plone.namedfile.utils.tiff_utils import process_tiff\n from plone.registry.interfaces import IRegistry\n from six import BytesIO\n from six.moves import urllib\n@@ -138,10 +137,6 @@ def getImageInfo(data):\n             content_type = \'image/x-ms-bmp\'\n             width, height = struct.unpack(\'<LL\', data[18:26])\n \n-    elif (size >= 4) and data[:4] in [b\'MM\\x00*\', b\'II*\\x00\']:\n-        # handle TIFFs\n-        content_type, width, height = process_tiff(data)\n-\n     elif size and b\'http://www.w3.org/2000/svg\' in data:\n         # handle SVGs\n         content_type, width, height = process_svg(data)\n@@ -151,7 +146,7 @@ def getImageInfo(data):\n         try:\n             img = PIL.Image.open(BytesIO(data))\n             width, height = img.size\n-            content_type = img.format\n+            content_type = PIL.Image.MIME[img.format]\n         except Exception:\n             # TODO: determ wich error really happens\n             # Should happen if data is to short --> first_bytes\ndiff --git a/plone/namedfile/utils/tiff_utils.py b/plone/namedfile/utils/tiff_utils.py\ndeleted file mode 100644\nindex bfdd01c..0000000\n--- a/plone/namedfile/utils/tiff_utils.py\n+++ /dev/null\n@@ -1,97 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from logging import getLogger\n-from six import BytesIO\n-\n-import struct\n-\n-\n-log = getLogger(__name__)\n-\n-\n-def process_tiff(data):\n-    """handle Tiff Images\n-    --> Doc http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n-\n-    """\n-    content_type = None\n-    w = -1\n-    h = -1\n-    # check for \'42\' as flag for tiff:\n-    # TODO: implement correct Image Length and Image Width lookup --> Page 14ff\n-    # Page 18: Tags:\n-    # ImageLength: Tag: 257 (101.H) Short or Long\n-    # ImageWidth: Tag: 256 (100.H) Short or Long\n-\n-    try:\n-        # Image File Header (Page 13-14):\n-        # First 2 Bytes: Determ Byte Order\n-        # --> II (4949.H) --> little-endian\n-        # --> MM (4D4D.H) --> big-endian\n-        # next 2 Bytes always Number: 42\n-        endian = None\n-        if data[:2] == \'MM\' and struct.unpack(\'>I\', data[2:4])[0] == 42:\n-            content_type = \'image/tiff\'\n-            endian = \'>\'  # big-endian encoding for the whole data stream\n-            log.info(\'Tiff Image in big-endian encoding\')\n-        elif data[:2] == \'II\' and struct.unpack(\'<I\', data[2:4])[0] == 42:\n-            content_type = \'image/tiff\'\n-            endian = \'<\'  # little-endian encoding for the whole data stream\n-            log.info(\'Tiff Image in little-endian encoding\')\n-        else:\n-            # not a tiff image\n-            log.info(\'Endian or 42 Check failed\')\n-\n-        if endian:\n-            tiff = BytesIO(data)\n-            tiff.read(4)  # Magic Header, could be skipped, already processed\n-            offset = struct.unpack_from(endian + \'I\', tiff)  # first IFD offset\n-            b = tiff.read(offset)\n-            # Process Image File Directory\n-            while (b and ord(b) != 0xDA):\n-                field_tag = struct.unpack_from(endian + \'I\', tiff)\n-                field_type = struct.unpack_from(endian + \'I\', tiff)\n-                field_type = translate_field_type.get(field_type, field_type)\n-                field_value = struct.unpack_from(endian + field_type, tiff)\n-                if field_tag == \'256\':  # ImageWidth\n-                    w = field_value\n-                elif field_tag == \'257\':  # ImageLength\n-                    h = field_value\n-                    # as fields has to appear in ascending order\n-                    # we could skip all other fields\n-                    break\n-                next_offset = struct.unpack_from(endian + \'I\', tiff)\n-                b.read(next_offset)\n-    except struct.error:\n-        pass\n-    except ValueError:\n-        pass\n-    except TypeError:\n-        pass\n-\n-    width = int(w)\n-    height = int(h)\n-    return content_type, width, height\n-\n-\n-translate_field_type = {\n-    """handle Tiff Image File Directory Types\n-    --> Doc http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n-    page 14-16\n-    """\n-    # TODO: translate to correct python struct mapping\n-    # TODO: check mappings\n-    \'1\': \'I\',  # BYTE: 8-bit unsigned Integer\n-    \'2\': \'c\',  # \'b\' \'B\'\n-               # ASCII: 8-bit byte that contains a 7-bit ASCII code\n-    \'3\': \'H\',  # SHORT: 16-bit (2-byte) unsigned integer\n-    \'4\': \'L\',  # LONG: 32-bit (4-byte) unsigned integer\n-    \'5\': \'\',  # RATIONAL, two LONGs: the first represents the numerator\n-              # of a fraction; the second, the donominator\n-    \'6\': \'\',  # SBYTE: An 8-bit signed (twos-complement) integer\n-    \'7\': \'\',  # UNDEFINED\n-    \'8\': \'\',  # SSHORT: A 16-bit (2-byte) signed (twos-complement) integer\n-    \'9\': \'\',   # SLONG: A 32-bit (4-byte) signed (twos-complement) integer\n-    \'10\': \'\',  # SRATIONAL: Two SLONG\'s (mutator, denominator)\n-    \'11\': \'\',  # FLOAT: Single precision (4-byte) IEEE format.\n-    \'12\': \'\',  # DOUBLE: Double precision (8-byte) IEEE format.\n-}\n'

