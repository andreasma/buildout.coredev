Repository: plone.dexterity


Branch: refs/heads/master
Date: 2019-12-23T10:37:07+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.dexterity/commit/af8ce7925e2e24e0d7cb335413acd618ba919637

fix: thread safe recursion detection

Files changed:
M plone/dexterity/content.py

b"diff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex 75d56c6..0bf92de 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -50,10 +50,12 @@\n from zope.security.interfaces import IPermission\n \n import six\n+import threading\n \n \n _marker = object()\n _zone = DateTime().timezone()\n+_recursion_detection = threading.local()\n FLOOR_DATE = DateTime(1970, 0)  # always effective\n CEILING_DATE = DateTime(2500, 0)  # never expires\n \n@@ -128,13 +130,12 @@ def __get__(self, inst, cls=None):\n         if inst is None:\n             return getObjectSpecification(cls)\n \n-        direct_spec = getattr(inst, '__provides__', None)\n+        # get direct specification\n+        spec = getattr(inst, '__provides__', None)\n \n         # avoid recursion - fall back on default\n-        if getattr(self, '__recursion__', False):\n-            return direct_spec\n-\n-        spec = direct_spec\n+        if getattr(_recursion_detection, 'blocked', False):\n+            return spec\n \n         # If the instance doesn't have a __provides__ attribute, get the\n         # interfaces implied by the class as a starting point.\n@@ -161,7 +162,7 @@ def __get__(self, inst, cls=None):\n             inst._p_mtime,\n             SCHEMA_CACHE.modified(portal_type),\n             SCHEMA_CACHE.invalidations,\n-            hash(direct_spec)\n+            hash(spec)\n         )\n         if cache is not None and cache[:-1] == updated:\n             if cache[-1] is not None:\n@@ -175,7 +176,7 @@ def __get__(self, inst, cls=None):\n             dynamically_provided = []\n \n         # block recursion\n-        self.__recursion__ = True\n+        setattr(_recursion_detection, 'blocked', True)\n         try:\n             assignable = get_assignable(inst)\n             if assignable is not None:\n@@ -185,7 +186,7 @@ def __get__(self, inst, cls=None):\n                             behavior_registration.marker\n                         )\n         finally:\n-            del self.__recursion__\n+            setattr(_recursion_detection, 'blocked', False)\n \n         if not dynamically_provided:\n             # rare case if no schema nor behaviors with markers are set\n"

Repository: plone.dexterity


Branch: refs/heads/master
Date: 2019-12-23T10:37:07+01:00
Author: Timo Stollenwerk (tisto) <stollenwerk@kitconcept.com>
Commit: https://github.com/plone/plone.dexterity/commit/b293f5b5ec5ac27bda6512a2c9e5aca4aaee27f9

Add changelog entry for #120.

Files changed:
A news/120.bugfix

b'diff --git a/news/120.bugfix b/news/120.bugfix\nnew file mode 100644\nindex 0000000..358c024\n--- /dev/null\n+++ b/news/120.bugfix\n@@ -0,0 +1 @@\n+- Fix thread safe recursion detection. This fixes an issue in plone.restapi: https://github.com/plone/plone.dexterity/issues/120. [jensens]\n\\ No newline at end of file\n'

