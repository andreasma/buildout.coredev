Repository: plone.session


Branch: refs/heads/master
Date: 2018-05-16T17:04:20+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.session/commit/ae9029aaf5112aa6733edc351c6215029ab19a01

fix import for py3

Files changed:
M plone/session/plugins/session.py

b'diff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex 5ac17d3..7e7200d 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -2,7 +2,7 @@\n from AccessControl.requestmethod import postonly\n from AccessControl.SecurityInfo import ClassSecurityInfo\n from App.config import getConfiguration\n-from email.Utils import formatdate\n+from email.utils import formatdate\n from plone.keyring.interfaces import IKeyManager\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-05-16T17:04:20+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.session/commit/6bb410794ee2d07f16e08b5c08f0fbffb3686daa

first stab at only using bytes for the cookie

Files changed:
M plone/session/tktauth.py

b'diff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex 6e7a5f5..a94205f 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -160,21 +160,25 @@ def mod_auth_tkt_digest(secret, data1, data2):\n     return digest\n \n \n-def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n+def safe_utf8(value):\n+    if isinstance(value, six.text_type):\n+        value = value.encode(\'utf-8\')\n+    return value\n+\n+\n+def createTicket(secret, userid, tokens=(), user_data=b\'\', ip=\'0.0.0.0\',\n                  timestamp=None, encoding=\'utf-8\', mod_auth_tkt=False):\n     """\n     By default, use a more compatible\n     """\n     if timestamp is None:\n         timestamp = int(time.time())\n-    if encoding is not None:\n-        userid = userid.encode(encoding)\n-        tokens = [t.encode(encoding) for t in tokens]\n-        user_data = user_data.encode(encoding)\n-    # if type(userid) == unicode:\n-        # userid = userid.encode(\'utf-8\')\n+    secret = safe_utf8(secret)\n+    userid = safe_utf8(userid)\n+    tokens = [safe_utf8(t) for t in tokens]\n+    user_data = safe_utf8(user_data)\n \n-    token_list = \',\'.join(tokens)\n+    token_list = b\',\'.join(tokens)\n \n     # ip address is part of the format, set it to 0.0.0.0 to be ignored.\n     # inet_aton packs the ip address into a 4 bytes in network byte order.\n@@ -184,7 +188,7 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n     # 32 bits, so we need to trucate the result in case we are on a 64-bit\n     # naive system.\n     data1 = inet_aton(ip)[:4] + pack(\'!I\', timestamp)\n-    data2 = \'\\0\'.join((userid, token_list, user_data))\n+    data2 = b\'\\0\'.join((userid, token_list, user_data))\n     if mod_auth_tkt:\n         digest = mod_auth_tkt_digest(secret, data1, data2)\n     else:\n@@ -192,9 +196,9 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n         digest = hmac.new(secret, data1 + data2, hashlib.sha256).digest()\n \n     # digest + timestamp as an eight character hexadecimal + userid + !\n-    ticket = \'%s%08x%s!\' % (digest, timestamp, userid)\n+    ticket = b\'%s%08x%s!\' % (digest, timestamp, userid)\n     if tokens:\n-        ticket += token_list + \'!\'\n+        ticket += token_list + b\'!\'\n     ticket += user_data\n \n     return ticket\n@@ -210,14 +214,14 @@ def splitTicket(ticket, encoding=None):\n \n     if encoding is not None:\n         remainder = remainder.decode(encoding)\n-    parts = remainder.split("!")\n+    parts = remainder.split(b"!")\n \n     if len(parts) == 2:\n         userid, user_data = parts\n         tokens = ()\n     elif len(parts) == 3:\n         userid, token_list, user_data = parts\n-        tokens = tuple(token_list.split(\',\'))\n+        tokens = tuple(token_list.split(b\',\'))\n     else:\n         raise ValueError\n \n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-05-16T17:04:20+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.session/commit/83c7ced328651d560397f60eac5cd99643a2f413

comparing should work with text and bytes

Files changed:
M plone/session/tktauth.py

b'diff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex a94205f..a09cd69 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -144,7 +144,8 @@\n \n def is_equal(val1, val2):\n     # constant time comparison\n-    if not isinstance(val1, six.string_types) or not isinstance(val2, six.string_types):\n+    if not isinstance(val1, (six.string_types, six.binary_type)) or \\\n+       not isinstance(val2, (six.string_types, six.binary_type)):\n         return False\n     if len(val1) != len(val2):\n         return False\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-05-16T17:04:20+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.session/commit/6938cf1bfba30761376cd5fe4263cb0adf852ac4

fix cookie handling (and login as Plone-user) (pbauer, jmevissen, sallner)

Files changed:
M plone/session/tktauth.py

b'diff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex a09cd69..bfff507 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -134,6 +134,8 @@\n \n """\n \n+from Products.CMFPlone.utils import safe_encode\n+from Products.CMFPlone.utils import safe_unicode\n from socket import inet_aton\n from struct import pack\n import hashlib\n@@ -144,14 +146,18 @@\n \n def is_equal(val1, val2):\n     # constant time comparison\n-    if not isinstance(val1, (six.string_types, six.binary_type)) or \\\n-       not isinstance(val2, (six.string_types, six.binary_type)):\n+    if not isinstance(val1, six.binary_type) or \\\n+       not isinstance(val2, six.binary_type):\n         return False\n     if len(val1) != len(val2):\n         return False\n     result = 0\n-    for x, y in zip(val1, val2):\n-        result |= ord(x) ^ ord(y)\n+    if six.PY2:\n+        for x, y in zip(val1, val2):\n+            result |= ord(x) ^ ord(y)\n+    else:\n+        for x, y in zip(val1, val2):\n+            result |= x ^ y\n     return result == 0\n \n \n@@ -161,23 +167,17 @@ def mod_auth_tkt_digest(secret, data1, data2):\n     return digest\n \n \n-def safe_utf8(value):\n-    if isinstance(value, six.text_type):\n-        value = value.encode(\'utf-8\')\n-    return value\n-\n-\n-def createTicket(secret, userid, tokens=(), user_data=b\'\', ip=\'0.0.0.0\',\n+def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n                  timestamp=None, encoding=\'utf-8\', mod_auth_tkt=False):\n     """\n     By default, use a more compatible\n     """\n     if timestamp is None:\n         timestamp = int(time.time())\n-    secret = safe_utf8(secret)\n-    userid = safe_utf8(userid)\n-    tokens = [safe_utf8(t) for t in tokens]\n-    user_data = safe_utf8(user_data)\n+    secret = safe_encode(secret)\n+    userid = safe_encode(userid)\n+    tokens = [safe_encode(t) for t in tokens]\n+    user_data = safe_encode(user_data)\n \n     token_list = b\',\'.join(tokens)\n \n@@ -213,16 +213,18 @@ def splitTicket(ticket, encoding=None):\n         raise ValueError\n     timestamp = int(val, 16)  # convert from hexadecimal+\n \n-    if encoding is not None:\n-        remainder = remainder.decode(encoding)\n-    parts = remainder.split(b"!")\n+    if six.PY3:\n+        remainder = safe_unicode(remainder)\n+    elif encoding is not None:\n+        remainder = safe_unicode(remainder, encoding)\n+    parts = remainder.split(\'!\')\n \n     if len(parts) == 2:\n         userid, user_data = parts\n         tokens = ()\n     elif len(parts) == 3:\n         userid, token_list, user_data = parts\n-        tokens = tuple(token_list.split(b\',\'))\n+        tokens = tuple(token_list.split(\',\'))\n     else:\n         raise ValueError\n \n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-06-10T10:49:10+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/c2af14e949a1e93917705af7df6abd09b9bb9808

Make tests compatible across Python versions

Files changed:
M plone/session/tests/testDocTests.py
M plone/session/tests/testPAS.py
M plone/session/tktauth.py

b'diff --git a/plone/session/tests/testDocTests.py b/plone/session/tests/testDocTests.py\nindex dc75d15..c6bc9ce 100644\n--- a/plone/session/tests/testDocTests.py\n+++ b/plone/session/tests/testDocTests.py\n@@ -1,12 +1,31 @@\n+# coding=utf-8\n import doctest\n import unittest\n+import six\n+import re\n \n from plone.session import tktauth\n \n optionflags = doctest.ELLIPSIS\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     suite = unittest.TestSuite()\n-    suite.addTest(doctest.DocTestSuite(tktauth, optionflags=optionflags))\n+    suite.addTest(\n+        doctest.DocTestSuite(\n+            tktauth,\n+            optionflags=optionflags,\n+            checker=Py23DocChecker(),\n+        )\n+    )\n     return suite\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex 513be1c..24fcfa0 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -4,6 +4,7 @@\n from plone.session.interfaces import ISessionPlugin\n from plone.session.tests.sessioncase import FunctionalPloneSessionTestCase\n \n+import base64\n import six\n \n \n@@ -71,11 +72,16 @@ def testCookieLifetimeWithExpirationSet(self):\n \n     def testExtraction(self):\n         session = self.folder.pas.session\n-\n-        request = self.makeRequest("test string".encode("base64"))\n+        # We will preapre a request that is equal in Py2 and Py3\n+        if six.PY2:\n+            request_body = base64.encodestring(b"test string")\n+        else:\n+            request_body = base64.encodebytes(b"test string").decode()\n+        self.assertEqual(request_body, \'dGVzdCBzdHJpbmc=\\n\')\n+        request = self.makeRequest(request_body)\n         creds = session.extractCredentials(request)\n         self.assertEqual(creds["source"], "plone.session")\n-        self.assertEqual(creds["cookie"], "test string")\n+        self.assertEqual(creds["cookie"], b"test string")\n \n         request = self.makeRequest("test string")\n         creds = session.extractCredentials(request)\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex bfff507..df6692c 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -50,14 +50,15 @@\n   ...     SECRET, userid, timestamp=timestamp, mod_auth_tkt=True\n   ... )\n   >>> tkt\n-  \'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n+  b\'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n \n The cookie itself should be base64 encoded. We will use the built-in Cookie\n module here, your web framework may supply it\'s own mechanism.\n \n-  >>> import Cookie, binascii\n-  >>> cookie = Cookie.SimpleCookie()\n-  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip()\n+  >>> from six.moves import http_cookies\n+  >>> import binascii\n+  >>> cookie = http_cookies.SimpleCookie()\n+  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip().decode()\n   >>> print(cookie)\n   Set-Cookie: auth_tkt=YzdjNzMwMGFjNWNmNTI5NjU2NDQ0MTIzYWNhMzQ1Mjk0ODg1YWZh...\n \n@@ -69,12 +70,12 @@\n \n   >>> tkt = binascii.a2b_base64(cookie[\'auth_tkt\'].value)\n   >>> tkt\n-  \'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n+  b\'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n \n Splitting the data reveals the contents (note the six.text_type output):\n \n   >>> splitTicket(tkt)\n-  (\'c7c7300ac5cf529656444123aca34529\', \'jbloggs\', (), \'\', 1216720800)\n+  (b\'c7c7300ac5cf529656444123aca34529\', \'jbloggs\', (), \'\', 1216720800)\n \n We will validate it an hour after it was created:\n \n@@ -109,15 +110,15 @@\n   ...     mod_auth_tkt=True\n   ... )\n   >>> tkt\n-  \'eea3630e98177bdbf0e7f803e1632b7e4885afa0jbloggs!foo,bar!Joe Bloggs\'\n-  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip()\n+  b\'eea3630e98177bdbf0e7f803e1632b7e4885afa0jbloggs!foo,bar!Joe Bloggs\'\n+  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip().decode()\n   >>> print(cookie)\n   Set-Cookie: auth_tkt=ZWVhMzYzMGU5ODE3N2JkYmYwZTdmODAzZTE2MzJiN2U0ODg1YWZh...\n   >>> data = validateTicket(\n   ...     SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True\n   ... )\n   >>> data\n-  (\'eea3630e98177bdbf0e7f803e1632b7e\', \'jbloggs\', (\'foo\', \'bar\'), \'Joe Bloggs\', 1216720800)\n+  (b\'eea3630e98177bdbf0e7f803e1632b7e\', \'jbloggs\', (\'foo\', \'bar\'), \'Joe Bloggs\', 1216720800)\n \n \n Using the more secure hashing scheme\n@@ -127,7 +128,7 @@\n \n   >>> tkt = createTicket(SECRET, userid, timestamp=timestamp)\n   >>> tkt\n-  \'\\xf3\\x08\\x98\\x99\\x83\\xb0;\\xef\\x95\\x94\\xee...\\xbe\\xf6X\\x114885afa0jbloggs!\'\n+  b\'\\xf3\\x08\\x98\\x99\\x83\\xb0;\\xef\\x95\\x94\\xee...\\xbe\\xf6X\\x114885afa0jbloggs!\'\n   >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=NOW)\n   >>> data is not None\n   True\n@@ -163,6 +164,10 @@ def is_equal(val1, val2):\n \n def mod_auth_tkt_digest(secret, data1, data2):\n     digest0 = hashlib.md5(data1 + secret + data2).hexdigest()\n+    if not six.PY2:\n+        # In Python 3 hashlib.md5(value).hexdigest() wants a bites value\n+        # and returns text\n+        digest0 = digest0.encode()\n     digest = hashlib.md5(digest0 + secret).hexdigest()\n     return digest\n \n@@ -196,6 +201,9 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n         # a sha256 digest is the same length as an md5 hexdigest\n         digest = hmac.new(secret, data1 + data2, hashlib.sha256).digest()\n \n+    if not isinstance(digest, six.binary_type):\n+        digest = digest.encode()\n+\n     # digest + timestamp as an eight character hexadecimal + userid + !\n     ticket = b\'%s%08x%s!\' % (digest, timestamp, userid)\n     if tokens:\n@@ -261,8 +269,10 @@ def validateTicket(secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None,\n # doctest runner\n def _test():\n     import doctest\n+    from plone.session.tests.testDocTests import Py23DocChecker\n     doctest.testmod(\n-        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE\n+        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE,\n+        checker=Py23DocChecker(),\n     )\n \n \n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-06-10T10:51:16+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/a928ee5e9114127a332030e1ec41c1e0ef19b9dc

Added a changelog line

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 94137cf..a7dab97 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,7 +14,7 @@ New features:\n \n Bug fixes:\n \n-- *add item here*\n+- Python3 compatibility [ale-rt, pbauer]\n \n \n 3.7.0 (2018-04-03)\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-06-10T11:01:22+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/d6a8dc807c4f34317adfc564a49c1ff4378c8562

The safe_encode function might be missing

Files changed:
M plone/session/tktauth.py

b'diff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex df6692c..29655b9 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -135,15 +135,25 @@\n \n """\n \n-from Products.CMFPlone.utils import safe_encode\n from Products.CMFPlone.utils import safe_unicode\n from socket import inet_aton\n from struct import pack\n+\n import hashlib\n import hmac\n import six\n import time\n \n+try:\n+    from Products.CMFPlone.utils import safe_encode\n+except ImportError:\n+    def safe_encode(value, encoding=\'utf-8\'):\n+        """Convert unicode to the specified encoding.\n+        """\n+        if isinstance(value, six.text_type):\n+            value = value.encode(encoding)\n+        return value\n+\n \n def is_equal(val1, val2):\n     # constant time comparison\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2018-08-17T10:45:56+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.session/commit/15d85db4a12d5dc65ae72c9ac4b4794d0e6f1399

update troove classifier

Files changed:
M setup.py

b"diff --git a/setup.py b/setup.py\nindex 063dd0e..6ce0210 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -21,6 +21,7 @@\n         'License :: OSI Approved :: BSD License',\n         'Operating System :: OS Independent',\n         'Programming Language :: Python :: 2.7',\n+        'Programming Language :: Python :: 3.6',\n         'Programming Language :: Python',\n         'Topic :: System :: Systems Administration :: Authentication/Directory',  # noqa\n     ],\n"

Repository: plone.session


Branch: refs/heads/master
Date: 2018-08-17T10:46:17+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.session/commit/9d60e327a25134e46e7dd3e9a750a38e5836d1bf

Merge pull request #13 from plone/python3

Fix handling session-cookies (and login) in py3

Files changed:
M CHANGES.rst
M plone/session/plugins/session.py
M plone/session/tests/testDocTests.py
M plone/session/tests/testPAS.py
M plone/session/tktauth.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 94137cf..a7dab97 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,7 +14,7 @@ New features:\n \n Bug fixes:\n \n-- *add item here*\n+- Python3 compatibility [ale-rt, pbauer]\n \n \n 3.7.0 (2018-04-03)\ndiff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex 5ac17d3..7e7200d 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -2,7 +2,7 @@\n from AccessControl.requestmethod import postonly\n from AccessControl.SecurityInfo import ClassSecurityInfo\n from App.config import getConfiguration\n-from email.Utils import formatdate\n+from email.utils import formatdate\n from plone.keyring.interfaces import IKeyManager\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\ndiff --git a/plone/session/tests/testDocTests.py b/plone/session/tests/testDocTests.py\nindex dc75d15..c6bc9ce 100644\n--- a/plone/session/tests/testDocTests.py\n+++ b/plone/session/tests/testDocTests.py\n@@ -1,12 +1,31 @@\n+# coding=utf-8\n import doctest\n import unittest\n+import six\n+import re\n \n from plone.session import tktauth\n \n optionflags = doctest.ELLIPSIS\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     suite = unittest.TestSuite()\n-    suite.addTest(doctest.DocTestSuite(tktauth, optionflags=optionflags))\n+    suite.addTest(\n+        doctest.DocTestSuite(\n+            tktauth,\n+            optionflags=optionflags,\n+            checker=Py23DocChecker(),\n+        )\n+    )\n     return suite\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex 513be1c..24fcfa0 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -4,6 +4,7 @@\n from plone.session.interfaces import ISessionPlugin\n from plone.session.tests.sessioncase import FunctionalPloneSessionTestCase\n \n+import base64\n import six\n \n \n@@ -71,11 +72,16 @@ def testCookieLifetimeWithExpirationSet(self):\n \n     def testExtraction(self):\n         session = self.folder.pas.session\n-\n-        request = self.makeRequest("test string".encode("base64"))\n+        # We will preapre a request that is equal in Py2 and Py3\n+        if six.PY2:\n+            request_body = base64.encodestring(b"test string")\n+        else:\n+            request_body = base64.encodebytes(b"test string").decode()\n+        self.assertEqual(request_body, \'dGVzdCBzdHJpbmc=\\n\')\n+        request = self.makeRequest(request_body)\n         creds = session.extractCredentials(request)\n         self.assertEqual(creds["source"], "plone.session")\n-        self.assertEqual(creds["cookie"], "test string")\n+        self.assertEqual(creds["cookie"], b"test string")\n \n         request = self.makeRequest("test string")\n         creds = session.extractCredentials(request)\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex 6e7a5f5..29655b9 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -50,14 +50,15 @@\n   ...     SECRET, userid, timestamp=timestamp, mod_auth_tkt=True\n   ... )\n   >>> tkt\n-  \'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n+  b\'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n \n The cookie itself should be base64 encoded. We will use the built-in Cookie\n module here, your web framework may supply it\'s own mechanism.\n \n-  >>> import Cookie, binascii\n-  >>> cookie = Cookie.SimpleCookie()\n-  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip()\n+  >>> from six.moves import http_cookies\n+  >>> import binascii\n+  >>> cookie = http_cookies.SimpleCookie()\n+  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip().decode()\n   >>> print(cookie)\n   Set-Cookie: auth_tkt=YzdjNzMwMGFjNWNmNTI5NjU2NDQ0MTIzYWNhMzQ1Mjk0ODg1YWZh...\n \n@@ -69,12 +70,12 @@\n \n   >>> tkt = binascii.a2b_base64(cookie[\'auth_tkt\'].value)\n   >>> tkt\n-  \'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n+  b\'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n \n Splitting the data reveals the contents (note the six.text_type output):\n \n   >>> splitTicket(tkt)\n-  (\'c7c7300ac5cf529656444123aca34529\', \'jbloggs\', (), \'\', 1216720800)\n+  (b\'c7c7300ac5cf529656444123aca34529\', \'jbloggs\', (), \'\', 1216720800)\n \n We will validate it an hour after it was created:\n \n@@ -109,15 +110,15 @@\n   ...     mod_auth_tkt=True\n   ... )\n   >>> tkt\n-  \'eea3630e98177bdbf0e7f803e1632b7e4885afa0jbloggs!foo,bar!Joe Bloggs\'\n-  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip()\n+  b\'eea3630e98177bdbf0e7f803e1632b7e4885afa0jbloggs!foo,bar!Joe Bloggs\'\n+  >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip().decode()\n   >>> print(cookie)\n   Set-Cookie: auth_tkt=ZWVhMzYzMGU5ODE3N2JkYmYwZTdmODAzZTE2MzJiN2U0ODg1YWZh...\n   >>> data = validateTicket(\n   ...     SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True\n   ... )\n   >>> data\n-  (\'eea3630e98177bdbf0e7f803e1632b7e\', \'jbloggs\', (\'foo\', \'bar\'), \'Joe Bloggs\', 1216720800)\n+  (b\'eea3630e98177bdbf0e7f803e1632b7e\', \'jbloggs\', (\'foo\', \'bar\'), \'Joe Bloggs\', 1216720800)\n \n \n Using the more secure hashing scheme\n@@ -127,35 +128,56 @@\n \n   >>> tkt = createTicket(SECRET, userid, timestamp=timestamp)\n   >>> tkt\n-  \'\\xf3\\x08\\x98\\x99\\x83\\xb0;\\xef\\x95\\x94\\xee...\\xbe\\xf6X\\x114885afa0jbloggs!\'\n+  b\'\\xf3\\x08\\x98\\x99\\x83\\xb0;\\xef\\x95\\x94\\xee...\\xbe\\xf6X\\x114885afa0jbloggs!\'\n   >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=NOW)\n   >>> data is not None\n   True\n \n """\n \n+from Products.CMFPlone.utils import safe_unicode\n from socket import inet_aton\n from struct import pack\n+\n import hashlib\n import hmac\n import six\n import time\n \n+try:\n+    from Products.CMFPlone.utils import safe_encode\n+except ImportError:\n+    def safe_encode(value, encoding=\'utf-8\'):\n+        """Convert unicode to the specified encoding.\n+        """\n+        if isinstance(value, six.text_type):\n+            value = value.encode(encoding)\n+        return value\n+\n \n def is_equal(val1, val2):\n     # constant time comparison\n-    if not isinstance(val1, six.string_types) or not isinstance(val2, six.string_types):\n+    if not isinstance(val1, six.binary_type) or \\\n+       not isinstance(val2, six.binary_type):\n         return False\n     if len(val1) != len(val2):\n         return False\n     result = 0\n-    for x, y in zip(val1, val2):\n-        result |= ord(x) ^ ord(y)\n+    if six.PY2:\n+        for x, y in zip(val1, val2):\n+            result |= ord(x) ^ ord(y)\n+    else:\n+        for x, y in zip(val1, val2):\n+            result |= x ^ y\n     return result == 0\n \n \n def mod_auth_tkt_digest(secret, data1, data2):\n     digest0 = hashlib.md5(data1 + secret + data2).hexdigest()\n+    if not six.PY2:\n+        # In Python 3 hashlib.md5(value).hexdigest() wants a bites value\n+        # and returns text\n+        digest0 = digest0.encode()\n     digest = hashlib.md5(digest0 + secret).hexdigest()\n     return digest\n \n@@ -167,14 +189,12 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n     """\n     if timestamp is None:\n         timestamp = int(time.time())\n-    if encoding is not None:\n-        userid = userid.encode(encoding)\n-        tokens = [t.encode(encoding) for t in tokens]\n-        user_data = user_data.encode(encoding)\n-    # if type(userid) == unicode:\n-        # userid = userid.encode(\'utf-8\')\n+    secret = safe_encode(secret)\n+    userid = safe_encode(userid)\n+    tokens = [safe_encode(t) for t in tokens]\n+    user_data = safe_encode(user_data)\n \n-    token_list = \',\'.join(tokens)\n+    token_list = b\',\'.join(tokens)\n \n     # ip address is part of the format, set it to 0.0.0.0 to be ignored.\n     # inet_aton packs the ip address into a 4 bytes in network byte order.\n@@ -184,17 +204,20 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n     # 32 bits, so we need to trucate the result in case we are on a 64-bit\n     # naive system.\n     data1 = inet_aton(ip)[:4] + pack(\'!I\', timestamp)\n-    data2 = \'\\0\'.join((userid, token_list, user_data))\n+    data2 = b\'\\0\'.join((userid, token_list, user_data))\n     if mod_auth_tkt:\n         digest = mod_auth_tkt_digest(secret, data1, data2)\n     else:\n         # a sha256 digest is the same length as an md5 hexdigest\n         digest = hmac.new(secret, data1 + data2, hashlib.sha256).digest()\n \n+    if not isinstance(digest, six.binary_type):\n+        digest = digest.encode()\n+\n     # digest + timestamp as an eight character hexadecimal + userid + !\n-    ticket = \'%s%08x%s!\' % (digest, timestamp, userid)\n+    ticket = b\'%s%08x%s!\' % (digest, timestamp, userid)\n     if tokens:\n-        ticket += token_list + \'!\'\n+        ticket += token_list + b\'!\'\n     ticket += user_data\n \n     return ticket\n@@ -208,9 +231,11 @@ def splitTicket(ticket, encoding=None):\n         raise ValueError\n     timestamp = int(val, 16)  # convert from hexadecimal+\n \n-    if encoding is not None:\n-        remainder = remainder.decode(encoding)\n-    parts = remainder.split("!")\n+    if six.PY3:\n+        remainder = safe_unicode(remainder)\n+    elif encoding is not None:\n+        remainder = safe_unicode(remainder, encoding)\n+    parts = remainder.split(\'!\')\n \n     if len(parts) == 2:\n         userid, user_data = parts\n@@ -254,8 +279,10 @@ def validateTicket(secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None,\n # doctest runner\n def _test():\n     import doctest\n+    from plone.session.tests.testDocTests import Py23DocChecker\n     doctest.testmod(\n-        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE\n+        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE,\n+        checker=Py23DocChecker(),\n     )\n \n \ndiff --git a/setup.py b/setup.py\nindex 063dd0e..6ce0210 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -21,6 +21,7 @@\n         \'License :: OSI Approved :: BSD License\',\n         \'Operating System :: OS Independent\',\n         \'Programming Language :: Python :: 2.7\',\n+        \'Programming Language :: Python :: 3.6\',\n         \'Programming Language :: Python\',\n         \'Topic :: System :: Systems Administration :: Authentication/Directory\',  # noqa\n     ],\n'

