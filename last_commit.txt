Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-05-15T20:00:14+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.vocabularies/commit/2fbf4b945948f177a27789d3ebb03f78cd9ff699

fix actions-vocabulary in py3

Files changed:
M plone/app/vocabularies/actions.py

b"diff --git a/plone/app/vocabularies/actions.py b/plone/app/vocabularies/actions.py\nindex a1533a1..c2b3f10 100644\n--- a/plone/app/vocabularies/actions.py\n+++ b/plone/app/vocabularies/actions.py\n@@ -20,9 +20,8 @@ def __call__(self, context):\n         except Exception:\n             portal = context.portal_url.getPortalObject()\n             categories = portal.portal_actions.objectIds()\n-        categories.sort()\n         return SimpleVocabulary(\n-            [SimpleTerm(cat, title=cat) for cat in categories]\n+            [SimpleTerm(cat, title=cat) for cat in sorted(categories)]\n         )\n \n \n@@ -36,9 +35,8 @@ class PortalActionCategoriesVocabulary(object):\n     def __call__(self, context):\n         portal_actions = getToolByName(context, 'portal_actions')\n         categories = portal_actions.objectIds()\n-        categories.sort()\n         terms = []\n-        for category in categories:\n+        for category in sorted(categories):\n             if category == 'controlpanel':\n                 continue\n             title = portal_actions.get(category).title\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-05-15T23:44:05+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.vocabularies/commit/a691e1679c41acd30aaa17a06a5a3915b095c787

fix WorkflowStatesVocabulary in py3

Files changed:
M plone/app/vocabularies/workflow.py

b"diff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex a9ecf0d..ed1b02c 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -1,5 +1,6 @@\n # -*- coding:utf-8 -*-\n from Acquisition import aq_get\n+from operator import itemgetter\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.utils import safe_unicode\n from zope.i18n import translate\n@@ -129,10 +130,9 @@ def __call__(self, context):\n             ]\n         )\n         items_list = [(k, v) for k, v in items_dict.items()]\n-        items_list.sort(lambda x, y: cmp(x[1], y[1]))\n         terms = [\n             SimpleTerm(k, title=u'{0} [{1}]'.format(v, k))\n-            for k, v in items_list\n+            for k, v in sorted(items_list, key=itemgetter(1))\n         ]\n         return SimpleVocabulary(terms)\n \n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-05-16T06:50:25+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.vocabularies/commit/e64a8dfba85a28fb6b1c98d130264e326cfd07e5

fix SyndicatableFeedItems vocabulary in py3

Files changed:
M plone/app/vocabularies/syndication.py

b"diff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex ebd48ae..161f267 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -9,6 +9,7 @@\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n+import six\n \n try:\n     # XXX: this is a circular dependency (not declared in setup.py)\n@@ -58,8 +59,11 @@ def __call__(self, context):\n         items = []\n         for brain in catalog(**query):\n             uid = brain.UID\n+            title = brain.Title\n+            if isinstance(title, six.binary_type):\n+                title = title.decode('utf8')\n             title = u'{0}({1})'.format(\n-                brain.Title.decode('utf8'),\n+                title,\n                 brain.getPath()[len(site_path) + 1:],\n             )\n             items.append(SimpleTerm(uid, uid, title))\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-05-23T14:20:17+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.vocabularies/commit/6ff32f199e55a0b86fd45ed385edd2cb9ec74808

fix QuerySearchableTextSourceView for py3

Files changed:
M plone/app/vocabularies/catalog.py

b"diff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex a934785..2d8bda9 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -354,8 +354,10 @@ def getTerm(self, value):\n             if brain.is_folderish:\n                 browse_token = value\n             parent_token = '/'.join(value.split('/')[:-1])\n+        if six.PY2 and isinstance(title, six.binary_type):\n+            title = title.decode(self.context.encoding)\n         return BrowsableTerm(value, token=token,\n-                             title=title.decode(self.context.encoding),\n+                             title=title,\n                              description=value,\n                              browse_token=browse_token,\n                              parent_token=parent_token)\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-05-25T11:10:50+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.vocabularies/commit/f223c1a292893180bf5266d52caab6d9305e1df1

start fixing tests in py3

Files changed:
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/tests/test_vocabularies.py
M plone/app/vocabularies/users.py
M plone/app/vocabularies/workflow.py

b'diff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex 2d8bda9..3c620a0 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -425,7 +425,7 @@ class KeywordsVocabulary(object):\n         >>> tool.indexes[\'Subject\'] = index\n         >>> vocab = KeywordsVocabulary()\n         >>> result = vocab(context)\n-        >>> result.by_token.keys()\n+        >>> list(result.by_token.keys())\n         [\'blee\', \'baz\', \'foo\', \'bar\', \'non-=C3=A5scii\']\n         >>> result.getTermByToken(\'non-=C3=A5scii\').title\n         u\'non-\\\\xe5scii\'\n@@ -440,7 +440,7 @@ class KeywordsVocabulary(object):\n         >>> tool.indexes[\'Subject\'] = index\n         >>> vocab = KeywordsVocabulary()\n         >>> result = vocab(context)\n-        >>> result.by_token.keys()\n+        >>> list(result.by_token.keys())\n         [\'nix\', \'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\']\n         >>> result.by_value.keys() == [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']\n         True\ndiff --git a/plone/app/vocabularies/tests/test_vocabularies.py b/plone/app/vocabularies/tests/test_vocabularies.py\nindex 782eefd..3b13a65 100644\n--- a/plone/app/vocabularies/tests/test_vocabularies.py\n+++ b/plone/app/vocabularies/tests/test_vocabularies.py\n@@ -6,6 +6,8 @@\n from zope.site import hooks\n \n import doctest\n+import re\n+import six\n import unittest\n import zope.component\n \n@@ -24,6 +26,15 @@ def vocabTearDown(self):\n     hooks.setSite()\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+\n+    def check_output(self, want, got, optionflags):\n+        if not six.PY2:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     optionflags = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n     return unittest.TestSuite(\n@@ -35,55 +46,64 @@ def test_suite():\n                 \'plone.app.vocabularies.catalog\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.datetimerelated\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.groups\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.language\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.security\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.skins\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.types\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.users\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.workflow\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n         )\n     )\ndiff --git a/plone/app/vocabularies/users.py b/plone/app/vocabularies/users.py\nindex d2e109e..a3e6db7 100644\n--- a/plone/app/vocabularies/users.py\n+++ b/plone/app/vocabularies/users.py\n@@ -152,11 +152,11 @@ class UsersFactory(object):\n     no user is returned to avoid expensive queries if no query filter is passed\n     >>> def patched_getUtility(arg):\n     ...     return {\'plone.many_users\': True}\n-    >>> backup = getUtility.func_code\n-    >>> getUtility.func_code = patched_getUtility.func_code\n+    >>> backup = getUtility.__code__\n+    >>> getUtility.__code__ = patched_getUtility.__code__\n     >>> [x.title for x in factory(context, \'\')]\n     []\n-    >>> getUtility.func_code = backup\n+    >>> getUtility.__code__ = backup\n \n     Passing a non empty query string will work ignore the \'plone.many_users\'\n     setting\ndiff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex ed1b02c..d7478c3 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -22,6 +22,7 @@ class WorkflowsVocabulary(object):\n       >>> from zope.component import queryUtility\n       >>> from plone.app.vocabularies.tests.base import create_context\n       >>> from plone.app.vocabularies.tests.base import DummyTool\n+      >>> import six\n \n       >>> name = \'plone.app.vocabularies.Workflows\'\n       >>> util = queryUtility(IVocabularyFactory, name)\n@@ -52,7 +53,9 @@ class WorkflowsVocabulary(object):\n       (u\'Intranet Workflow\', \'intranet\', \'intranet\')\n \n       >>> noticias = workflows.by_token[\'noticias\']\n-      >>> noticias.title == \'Workflow de Not\xc3\xadcias\'.decode(\'utf-8\')\n+      >>> title = \'Workflow de Not\xc3\xadcias\'\n+      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n+      >>> noticias.title == title\n       True\n     """\n \n@@ -80,6 +83,7 @@ class WorkflowStatesVocabulary(object):\n       >>> from zope.component import queryUtility\n       >>> from plone.app.vocabularies.tests.base import create_context\n       >>> from plone.app.vocabularies.tests.base import DummyTool\n+      >>> import six\n \n       >>> name = \'plone.app.vocabularies.WorkflowStates\'\n       >>> util = queryUtility(IVocabularyFactory, name)\n@@ -105,7 +109,9 @@ class WorkflowStatesVocabulary(object):\n       (u\'Published [published]\', \'published\', \'published\')\n \n       >>> rev = states.by_token[\'revisao\']\n-      >>> rev.title == \'Revis\xc3\xa3o [revisao]\'.decode(\'utf-8\')\n+      >>> title = \'Revis\xc3\xa3o [revisao]\'\n+      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n+      >>> rev.title == title\n       True\n     """\n \n@@ -227,8 +233,7 @@ def __call__(self, context):\n                         dict(title=transition_title, wf_name=wf_name))\n         items = []\n         transition_items = transitions.items()\n-        transition_items.sort(key=lambda transition: transition[0])\n-        for transition_id, info in transition_items:\n+        for transition_id, info in sorted(transition_items, key=itemgetter(0)):\n             titles = set([i[\'title\'] for i in info])\n             item_title = \' // \'.join(sorted(titles))\n             item_title = u\'{0} [{1}]\'.format(item_title, transition_id)\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-06-10T14:52:35+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.app.vocabularies/commit/72188d1b41831ab2a87448d01094a1851866a5ca

Fix tests for Python 3

Files changed:
M plone/app/vocabularies/catalog.py

b'diff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex 3c620a0..dd06b54 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -67,25 +67,30 @@ def parse_query(query, path_prefix=\'\'):\n         then all contents of that folder will be searched. If you supply\n         additional search words, then all subfolders are searched as well.\n \n-        >>> parse_query(\'path:/dummy\')\n-        {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n+        >>> expected = {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n+        >>> parse_query(\'path:/dummy\') == expected\n+        True\n \n-        >>> parse_query(\'bar path:/dummy\')\n-        {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n+        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n+        >>> parse_query(\'bar path:/dummy\') == expected\n+        True\n \n-        >>> parse_query(\'path:/dummy foo\')\n-        {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n+        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n+        >>> parse_query(\'path:/dummy foo\') == expected\n+        True\n \n         If you supply more then one path, then only the last one is used.\n \n-        >>> parse_query(\'path:/dummy path:/spam\')\n-        {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n+        >>> expected = {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n+        >>> parse_query(\'path:/dummy path:/spam\') == expected\n+        True\n \n         You can also provide a prefix for the path. This is useful for virtual\n         hosting.\n \n-        >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\')\n-        {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n+        >>> expected = {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n+        >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\') == expected\n+        True\n \n     """\n     query_parts = query.split()\n@@ -310,14 +315,14 @@ class QuerySearchableTextSourceView(object):\n \n       >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n       >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> list(view.results(\'t\'))\n-      [\'\', \'/1234\', \'\']\n+      >>> sorted(view.results(\'t\'))\n+      [\'\', \'\', \'/1234\']\n \n       >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\',\n       ...                         \'t.browse.foo\' : \'/foo\'})\n       >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> list(view.results(\'t\'))\n-      [\'foo\', \'\', \'/1234\', \'\']\n+      >>> sorted(view.results(\'t\'))\n+      [\'\', \'\', \'/1234\', \'foo\']\n \n       Titles need to be unicode:\n       >>> view.getTerm(list(view.results(\'t\'))[0]).title\n@@ -407,28 +412,41 @@ class KeywordsVocabulary(object):\n \n         >>> context = create_context()\n \n+        First test bytes vocabularies\n         >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n         >>> tool = DummyCatalog(rids)\n         >>> context.portal_catalog = tool\n         >>> index = KeywordIndex(\'Subject\')\n         >>> done = index._index_object(\n         ...     1,\n-        ...     DummyContent(\'ob1\', [\'foo\', \'bar\', \'baz\']), attr=\'Subject\'\n+        ...     DummyContent(\'ob1\', [b\'foo\', b\'bar\', b\'baz\']), attr=\'Subject\'\n         ... )\n         >>> done = index._index_object(\n         ...     2,\n         ...     DummyContent(\n         ...         \'ob2\',\n-        ...         [\'blee\', \'bar\', \'non-\\xc3\\xa5scii\']),\n+        ...         [b\'blee\', b\'bar\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]),\n         ...         attr=\'Subject\',\n         ... )\n         >>> tool.indexes[\'Subject\'] = index\n         >>> vocab = KeywordsVocabulary()\n         >>> result = vocab(context)\n-        >>> list(result.by_token.keys())\n-        [\'blee\', \'baz\', \'foo\', \'bar\', \'non-=C3=A5scii\']\n-        >>> result.getTermByToken(\'non-=C3=A5scii\').title\n-        u\'non-\\\\xe5scii\'\n+\n+        Value type is kept ...\n+        >>> expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]\n+        >>> sorted(result.by_value) == expected\n+        True\n+\n+        ... but tokens are bytes on Python 2 and text in Python 3\n+        >>> if six.PY2:\n+        ...     expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', b\'non-=C3=83=C2=A5scii\']\n+        ... else:\n+        ...     expected = [u\'bar\', u\'baz\', u\'blee\', u\'foo\', u\'non-=C3=A5scii\']\n+        >>> sorted(result.by_token) == expected\n+        True\n+\n+        >>> result.getTermByToken(expected[-1]).title == u\'non-\xc3\xa5scii\'\n+        True\n \n         Testing unicode vocabularies\n         First clear the index. Comparing non-six.text_type to six.text_type objects fails.\n@@ -440,17 +458,16 @@ class KeywordsVocabulary(object):\n         >>> tool.indexes[\'Subject\'] = index\n         >>> vocab = KeywordsVocabulary()\n         >>> result = vocab(context)\n-        >>> list(result.by_token.keys())\n-        [\'nix\', \'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\']\n-        >>> result.by_value.keys() == [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']\n+        >>> if six.PY2:\n+        ...     expected = [b\'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\', b\'nix\']\n+        ... else:\n+        ...     expected = [u\'=C3=A4=C3=BC=C3=B6\', u\'nix\']\n+        >>> sorted(result.by_token) == expected\n         True\n-        >>> test_title = result.getTermByToken(\n-        ...     \'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\'\n-        ... ).title\n-        >>> test_title == u\'\xc3\xa4\xc3\xbc\xc3\xb6\'\n+        >>> set(result.by_value) == {u\'nix\', u\'\xc3\xa4\xc3\xbc\xc3\xb6\'}\n+        True\n+        >>> result.getTermByToken(expected[0]).title == u\'\xc3\xa4\xc3\xbc\xc3\xb6\'\n         True\n-\n-\n \n     """\n     # Allow users to customize the index to easily create\n@@ -599,8 +616,8 @@ class CatalogVocabularyFactory(object):\n       >>> context.portal_url = DummyUrlTool(context)\n       >>> factory = CatalogVocabularyFactory()\n \n-      >>> [t.token for t in factory(context)]\n-      [\'/dummy/sub-site\', \'/abcd\', \'/dummy/sub-site/ghij\', \'/defg\']\n+      >>> sorted(t.token for t in factory(context))\n+      [\'/abcd\', \'/defg\', \'/dummy/sub-site\', \'/dummy/sub-site/ghij\']\n \n       >>> from plone.app.vocabularies.tests.base import DummyNavRoot\n       >>> nav_root = DummyNavRoot(\'sub-site\', parent=context)\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-06-10T14:52:54+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.app.vocabularies/commit/cb245fe8d4e0a916385bf0316b17d981e59095a4

Changelog

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 0068869..60f925f 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,7 +14,7 @@ New features:\n \n Bug fixes:\n \n-- *add item here*\n+- Python 3 support [ale-rt, pbauer]\n \n \n 4.0.6 (2018-02-11)\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-08-17T10:39:54+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/7a71c3ad63fe3a3d24153bbf9f7d9ff70230b7ff

update troove classifier

Files changed:
M setup.py

b"diff --git a/setup.py b/setup.py\nindex fede8ac..6a09ed9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -23,6 +23,7 @@\n         'Operating System :: OS Independent',\n         'Programming Language :: Python',\n         'Programming Language :: Python :: 2.7',\n+        'Programming Language :: Python :: 3.6',\n     ],\n     keywords='Plone Zope vocabularies',\n     author='Plone Foundation',\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2018-08-17T10:40:28+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/1b34f04b245aa3b505d9351e351494196e7c42a5

Merge pull request #54 from plone/python3

Python 3 support

Files changed:
M CHANGES.rst
M plone/app/vocabularies/actions.py
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/syndication.py
M plone/app/vocabularies/tests/test_vocabularies.py
M plone/app/vocabularies/users.py
M plone/app/vocabularies/workflow.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 0068869..60f925f 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,7 +14,7 @@ New features:\n \n Bug fixes:\n \n-- *add item here*\n+- Python 3 support [ale-rt, pbauer]\n \n \n 4.0.6 (2018-02-11)\ndiff --git a/plone/app/vocabularies/actions.py b/plone/app/vocabularies/actions.py\nindex a1533a1..c2b3f10 100644\n--- a/plone/app/vocabularies/actions.py\n+++ b/plone/app/vocabularies/actions.py\n@@ -20,9 +20,8 @@ def __call__(self, context):\n         except Exception:\n             portal = context.portal_url.getPortalObject()\n             categories = portal.portal_actions.objectIds()\n-        categories.sort()\n         return SimpleVocabulary(\n-            [SimpleTerm(cat, title=cat) for cat in categories]\n+            [SimpleTerm(cat, title=cat) for cat in sorted(categories)]\n         )\n \n \n@@ -36,9 +35,8 @@ class PortalActionCategoriesVocabulary(object):\n     def __call__(self, context):\n         portal_actions = getToolByName(context, \'portal_actions\')\n         categories = portal_actions.objectIds()\n-        categories.sort()\n         terms = []\n-        for category in categories:\n+        for category in sorted(categories):\n             if category == \'controlpanel\':\n                 continue\n             title = portal_actions.get(category).title\ndiff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex a934785..dd06b54 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -67,25 +67,30 @@ def parse_query(query, path_prefix=\'\'):\n         then all contents of that folder will be searched. If you supply\n         additional search words, then all subfolders are searched as well.\n \n-        >>> parse_query(\'path:/dummy\')\n-        {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n+        >>> expected = {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n+        >>> parse_query(\'path:/dummy\') == expected\n+        True\n \n-        >>> parse_query(\'bar path:/dummy\')\n-        {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n+        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n+        >>> parse_query(\'bar path:/dummy\') == expected\n+        True\n \n-        >>> parse_query(\'path:/dummy foo\')\n-        {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n+        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n+        >>> parse_query(\'path:/dummy foo\') == expected\n+        True\n \n         If you supply more then one path, then only the last one is used.\n \n-        >>> parse_query(\'path:/dummy path:/spam\')\n-        {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n+        >>> expected = {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n+        >>> parse_query(\'path:/dummy path:/spam\') == expected\n+        True\n \n         You can also provide a prefix for the path. This is useful for virtual\n         hosting.\n \n-        >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\')\n-        {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n+        >>> expected = {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n+        >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\') == expected\n+        True\n \n     """\n     query_parts = query.split()\n@@ -310,14 +315,14 @@ class QuerySearchableTextSourceView(object):\n \n       >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n       >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> list(view.results(\'t\'))\n-      [\'\', \'/1234\', \'\']\n+      >>> sorted(view.results(\'t\'))\n+      [\'\', \'\', \'/1234\']\n \n       >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\',\n       ...                         \'t.browse.foo\' : \'/foo\'})\n       >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> list(view.results(\'t\'))\n-      [\'foo\', \'\', \'/1234\', \'\']\n+      >>> sorted(view.results(\'t\'))\n+      [\'\', \'\', \'/1234\', \'foo\']\n \n       Titles need to be unicode:\n       >>> view.getTerm(list(view.results(\'t\'))[0]).title\n@@ -354,8 +359,10 @@ def getTerm(self, value):\n             if brain.is_folderish:\n                 browse_token = value\n             parent_token = \'/\'.join(value.split(\'/\')[:-1])\n+        if six.PY2 and isinstance(title, six.binary_type):\n+            title = title.decode(self.context.encoding)\n         return BrowsableTerm(value, token=token,\n-                             title=title.decode(self.context.encoding),\n+                             title=title,\n                              description=value,\n                              browse_token=browse_token,\n                              parent_token=parent_token)\n@@ -405,28 +412,41 @@ class KeywordsVocabulary(object):\n \n         >>> context = create_context()\n \n+        First test bytes vocabularies\n         >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n         >>> tool = DummyCatalog(rids)\n         >>> context.portal_catalog = tool\n         >>> index = KeywordIndex(\'Subject\')\n         >>> done = index._index_object(\n         ...     1,\n-        ...     DummyContent(\'ob1\', [\'foo\', \'bar\', \'baz\']), attr=\'Subject\'\n+        ...     DummyContent(\'ob1\', [b\'foo\', b\'bar\', b\'baz\']), attr=\'Subject\'\n         ... )\n         >>> done = index._index_object(\n         ...     2,\n         ...     DummyContent(\n         ...         \'ob2\',\n-        ...         [\'blee\', \'bar\', \'non-\\xc3\\xa5scii\']),\n+        ...         [b\'blee\', b\'bar\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]),\n         ...         attr=\'Subject\',\n         ... )\n         >>> tool.indexes[\'Subject\'] = index\n         >>> vocab = KeywordsVocabulary()\n         >>> result = vocab(context)\n-        >>> result.by_token.keys()\n-        [\'blee\', \'baz\', \'foo\', \'bar\', \'non-=C3=A5scii\']\n-        >>> result.getTermByToken(\'non-=C3=A5scii\').title\n-        u\'non-\\\\xe5scii\'\n+\n+        Value type is kept ...\n+        >>> expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]\n+        >>> sorted(result.by_value) == expected\n+        True\n+\n+        ... but tokens are bytes on Python 2 and text in Python 3\n+        >>> if six.PY2:\n+        ...     expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', b\'non-=C3=83=C2=A5scii\']\n+        ... else:\n+        ...     expected = [u\'bar\', u\'baz\', u\'blee\', u\'foo\', u\'non-=C3=A5scii\']\n+        >>> sorted(result.by_token) == expected\n+        True\n+\n+        >>> result.getTermByToken(expected[-1]).title == u\'non-\xc3\xa5scii\'\n+        True\n \n         Testing unicode vocabularies\n         First clear the index. Comparing non-six.text_type to six.text_type objects fails.\n@@ -438,17 +458,16 @@ class KeywordsVocabulary(object):\n         >>> tool.indexes[\'Subject\'] = index\n         >>> vocab = KeywordsVocabulary()\n         >>> result = vocab(context)\n-        >>> result.by_token.keys()\n-        [\'nix\', \'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\']\n-        >>> result.by_value.keys() == [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']\n+        >>> if six.PY2:\n+        ...     expected = [b\'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\', b\'nix\']\n+        ... else:\n+        ...     expected = [u\'=C3=A4=C3=BC=C3=B6\', u\'nix\']\n+        >>> sorted(result.by_token) == expected\n         True\n-        >>> test_title = result.getTermByToken(\n-        ...     \'=C3=83=C2=A4=C3=83=C2=BC=C3=83=C2=B6\'\n-        ... ).title\n-        >>> test_title == u\'\xc3\xa4\xc3\xbc\xc3\xb6\'\n+        >>> set(result.by_value) == {u\'nix\', u\'\xc3\xa4\xc3\xbc\xc3\xb6\'}\n+        True\n+        >>> result.getTermByToken(expected[0]).title == u\'\xc3\xa4\xc3\xbc\xc3\xb6\'\n         True\n-\n-\n \n     """\n     # Allow users to customize the index to easily create\n@@ -597,8 +616,8 @@ class CatalogVocabularyFactory(object):\n       >>> context.portal_url = DummyUrlTool(context)\n       >>> factory = CatalogVocabularyFactory()\n \n-      >>> [t.token for t in factory(context)]\n-      [\'/dummy/sub-site\', \'/abcd\', \'/dummy/sub-site/ghij\', \'/defg\']\n+      >>> sorted(t.token for t in factory(context))\n+      [\'/abcd\', \'/defg\', \'/dummy/sub-site\', \'/dummy/sub-site/ghij\']\n \n       >>> from plone.app.vocabularies.tests.base import DummyNavRoot\n       >>> nav_root = DummyNavRoot(\'sub-site\', parent=context)\ndiff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex ebd48ae..161f267 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -9,6 +9,7 @@\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n+import six\n \n try:\n     # XXX: this is a circular dependency (not declared in setup.py)\n@@ -58,8 +59,11 @@ def __call__(self, context):\n         items = []\n         for brain in catalog(**query):\n             uid = brain.UID\n+            title = brain.Title\n+            if isinstance(title, six.binary_type):\n+                title = title.decode(\'utf8\')\n             title = u\'{0}({1})\'.format(\n-                brain.Title.decode(\'utf8\'),\n+                title,\n                 brain.getPath()[len(site_path) + 1:],\n             )\n             items.append(SimpleTerm(uid, uid, title))\ndiff --git a/plone/app/vocabularies/tests/test_vocabularies.py b/plone/app/vocabularies/tests/test_vocabularies.py\nindex 782eefd..3b13a65 100644\n--- a/plone/app/vocabularies/tests/test_vocabularies.py\n+++ b/plone/app/vocabularies/tests/test_vocabularies.py\n@@ -6,6 +6,8 @@\n from zope.site import hooks\n \n import doctest\n+import re\n+import six\n import unittest\n import zope.component\n \n@@ -24,6 +26,15 @@ def vocabTearDown(self):\n     hooks.setSite()\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+\n+    def check_output(self, want, got, optionflags):\n+        if not six.PY2:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     optionflags = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n     return unittest.TestSuite(\n@@ -35,55 +46,64 @@ def test_suite():\n                 \'plone.app.vocabularies.catalog\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.datetimerelated\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.groups\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.language\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.security\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.skins\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.types\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.users\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n                 \'plone.app.vocabularies.workflow\',\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n-                optionflags=optionflags\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n             ),\n         )\n     )\ndiff --git a/plone/app/vocabularies/users.py b/plone/app/vocabularies/users.py\nindex d2e109e..a3e6db7 100644\n--- a/plone/app/vocabularies/users.py\n+++ b/plone/app/vocabularies/users.py\n@@ -152,11 +152,11 @@ class UsersFactory(object):\n     no user is returned to avoid expensive queries if no query filter is passed\n     >>> def patched_getUtility(arg):\n     ...     return {\'plone.many_users\': True}\n-    >>> backup = getUtility.func_code\n-    >>> getUtility.func_code = patched_getUtility.func_code\n+    >>> backup = getUtility.__code__\n+    >>> getUtility.__code__ = patched_getUtility.__code__\n     >>> [x.title for x in factory(context, \'\')]\n     []\n-    >>> getUtility.func_code = backup\n+    >>> getUtility.__code__ = backup\n \n     Passing a non empty query string will work ignore the \'plone.many_users\'\n     setting\ndiff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex a9ecf0d..d7478c3 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -1,5 +1,6 @@\n # -*- coding:utf-8 -*-\n from Acquisition import aq_get\n+from operator import itemgetter\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.utils import safe_unicode\n from zope.i18n import translate\n@@ -21,6 +22,7 @@ class WorkflowsVocabulary(object):\n       >>> from zope.component import queryUtility\n       >>> from plone.app.vocabularies.tests.base import create_context\n       >>> from plone.app.vocabularies.tests.base import DummyTool\n+      >>> import six\n \n       >>> name = \'plone.app.vocabularies.Workflows\'\n       >>> util = queryUtility(IVocabularyFactory, name)\n@@ -51,7 +53,9 @@ class WorkflowsVocabulary(object):\n       (u\'Intranet Workflow\', \'intranet\', \'intranet\')\n \n       >>> noticias = workflows.by_token[\'noticias\']\n-      >>> noticias.title == \'Workflow de Not\xc3\xadcias\'.decode(\'utf-8\')\n+      >>> title = \'Workflow de Not\xc3\xadcias\'\n+      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n+      >>> noticias.title == title\n       True\n     """\n \n@@ -79,6 +83,7 @@ class WorkflowStatesVocabulary(object):\n       >>> from zope.component import queryUtility\n       >>> from plone.app.vocabularies.tests.base import create_context\n       >>> from plone.app.vocabularies.tests.base import DummyTool\n+      >>> import six\n \n       >>> name = \'plone.app.vocabularies.WorkflowStates\'\n       >>> util = queryUtility(IVocabularyFactory, name)\n@@ -104,7 +109,9 @@ class WorkflowStatesVocabulary(object):\n       (u\'Published [published]\', \'published\', \'published\')\n \n       >>> rev = states.by_token[\'revisao\']\n-      >>> rev.title == \'Revis\xc3\xa3o [revisao]\'.decode(\'utf-8\')\n+      >>> title = \'Revis\xc3\xa3o [revisao]\'\n+      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n+      >>> rev.title == title\n       True\n     """\n \n@@ -129,10 +136,9 @@ def __call__(self, context):\n             ]\n         )\n         items_list = [(k, v) for k, v in items_dict.items()]\n-        items_list.sort(lambda x, y: cmp(x[1], y[1]))\n         terms = [\n             SimpleTerm(k, title=u\'{0} [{1}]\'.format(v, k))\n-            for k, v in items_list\n+            for k, v in sorted(items_list, key=itemgetter(1))\n         ]\n         return SimpleVocabulary(terms)\n \n@@ -227,8 +233,7 @@ def __call__(self, context):\n                         dict(title=transition_title, wf_name=wf_name))\n         items = []\n         transition_items = transitions.items()\n-        transition_items.sort(key=lambda transition: transition[0])\n-        for transition_id, info in transition_items:\n+        for transition_id, info in sorted(transition_items, key=itemgetter(0)):\n             titles = set([i[\'title\'] for i in info])\n             item_title = \' // \'.join(sorted(titles))\n             item_title = u\'{0} [{1}]\'.format(item_title, transition_id)\ndiff --git a/setup.py b/setup.py\nindex fede8ac..6a09ed9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -23,6 +23,7 @@\n         \'Operating System :: OS Independent\',\n         \'Programming Language :: Python\',\n         \'Programming Language :: Python :: 2.7\',\n+        \'Programming Language :: Python :: 3.6\',\n     ],\n     keywords=\'Plone Zope vocabularies\',\n     author=\'Plone Foundation\',\n'

