Repository: plone.tiles


Branch: refs/heads/master
Date: 2018-11-04T00:18:08+09:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.tiles/commit/d794c35b24da8a8e231c1b514ff73331fb7f7740

start migrating to python3

Files changed:
M plone/tiles/absoluteurl.py
M plone/tiles/data.py
M plone/tiles/data.rst
M plone/tiles/directives.rst
M plone/tiles/esi.rst
M plone/tiles/tests/test_doctests.py
M plone/tiles/tiles.rst

b'diff --git a/plone/tiles/absoluteurl.py b/plone/tiles/absoluteurl.py\nindex 9fe4776..826ad5f 100644\n--- a/plone/tiles/absoluteurl.py\n+++ b/plone/tiles/absoluteurl.py\n@@ -8,7 +8,7 @@\n from zope.traversing.browser.absoluteurl import AbsoluteURL\n from zope.traversing.browser.interfaces import IAbsoluteURL\n \n-import urllib\n+import six.moves.urllib.request, six.moves.urllib.parse, six.moves.urllib.error\n \n \n _safe = \'@+\'\n@@ -29,9 +29,9 @@ def __str__(self):\n         if name is None or context is None:\n             raise TypeError(\'Insufficient context to determine URL\')\n \n-        tileFragment = \'@@\' + urllib.quote(name.encode(\'utf-8\'), _safe)\n+        tileFragment = \'@@\' + six.moves.urllib.parse.quote(name.encode(\'utf-8\'), _safe)\n         if tid:\n-            tileFragment += \'/\' + urllib.quote(tid.encode(\'utf-8\'), _safe)\n+            tileFragment += \'/\' + six.moves.urllib.parse.quote(tid.encode(\'utf-8\'), _safe)\n \n         absolute_url = getMultiAdapter((context, request), IAbsoluteURL)\n         try:\n@@ -49,9 +49,9 @@ def breadcrumbs(self):\n         name = tile.__name__\n         context = tile.__parent__\n \n-        tileFragment = \'@@\' + urllib.quote(name.encode(\'utf-8\'), _safe)\n+        tileFragment = \'@@\' + six.moves.urllib.parse.quote(name.encode(\'utf-8\'), _safe)\n         if tid:\n-            tileFragment += \'/\' + urllib.quote(tid.encode(\'utf-8\'), _safe)\n+            tileFragment += \'/\' + six.moves.urllib.parse.quote(tid.encode(\'utf-8\'), _safe)\n \n         base = tuple(\n             getMultiAdapter((context, request), IAbsoluteURL).breadcrumbs())\ndiff --git a/plone/tiles/data.py b/plone/tiles/data.py\nindex 1def88a..1fc12d0 100644\n--- a/plone/tiles/data.py\n+++ b/plone/tiles/data.py\n@@ -23,7 +23,10 @@\n import json\n import logging\n import pkg_resources\n-import urllib\n+import six.moves.urllib.request\n+import six.moves.urllib.parse\n+import six.moves.urllib.error\n+import six\n \n \n try:\n@@ -223,7 +226,7 @@ def guess_type(v):\n         return \'\'\n \n     for item_name, item_value in value.items():\n-        if isinstance(item_value, unicode):\n+        if isinstance(item_value, six.text_type):\n             item_value = item_value.encode(\'utf-8\')\n \n         if isinstance(item_value, list) or isinstance(item_value, tuple):\n@@ -231,7 +234,7 @@ def guess_type(v):\n                 marshall_type = guess_type(item_subvalue)\n                 if isinstance(item_subvalue, bool):\n                     item_subvalue = item_subvalue and \'1\' or \'\'\n-                elif isinstance(item_subvalue, unicode):\n+                elif isinstance(item_subvalue, six.text_type):\n                     item_subvalue = item_subvalue.encode(\'utf-8\')\n                 encoded_name = \'{0}.{1}{2}:list:{3}\'.format(\n                     prefix,\n@@ -244,7 +247,7 @@ def guess_type(v):\n             marshall_type = guess_type(item_value)\n             if isinstance(item_value, bool):\n                 item_value = item_value and \'1\' or \'\'\n-            elif isinstance(item_value, unicode):\n+            elif isinstance(item_value, six.text_type):\n                 item_value = item_value.encode(\'utf-8\')\n             encoded_name = \'{0:s}.{1:s}{2:s}:{3:s}\'.format(\n                 prefix,\n@@ -291,7 +294,7 @@ def encode(data, schema, ignore=()):\n         value = data[name]\n         if value is None:\n             continue\n-        elif isinstance(value, unicode):\n+        elif isinstance(value, six.text_type):\n             value = value.encode(\'utf-8\')\n \n         if ISequence.providedBy(field):\n@@ -317,7 +320,7 @@ def encode(data, schema, ignore=()):\n \n                 if isinstance(item, bool):\n                     item = item and \'1\' or \'\'\n-                elif isinstance(item, unicode):\n+                elif isinstance(item, six.text_type):\n                     item = item.encode(\'utf-8\')\n \n                 if isinstance(item, dict):\n@@ -336,7 +339,7 @@ def encode(data, schema, ignore=()):\n             else:\n                 encode.append((encoded_name, value))\n \n-    return urllib.urlencode(encode)\n+    return six.moves.urllib.parse.urlencode(encode)\n \n \n # Decoding\n@@ -390,8 +393,8 @@ def decode(data, schema, missing=True):\n         elif isinstance(value, (tuple, list)) and value:\n             value = value[0]\n \n-        if isinstance(value, str):\n-            value = unicode(value, \'utf-8\')\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(\'utf-8\')\n \n         if field._type is not None and not isinstance(value, field._type):\n             value = field_type(value)\ndiff --git a/plone/tiles/data.rst b/plone/tiles/data.rst\nindex 78f3ecc..d9fb8b4 100644\n--- a/plone/tiles/data.rst\n+++ b/plone/tiles/data.rst\n@@ -112,12 +112,12 @@ This also applies to the value_type of a list or tuple:\n     >>> encode(data, IUnsupported) # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n     ...\n-    ComponentLookupError: Cannot URL encode decimal of type <class \'zope.schema._field.Decimal\'>\n+    zope.interface.interfaces.ComponentLookupError: Cannot URL encode decimal of type <class \'zope.schema._field.Decimal\'>\n \n     >>> encode(data, IUnsupported, ignore=(\'decimal\',)) # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n     ...\n-    ComponentLookupError: Cannot URL encode value type for list of type <class \'zope.schema._field.List\'> : <class \'zope.schema._field.Decimal\'>\n+    zope.interface.interfaces.ComponentLookupError: Cannot URL encode value type for list of type <class \'zope.schema._field.List\'> : <class \'zope.schema._field.Decimal\'>\n \n     >>> encode(data, IUnsupported, ignore=(\'decimal\', \'list\',))\n     \'bytes_line=abc\'\n@@ -135,7 +135,7 @@ Let\'s use a data dictionary that may have come back from a query string like the\n \n     >>> data = dict(text_line=u\'A\', ascii_line=u\'B\', text=u\'C\\nD\', ascii=u\'E\\nF\', int=3, float=1.2, bool=False, weekday=u\'Saturday\')\n     >>> sorted(decode(data, ISimple).items())\n-    [(\'ascii\', \'E\\nF\'), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', u\'C\\nD\'), (\'text_line\', u\'A\'), (\'weekday\', u\'Saturday\')]\n+    [(\'ascii\', \'E\\nF\'), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', \'C\\nD\'), (\'text_line\', \'A\'), (\'weekday\', \'Saturday\')]\n \n If any values are missing from the input dictionary,\n they will default to ``missing_value``.\n@@ -144,7 +144,7 @@ they will default to ``missing_value``.\n \n     >>> data = dict(text_line=u\'A\', ascii_line=u\'B\', int=3, float=1.2, bool=False, weekday=u\'Saturday\')\n     >>> sorted(decode(data, ISimple).items())\n-    [(\'ascii\', None), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', u\'Missing\'), (\'text_line\', u\'A\'), (\'weekday\', u\'Saturday\')]\n+    [(\'ascii\', None), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', \'Missing\'), (\'text_line\', \'A\'), (\'weekday\', \'Saturday\')]\n \n If you pass ``missing=False``, the values are ignored instead.\n \n@@ -152,7 +152,7 @@ If you pass ``missing=False``, the values are ignored instead.\n \n     >>> data = dict(text_line=u\'A\', ascii_line=u\'B\', int=3, float=1.2, bool=False)\n     >>> sorted(decode(data, ISimple, missing=False).items())\n-    [(\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'text_line\', u\'A\')]\n+    [(\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'text_line\', \'A\')]\n \n Decoding also works for lists and their value types:\n \n@@ -168,7 +168,7 @@ Decoding should work with lists and the ISimple schema\n \n     >>> data = dict(list=[\'a\', \'b\'])\n     >>> sorted(decode(data, ISimple, missing=False).items())\n-    [(\'list\', [u\'a\', u\'b\'])]\n+    [(\'list\', [\'a\', \'b\'])]\n \n And list choice fields\n \ndiff --git a/plone/tiles/directives.rst b/plone/tiles/directives.rst\nindex e8f7ed3..5e27fd6 100644\n--- a/plone/tiles/directives.rst\n+++ b/plone/tiles/directives.rst\n@@ -103,7 +103,7 @@ Let\'s show how these may be used by registering several tiles:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -118,7 +118,7 @@ Let\'s check how the tiles were registered:\n     >>> tile1_type\n     <TileType dummy1 (Dummy tile 1)>\n     >>> tile1_type.description\n-    u\'This one shows all available options\'\n+    \'This one shows all available options\'\n \n     >>> tile1_type.add_permission\n     \'plone.tiles.testing.DummyAdd\'\n@@ -164,12 +164,13 @@ Finally, let\'s check that we can look up the tiles:\n .. code-block:: python\n \n     >>> from zope.publisher.browser import TestRequest\n-    >>> from zope.interface import implements, alsoProvides\n+    >>> from zope.interface import implementer, alsoProvides\n \n     >>> from plone.tiles.testing import IDummyContext, IDummyLayer\n \n-    >>> class Context(object):\n-    ...     implements(IDummyContext)\n+    >>> @implementer(IDummyContext)\n+    ... class Context(object):\n+    ...     pass\n \n     >>> context = Context()\n     >>> request = TestRequest()\n@@ -182,7 +183,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile1 = getMultiAdapter((context, layer_request), name=\'dummy1\')\n     >>> isinstance(tile1, DummyTileWithTemplate)\n     True\n-    >>> print tile1()\n+    >>> print(tile1())\n     <b>test!</b>\n     >>> tile1.__name__\n     \'dummy1\'\n@@ -190,7 +191,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile2 = getMultiAdapter((context, request), name=\'dummy2\')\n     >>> isinstance(tile2, DummyTile)\n     True\n-    >>> print tile2()\n+    >>> print(tile2())\n     dummy\n     >>> tile2.__name__\n     \'dummy2\'\n@@ -198,7 +199,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile3 = getMultiAdapter((context, request), name=\'dummy3\')\n     >>> isinstance(tile3, Tile)\n     True\n-    >>> print tile3()\n+    >>> print(tile3())\n     <b>test!</b>\n     >>> tile3.__name__\n     \'dummy3\'\n@@ -206,7 +207,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile4 = getMultiAdapter((context, request), name=\'dummy4\')\n     >>> isinstance(tile4, PersistentTile)\n     True\n-    >>> print tile4()\n+    >>> print(tile4())\n     <b>test!</b>\n     >>> tile4.__name__\n     \'dummy4\'\n@@ -214,7 +215,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile3_layer = getMultiAdapter((context, layer_request), name=\'dummy3\')\n     >>> isinstance(tile3_layer, DummyTile)\n     True\n-    >>> print tile3_layer()\n+    >>> print(tile3_layer())\n     dummy\n     >>> tile3_layer.__name__\n     \'dummy3\'\ndiff --git a/plone/tiles/esi.rst b/plone/tiles/esi.rst\nindex f8ff303..ef95e48 100644\n--- a/plone/tiles/esi.rst\n+++ b/plone/tiles/esi.rst\n@@ -26,7 +26,7 @@ To use the package, you should first load its ZCML configuration.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -145,18 +145,18 @@ At this point, we can look up the ESI views:\n     >>> head()\n     Traceback (most recent call last):\n     ...\n-    Unauthorized: Unauthorized()\n+    zExceptions.unauthorized.Unauthorized: Unauthorized()\n \n But we can only render them when we have the required permissions:\n \n     >>> from AccessControl.SecurityManagement import newSecurityManager\n     >>> from AccessControl.User import UnrestrictedUser\n     >>> newSecurityManager(None, UnrestrictedUser(\'manager\', \'\', [\'Manager\'], []))\n-    >>> print head()\n+    >>> print(head())\n     <title>Title</title>\n \n     >>> body = getMultiAdapter((tile, request), name=\'esi-body\')\n-    >>> print body()\n+    >>> print(body())\n     <b>My tile</b>\n \n Tiles without heads or bodies\n@@ -186,7 +186,7 @@ We won\'t bother to register this for this test, instead just instantiating it di\n     True\n \n     >>> head = getMultiAdapter((tile, request), name=\'esi-head\')\n-    >>> print head()\n+    >>> print(head())\n     <title>Page title</title>\n \n Of course, the ESI body renderer would return the same thing,\n@@ -195,7 +195,7 @@ since it can\'t extract a specific body either:\n .. code-block:: python\n \n     >>> body = getMultiAdapter((tile, request), name=\'esi-body\')\n-    >>> print body()\n+    >>> print(body())\n     <title>Page title</title>\n \n In this case, we would likely end up with invalid HTML,\n@@ -272,7 +272,7 @@ By default, the tile renders as normal:\n \n .. code-block:: python\n \n-    >>> print tile()\n+    >>> print(tile())\n     <html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>\n \n However, if we opt into ESI rendering via a request header, we get a different view:\n@@ -281,7 +281,7 @@ However, if we opt into ESI rendering via a request header, we get a different v\n \n     >>> from plone.tiles.interfaces import ESI_HEADER_KEY\n     >>> request.environ[ESI_HEADER_KEY] = \'true\'\n-    >>> print tile() # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(tile()) # doctest: +NORMALIZE_WHITESPACE\n     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n     <html xmlns="http://www.w3.org/1999/xhtml">\n@@ -297,7 +297,7 @@ This can be transformed into a proper ESI tag with ``substituteESILinks()``:\n .. code-block:: python\n \n     >>> from plone.tiles.esi import substituteESILinks\n-    >>> print substituteESILinks(tile()) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(substituteESILinks(tile())) # doctest: +NORMALIZE_WHITESPACE\n     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n     <html xmlns:esi="http://www.edge-delivery.org/esi/1.0" xmlns="http://www.w3.org/1999/xhtml">\n@@ -313,7 +313,7 @@ This is done with a class variable \'head\'\n .. code-block:: python\n \n     >>> SampleESITile.head = True\n-    >>> print tile() # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(tile()) # doctest: +NORMALIZE_WHITESPACE\n     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n     <html xmlns="http://www.w3.org/1999/xhtml">\ndiff --git a/plone/tiles/tests/test_doctests.py b/plone/tiles/tests/test_doctests.py\nindex 2fa2378..17d8a58 100644\n--- a/plone/tiles/tests/test_doctests.py\n+++ b/plone/tiles/tests/test_doctests.py\n@@ -3,9 +3,24 @@\n from plone.tiles.testing import PLONE_TILES_INTEGRATION_TESTING\n \n import doctest\n+import re\n+import six\n import unittest\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub(\'zExceptions.NotFound\', \'NotFound\', want)\n+            want = re.sub(\'zope.interface.interfaces.ComponentLookupError\', \'ComponentLookupError\', want)\n+            want = re.sub(\'zope.testbrowser.browser.LinkNotFoundError\', \'LinkNotFoundError\', want)\n+            want = re.sub(\'AccessControl.unauthorized.Unauthorized\', \'Unauthorized\', want)\n+            want = re.sub(\'zope.interface.interfaces.ComponentLookupError\', \'ComponentLookupError\', want)\n+            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n+            # want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     return unittest.TestSuite((\n         layered(\n@@ -14,7 +29,8 @@ def test_suite():\n                 \'../directives.rst\',\n                 \'../data.rst\',\n                 \'../esi.rst\',\n-                optionflags=doctest.ELLIPSIS\n+                optionflags=doctest.ELLIPSIS,\n+                checker=Py23DocChecker(),\n             ),\n             layer=PLONE_TILES_INTEGRATION_TESTING\n         ),\ndiff --git a/plone/tiles/tiles.rst b/plone/tiles/tiles.rst\nindex 1686e60..f7c0b39 100644\n--- a/plone/tiles/tiles.rst\n+++ b/plone/tiles/tiles.rst\n@@ -37,7 +37,7 @@ To use the package, you should first load its ZCML configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -297,8 +297,8 @@ Therefore, there is a corresponding ``decode()`` method that may be used to ensu\n     >>> marshaled = {\'title\': u\'My tile\', \'count\': 5, \'cssClass\': u\'foo\'}\n \n     >>> from plone.tiles.data import decode\n-    >>> decode(marshaled, ISampleTileData)\n-    {\'count\': 5, \'cssClass\': \'foo\', \'title\': u\'My tile\'}\n+    >>> sorted(decode(marshaled, ISampleTileData).items())\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My tile\')]\n \n When saved into a layout, the tile link would now look like:\n \n@@ -318,7 +318,7 @@ Let\'s simulate traversal once more and see how the data is now available to the\n     >>> tile = tile[\'tile1\']\n \n     >>> sorted(tile.data.items())\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n Notice also how the data has been properly decoded according to the schema.\n \n@@ -338,7 +338,7 @@ this one will be used instead:\n     >>> tile = tile[\'tile1\']\n \n     >>> sorted(tile.data.items())\n-    [(u\'count\', 6), (u\'cssClass\', u\'bar\'), (u\'title\', u\'Your title\')]\n+    [(\'count\', 6), (\'cssClass\', \'bar\'), (\'title\', \'Your title\')]\n \n This way we can use transient tiles safely in contexts where the tile data can be confused with raw data coming from a form, e.g. in an edit form.\n \n@@ -367,7 +367,7 @@ We can also update the tile data:\n \n     >>> dataManager.set({\'count\': 1, \'cssClass\': \'bar\', \'title\': u\'Another title\'})\n     >>> sorted(dataManager.get().items())\n-    [(\'count\', 1), (\'cssClass\', \'bar\'), (\'title\', u\'Another title\')]\n+    [(\'count\', 1), (\'cssClass\', \'bar\'), (\'title\', \'Another title\')]\n \n The data can also be deleted:\n \n@@ -453,13 +453,13 @@ By default, there is no data, and the field\'s missing value will be used.\n     \'tile2\'\n \n     >>> tile()\n-    u\'<b>You said</b> Missing!\'\n+    \'<b>You said</b> Missing!\'\n \n At this point, there is nothing in the annotations for the type either:\n \n .. code-block:: python\n \n-    >>> dict(getattr(context, \'__annotations__\', {})).keys()\n+    >>> list(dict(getattr(context, \'__annotations__\', {})).keys())\n     []\n \n We can write data to the context\'s annotations using an ``ITileDataManager``:\n@@ -467,23 +467,23 @@ We can write data to the context\'s annotations using an ``ITileDataManager``:\n .. code-block:: python\n \n     >>> dataManager = ITileDataManager(tile)\n-    >>> dataManager.set({\'text\': u\'Hello!\'})\n+    >>> dataManager.set({\'text\': \'Hello!\'})\n \n This writes data to annotations:\n \n .. code-block:: python\n \n-    >>> dict(context.__annotations__).keys()\n-    [u\'plone.tiles.data.tile2\']\n+    >>> list(dict(context.__annotations__).keys())\n+    [\'plone.tiles.data.tile2\']\n     >>> context.__annotations__[u\'plone.tiles.data.tile2\']\n-    {\'text\': u\'Hello!\'}\n+    {\'text\': \'Hello!\'}\n \n We can get this from the data manager too, of course:\n \n .. code-block:: python\n \n     >>> dataManager.get()\n-    {\'text\': u\'Hello!\'}\n+    {\'text\': \'Hello!\'}\n \n Note that as with transient tiles,\n the ``data`` attribute is cached and will only be looked up once.\n@@ -495,10 +495,10 @@ If we now look up the tile again, we will get the new value:\n     >>> tile = getMultiAdapter((context, request), name=u\'sample.persistenttile\')\n     >>> tile = tile[\'tile2\']\n     >>> tile()\n-    u\'<b>You said</b> Hello!\'\n+    \'<b>You said</b> Hello!\'\n \n     >>> tile.data\n-    {\'text\': u\'Hello!\'}\n+    {\'text\': \'Hello!\'}\n \n We can also remove the annotation using the data manager:\n \n@@ -533,7 +533,7 @@ Yet, just adding the flag, doesn\'t create new persistent annotations on GET requ\n     <plone.tiles.data.PersistentTileDataManager object at ...>\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> list(IAnnotations(context).keys())\n     []\n@@ -546,13 +546,13 @@ That\'s because the data is persistent only once it\'s set:\n     >>> data.update({\'count\': 6})\n     >>> ITileDataManager(tile).set(data)\n     >>> list(IAnnotations(context).keys())\n-    [u\'plone.tiles.data...\']\n+    [\'plone.tiles.data...\']\n \n-    >>> sorted(IAnnotations(context).values()[0].items(), key=lambda x: x[0])\n-    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    >>> sorted(list(IAnnotations(context).values())[0].items(), key=lambda x: x[0])\n+    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n Without the persistent flag, fixed transient data would be returned:\n \n@@ -567,7 +567,7 @@ Without the persistent flag, fixed transient data would be returned:\n \n     >>> data = ITileDataManager(tile).get()\n     >>> sorted(data.items(), key=lambda x: x[0])\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n Finally, the persistent override could also be deleted:\n \n@@ -582,14 +582,14 @@ Finally, the persistent override could also be deleted:\n     <plone.tiles.data.PersistentTileDataManager object at ...>\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> ITileDataManager(tile).delete()\n     >>> list(IAnnotations(context).keys())\n     []\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> request = TestRequest(\n     ...     form={\'title\': u\'My title\', \'count\': 5, \'cssClass\': u\'foo\'},\n@@ -614,15 +614,15 @@ We\'ll achieve that with a dummy adapter:\n \n .. code-block:: python\n \n-    >>> from zope.interface import implements\n-    >>> from zope.component import adapts\n+    >>> from zope.interface import implementer\n+    >>> from zope.component import adapter\n \n     >>> from zope.traversing.browser.interfaces import IAbsoluteURL\n     >>> from zope.publisher.interfaces.http import IHTTPRequest\n \n-    >>> class DummyAbsoluteURL(object):\n-    ...     implements(IAbsoluteURL)\n-    ...     adapts(IContext, IHTTPRequest)\n+    >>> @implementer(IAbsoluteURL)\n+    ... @adapter(IContext, IHTTPRequest)\n+    ... class DummyAbsoluteURL(object):\n     ...\n     ...     def __init__(self, context, request):\n     ...         self.context = context\n@@ -769,7 +769,7 @@ Data should not contain unfiltered field:\n .. code-block:: python\n \n     >>> sorted(tile.data.items())\n-    [(\'filtered\', u\'safe\')]\n+    [(\'filtered\', \'safe\')]\n \n \n Rendering the tile should not include ignored query string:\n'

Repository: plone.tiles


Branch: refs/heads/master
Date: 2018-11-04T00:26:32+09:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.tiles/commit/8f293a05ea7c887c3bcb380a30e6b5ad7a0ac320

fix tests in py2

Files changed:
M plone/tiles/tests/test_doctests.py

b'diff --git a/plone/tiles/tests/test_doctests.py b/plone/tiles/tests/test_doctests.py\nindex 17d8a58..4dfac56 100644\n--- a/plone/tiles/tests/test_doctests.py\n+++ b/plone/tiles/tests/test_doctests.py\n@@ -11,13 +11,13 @@\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            want = re.sub(\'zExceptions.NotFound\', \'NotFound\', want)\n-            want = re.sub(\'zope.interface.interfaces.ComponentLookupError\', \'ComponentLookupError\', want)\n-            want = re.sub(\'zope.testbrowser.browser.LinkNotFoundError\', \'LinkNotFoundError\', want)\n-            want = re.sub(\'AccessControl.unauthorized.Unauthorized\', \'Unauthorized\', want)\n-            want = re.sub(\'zope.interface.interfaces.ComponentLookupError\', \'ComponentLookupError\', want)\n+            want = re.sub(\n+                \'zope.interface.interfaces.ComponentLookupError\',\n+                \'ComponentLookupError\',\n+                want)\n+            want = re.sub(\n+                \'zExceptions.unauthorized.Unauthorized\', \'Unauthorized\', want)\n             got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n-            # want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n'

Repository: plone.tiles


Branch: refs/heads/master
Date: 2018-11-04T00:36:14+09:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.tiles/commit/fbbf333d2ad61024dcda5f2ae7762eb756560c3a

add changenote and classifiers

Files changed:
M CHANGES.rst
M setup.py

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 3115f89..5a9fc57 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -4,7 +4,8 @@ Changelog\n 2.1.1 (unreleased)\n ------------------\n \n-- Nothing changed yet.\n+- Add support for Python 3.\n+  [pbauer]\n \n \n 2.1 (2018-07-05)\ndiff --git a/setup.py b/setup.py\nindex 07f20a4..5e78e72 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -27,6 +27,8 @@\n         'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',\n         'Programming Language :: Python',\n         'Programming Language :: Python :: 2.7',\n+        'Programming Language :: Python :: 3.6',\n+        'Programming Language :: Python :: 3.7',\n         'Topic :: Internet :: WWW/HTTP',\n         'Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n         'Topic :: Software Development :: Libraries :: Python Modules',\n"

Repository: plone.tiles


Branch: refs/heads/master
Date: 2018-11-04T15:59:51+09:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.tiles/commit/571fc91bc69052cbe260bc093d67169baba814cf

fix imports

Files changed:
M plone/tiles/absoluteurl.py
M plone/tiles/data.py

b"diff --git a/plone/tiles/absoluteurl.py b/plone/tiles/absoluteurl.py\nindex 826ad5f..efb4efb 100644\n--- a/plone/tiles/absoluteurl.py\n+++ b/plone/tiles/absoluteurl.py\n@@ -2,15 +2,13 @@\n from plone.tiles.data import encode\n from plone.tiles.interfaces import ITileDataManager\n from plone.tiles.interfaces import ITileType\n+from six.moves.urllib import parse\n from zope.annotation import IAnnotations\n from zope.component import getMultiAdapter\n from zope.component import queryUtility\n from zope.traversing.browser.absoluteurl import AbsoluteURL\n from zope.traversing.browser.interfaces import IAbsoluteURL\n \n-import six.moves.urllib.request, six.moves.urllib.parse, six.moves.urllib.error\n-\n-\n _safe = '@+'\n \n \n@@ -29,9 +27,9 @@ def __str__(self):\n         if name is None or context is None:\n             raise TypeError('Insufficient context to determine URL')\n \n-        tileFragment = '@@' + six.moves.urllib.parse.quote(name.encode('utf-8'), _safe)\n+        tileFragment = '@@' + parse.quote(name.encode('utf-8'), _safe)\n         if tid:\n-            tileFragment += '/' + six.moves.urllib.parse.quote(tid.encode('utf-8'), _safe)\n+            tileFragment += '/' + parse.quote(tid.encode('utf-8'), _safe)\n \n         absolute_url = getMultiAdapter((context, request), IAbsoluteURL)\n         try:\n@@ -49,9 +47,9 @@ def breadcrumbs(self):\n         name = tile.__name__\n         context = tile.__parent__\n \n-        tileFragment = '@@' + six.moves.urllib.parse.quote(name.encode('utf-8'), _safe)\n+        tileFragment = '@@' + parse.quote(name.encode('utf-8'), _safe)\n         if tid:\n-            tileFragment += '/' + six.moves.urllib.parse.quote(tid.encode('utf-8'), _safe)\n+            tileFragment += '/' + parse.quote(tid.encode('utf-8'), _safe)\n \n         base = tuple(\n             getMultiAdapter((context, request), IAbsoluteURL).breadcrumbs())\ndiff --git a/plone/tiles/data.py b/plone/tiles/data.py\nindex 1fc12d0..8494f6a 100644\n--- a/plone/tiles/data.py\n+++ b/plone/tiles/data.py\n@@ -9,6 +9,7 @@\n from plone.tiles.interfaces import ITileDataManager\n from plone.tiles.interfaces import ITileDataStorage\n from plone.tiles.interfaces import ITileType\n+from six.moves.urllib import parse\n from zope.annotation.interfaces import IAnnotations\n from zope.component import adapter\n from zope.component import getMultiAdapter\n@@ -23,9 +24,6 @@\n import json\n import logging\n import pkg_resources\n-import six.moves.urllib.request\n-import six.moves.urllib.parse\n-import six.moves.urllib.error\n import six\n \n \n@@ -339,7 +337,7 @@ def encode(data, schema, ignore=()):\n             else:\n                 encode.append((encoded_name, value))\n \n-    return six.moves.urllib.parse.urlencode(encode)\n+    return parse.urlencode(encode)\n \n \n # Decoding\n"

Repository: plone.tiles


Branch: refs/heads/master
Date: 2018-11-09T00:35:34+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.tiles/commit/5477145ca6894c89f32f67b3df33d17211ee0f9e

Merge pull request #28 from plone/python3

Add support for Python 3

Files changed:
M CHANGES.rst
M plone/tiles/absoluteurl.py
M plone/tiles/data.py
M plone/tiles/data.rst
M plone/tiles/directives.rst
M plone/tiles/esi.rst
M plone/tiles/tests/test_doctests.py
M plone/tiles/tiles.rst
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 3115f89..5a9fc57 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -4,7 +4,8 @@ Changelog\n 2.1.1 (unreleased)\n ------------------\n \n-- Nothing changed yet.\n+- Add support for Python 3.\n+  [pbauer]\n \n \n 2.1 (2018-07-05)\ndiff --git a/plone/tiles/absoluteurl.py b/plone/tiles/absoluteurl.py\nindex 9fe4776..efb4efb 100644\n--- a/plone/tiles/absoluteurl.py\n+++ b/plone/tiles/absoluteurl.py\n@@ -2,15 +2,13 @@\n from plone.tiles.data import encode\n from plone.tiles.interfaces import ITileDataManager\n from plone.tiles.interfaces import ITileType\n+from six.moves.urllib import parse\n from zope.annotation import IAnnotations\n from zope.component import getMultiAdapter\n from zope.component import queryUtility\n from zope.traversing.browser.absoluteurl import AbsoluteURL\n from zope.traversing.browser.interfaces import IAbsoluteURL\n \n-import urllib\n-\n-\n _safe = \'@+\'\n \n \n@@ -29,9 +27,9 @@ def __str__(self):\n         if name is None or context is None:\n             raise TypeError(\'Insufficient context to determine URL\')\n \n-        tileFragment = \'@@\' + urllib.quote(name.encode(\'utf-8\'), _safe)\n+        tileFragment = \'@@\' + parse.quote(name.encode(\'utf-8\'), _safe)\n         if tid:\n-            tileFragment += \'/\' + urllib.quote(tid.encode(\'utf-8\'), _safe)\n+            tileFragment += \'/\' + parse.quote(tid.encode(\'utf-8\'), _safe)\n \n         absolute_url = getMultiAdapter((context, request), IAbsoluteURL)\n         try:\n@@ -49,9 +47,9 @@ def breadcrumbs(self):\n         name = tile.__name__\n         context = tile.__parent__\n \n-        tileFragment = \'@@\' + urllib.quote(name.encode(\'utf-8\'), _safe)\n+        tileFragment = \'@@\' + parse.quote(name.encode(\'utf-8\'), _safe)\n         if tid:\n-            tileFragment += \'/\' + urllib.quote(tid.encode(\'utf-8\'), _safe)\n+            tileFragment += \'/\' + parse.quote(tid.encode(\'utf-8\'), _safe)\n \n         base = tuple(\n             getMultiAdapter((context, request), IAbsoluteURL).breadcrumbs())\ndiff --git a/plone/tiles/data.py b/plone/tiles/data.py\nindex 1def88a..8494f6a 100644\n--- a/plone/tiles/data.py\n+++ b/plone/tiles/data.py\n@@ -9,6 +9,7 @@\n from plone.tiles.interfaces import ITileDataManager\n from plone.tiles.interfaces import ITileDataStorage\n from plone.tiles.interfaces import ITileType\n+from six.moves.urllib import parse\n from zope.annotation.interfaces import IAnnotations\n from zope.component import adapter\n from zope.component import getMultiAdapter\n@@ -23,7 +24,7 @@\n import json\n import logging\n import pkg_resources\n-import urllib\n+import six\n \n \n try:\n@@ -223,7 +224,7 @@ def guess_type(v):\n         return \'\'\n \n     for item_name, item_value in value.items():\n-        if isinstance(item_value, unicode):\n+        if isinstance(item_value, six.text_type):\n             item_value = item_value.encode(\'utf-8\')\n \n         if isinstance(item_value, list) or isinstance(item_value, tuple):\n@@ -231,7 +232,7 @@ def guess_type(v):\n                 marshall_type = guess_type(item_subvalue)\n                 if isinstance(item_subvalue, bool):\n                     item_subvalue = item_subvalue and \'1\' or \'\'\n-                elif isinstance(item_subvalue, unicode):\n+                elif isinstance(item_subvalue, six.text_type):\n                     item_subvalue = item_subvalue.encode(\'utf-8\')\n                 encoded_name = \'{0}.{1}{2}:list:{3}\'.format(\n                     prefix,\n@@ -244,7 +245,7 @@ def guess_type(v):\n             marshall_type = guess_type(item_value)\n             if isinstance(item_value, bool):\n                 item_value = item_value and \'1\' or \'\'\n-            elif isinstance(item_value, unicode):\n+            elif isinstance(item_value, six.text_type):\n                 item_value = item_value.encode(\'utf-8\')\n             encoded_name = \'{0:s}.{1:s}{2:s}:{3:s}\'.format(\n                 prefix,\n@@ -291,7 +292,7 @@ def encode(data, schema, ignore=()):\n         value = data[name]\n         if value is None:\n             continue\n-        elif isinstance(value, unicode):\n+        elif isinstance(value, six.text_type):\n             value = value.encode(\'utf-8\')\n \n         if ISequence.providedBy(field):\n@@ -317,7 +318,7 @@ def encode(data, schema, ignore=()):\n \n                 if isinstance(item, bool):\n                     item = item and \'1\' or \'\'\n-                elif isinstance(item, unicode):\n+                elif isinstance(item, six.text_type):\n                     item = item.encode(\'utf-8\')\n \n                 if isinstance(item, dict):\n@@ -336,7 +337,7 @@ def encode(data, schema, ignore=()):\n             else:\n                 encode.append((encoded_name, value))\n \n-    return urllib.urlencode(encode)\n+    return parse.urlencode(encode)\n \n \n # Decoding\n@@ -390,8 +391,8 @@ def decode(data, schema, missing=True):\n         elif isinstance(value, (tuple, list)) and value:\n             value = value[0]\n \n-        if isinstance(value, str):\n-            value = unicode(value, \'utf-8\')\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(\'utf-8\')\n \n         if field._type is not None and not isinstance(value, field._type):\n             value = field_type(value)\ndiff --git a/plone/tiles/data.rst b/plone/tiles/data.rst\nindex 78f3ecc..d9fb8b4 100644\n--- a/plone/tiles/data.rst\n+++ b/plone/tiles/data.rst\n@@ -112,12 +112,12 @@ This also applies to the value_type of a list or tuple:\n     >>> encode(data, IUnsupported) # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n     ...\n-    ComponentLookupError: Cannot URL encode decimal of type <class \'zope.schema._field.Decimal\'>\n+    zope.interface.interfaces.ComponentLookupError: Cannot URL encode decimal of type <class \'zope.schema._field.Decimal\'>\n \n     >>> encode(data, IUnsupported, ignore=(\'decimal\',)) # doctest: +ELLIPSIS\n     Traceback (most recent call last):\n     ...\n-    ComponentLookupError: Cannot URL encode value type for list of type <class \'zope.schema._field.List\'> : <class \'zope.schema._field.Decimal\'>\n+    zope.interface.interfaces.ComponentLookupError: Cannot URL encode value type for list of type <class \'zope.schema._field.List\'> : <class \'zope.schema._field.Decimal\'>\n \n     >>> encode(data, IUnsupported, ignore=(\'decimal\', \'list\',))\n     \'bytes_line=abc\'\n@@ -135,7 +135,7 @@ Let\'s use a data dictionary that may have come back from a query string like the\n \n     >>> data = dict(text_line=u\'A\', ascii_line=u\'B\', text=u\'C\\nD\', ascii=u\'E\\nF\', int=3, float=1.2, bool=False, weekday=u\'Saturday\')\n     >>> sorted(decode(data, ISimple).items())\n-    [(\'ascii\', \'E\\nF\'), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', u\'C\\nD\'), (\'text_line\', u\'A\'), (\'weekday\', u\'Saturday\')]\n+    [(\'ascii\', \'E\\nF\'), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', \'C\\nD\'), (\'text_line\', \'A\'), (\'weekday\', \'Saturday\')]\n \n If any values are missing from the input dictionary,\n they will default to ``missing_value``.\n@@ -144,7 +144,7 @@ they will default to ``missing_value``.\n \n     >>> data = dict(text_line=u\'A\', ascii_line=u\'B\', int=3, float=1.2, bool=False, weekday=u\'Saturday\')\n     >>> sorted(decode(data, ISimple).items())\n-    [(\'ascii\', None), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', u\'Missing\'), (\'text_line\', u\'A\'), (\'weekday\', u\'Saturday\')]\n+    [(\'ascii\', None), (\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'list\', None), (\'listchoice\', None), (\'text\', \'Missing\'), (\'text_line\', \'A\'), (\'weekday\', \'Saturday\')]\n \n If you pass ``missing=False``, the values are ignored instead.\n \n@@ -152,7 +152,7 @@ If you pass ``missing=False``, the values are ignored instead.\n \n     >>> data = dict(text_line=u\'A\', ascii_line=u\'B\', int=3, float=1.2, bool=False)\n     >>> sorted(decode(data, ISimple, missing=False).items())\n-    [(\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'text_line\', u\'A\')]\n+    [(\'ascii_line\', \'B\'), (\'bool\', False), (\'float\', 1.2), (\'int\', 3), (\'text_line\', \'A\')]\n \n Decoding also works for lists and their value types:\n \n@@ -168,7 +168,7 @@ Decoding should work with lists and the ISimple schema\n \n     >>> data = dict(list=[\'a\', \'b\'])\n     >>> sorted(decode(data, ISimple, missing=False).items())\n-    [(\'list\', [u\'a\', u\'b\'])]\n+    [(\'list\', [\'a\', \'b\'])]\n \n And list choice fields\n \ndiff --git a/plone/tiles/directives.rst b/plone/tiles/directives.rst\nindex e8f7ed3..5e27fd6 100644\n--- a/plone/tiles/directives.rst\n+++ b/plone/tiles/directives.rst\n@@ -103,7 +103,7 @@ Let\'s show how these may be used by registering several tiles:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -118,7 +118,7 @@ Let\'s check how the tiles were registered:\n     >>> tile1_type\n     <TileType dummy1 (Dummy tile 1)>\n     >>> tile1_type.description\n-    u\'This one shows all available options\'\n+    \'This one shows all available options\'\n \n     >>> tile1_type.add_permission\n     \'plone.tiles.testing.DummyAdd\'\n@@ -164,12 +164,13 @@ Finally, let\'s check that we can look up the tiles:\n .. code-block:: python\n \n     >>> from zope.publisher.browser import TestRequest\n-    >>> from zope.interface import implements, alsoProvides\n+    >>> from zope.interface import implementer, alsoProvides\n \n     >>> from plone.tiles.testing import IDummyContext, IDummyLayer\n \n-    >>> class Context(object):\n-    ...     implements(IDummyContext)\n+    >>> @implementer(IDummyContext)\n+    ... class Context(object):\n+    ...     pass\n \n     >>> context = Context()\n     >>> request = TestRequest()\n@@ -182,7 +183,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile1 = getMultiAdapter((context, layer_request), name=\'dummy1\')\n     >>> isinstance(tile1, DummyTileWithTemplate)\n     True\n-    >>> print tile1()\n+    >>> print(tile1())\n     <b>test!</b>\n     >>> tile1.__name__\n     \'dummy1\'\n@@ -190,7 +191,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile2 = getMultiAdapter((context, request), name=\'dummy2\')\n     >>> isinstance(tile2, DummyTile)\n     True\n-    >>> print tile2()\n+    >>> print(tile2())\n     dummy\n     >>> tile2.__name__\n     \'dummy2\'\n@@ -198,7 +199,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile3 = getMultiAdapter((context, request), name=\'dummy3\')\n     >>> isinstance(tile3, Tile)\n     True\n-    >>> print tile3()\n+    >>> print(tile3())\n     <b>test!</b>\n     >>> tile3.__name__\n     \'dummy3\'\n@@ -206,7 +207,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile4 = getMultiAdapter((context, request), name=\'dummy4\')\n     >>> isinstance(tile4, PersistentTile)\n     True\n-    >>> print tile4()\n+    >>> print(tile4())\n     <b>test!</b>\n     >>> tile4.__name__\n     \'dummy4\'\n@@ -214,7 +215,7 @@ Finally, let\'s check that we can look up the tiles:\n     >>> tile3_layer = getMultiAdapter((context, layer_request), name=\'dummy3\')\n     >>> isinstance(tile3_layer, DummyTile)\n     True\n-    >>> print tile3_layer()\n+    >>> print(tile3_layer())\n     dummy\n     >>> tile3_layer.__name__\n     \'dummy3\'\ndiff --git a/plone/tiles/esi.rst b/plone/tiles/esi.rst\nindex f8ff303..ef95e48 100644\n--- a/plone/tiles/esi.rst\n+++ b/plone/tiles/esi.rst\n@@ -26,7 +26,7 @@ To use the package, you should first load its ZCML configuration.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -145,18 +145,18 @@ At this point, we can look up the ESI views:\n     >>> head()\n     Traceback (most recent call last):\n     ...\n-    Unauthorized: Unauthorized()\n+    zExceptions.unauthorized.Unauthorized: Unauthorized()\n \n But we can only render them when we have the required permissions:\n \n     >>> from AccessControl.SecurityManagement import newSecurityManager\n     >>> from AccessControl.User import UnrestrictedUser\n     >>> newSecurityManager(None, UnrestrictedUser(\'manager\', \'\', [\'Manager\'], []))\n-    >>> print head()\n+    >>> print(head())\n     <title>Title</title>\n \n     >>> body = getMultiAdapter((tile, request), name=\'esi-body\')\n-    >>> print body()\n+    >>> print(body())\n     <b>My tile</b>\n \n Tiles without heads or bodies\n@@ -186,7 +186,7 @@ We won\'t bother to register this for this test, instead just instantiating it di\n     True\n \n     >>> head = getMultiAdapter((tile, request), name=\'esi-head\')\n-    >>> print head()\n+    >>> print(head())\n     <title>Page title</title>\n \n Of course, the ESI body renderer would return the same thing,\n@@ -195,7 +195,7 @@ since it can\'t extract a specific body either:\n .. code-block:: python\n \n     >>> body = getMultiAdapter((tile, request), name=\'esi-body\')\n-    >>> print body()\n+    >>> print(body())\n     <title>Page title</title>\n \n In this case, we would likely end up with invalid HTML,\n@@ -272,7 +272,7 @@ By default, the tile renders as normal:\n \n .. code-block:: python\n \n-    >>> print tile()\n+    >>> print(tile())\n     <html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>\n \n However, if we opt into ESI rendering via a request header, we get a different view:\n@@ -281,7 +281,7 @@ However, if we opt into ESI rendering via a request header, we get a different v\n \n     >>> from plone.tiles.interfaces import ESI_HEADER_KEY\n     >>> request.environ[ESI_HEADER_KEY] = \'true\'\n-    >>> print tile() # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(tile()) # doctest: +NORMALIZE_WHITESPACE\n     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n     <html xmlns="http://www.w3.org/1999/xhtml">\n@@ -297,7 +297,7 @@ This can be transformed into a proper ESI tag with ``substituteESILinks()``:\n .. code-block:: python\n \n     >>> from plone.tiles.esi import substituteESILinks\n-    >>> print substituteESILinks(tile()) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(substituteESILinks(tile())) # doctest: +NORMALIZE_WHITESPACE\n     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n     <html xmlns:esi="http://www.edge-delivery.org/esi/1.0" xmlns="http://www.w3.org/1999/xhtml">\n@@ -313,7 +313,7 @@ This is done with a class variable \'head\'\n .. code-block:: python\n \n     >>> SampleESITile.head = True\n-    >>> print tile() # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(tile()) # doctest: +NORMALIZE_WHITESPACE\n     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n     <html xmlns="http://www.w3.org/1999/xhtml">\ndiff --git a/plone/tiles/tests/test_doctests.py b/plone/tiles/tests/test_doctests.py\nindex 2fa2378..4dfac56 100644\n--- a/plone/tiles/tests/test_doctests.py\n+++ b/plone/tiles/tests/test_doctests.py\n@@ -3,9 +3,24 @@\n from plone.tiles.testing import PLONE_TILES_INTEGRATION_TESTING\n \n import doctest\n+import re\n+import six\n import unittest\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub(\n+                \'zope.interface.interfaces.ComponentLookupError\',\n+                \'ComponentLookupError\',\n+                want)\n+            want = re.sub(\n+                \'zExceptions.unauthorized.Unauthorized\', \'Unauthorized\', want)\n+            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     return unittest.TestSuite((\n         layered(\n@@ -14,7 +29,8 @@ def test_suite():\n                 \'../directives.rst\',\n                 \'../data.rst\',\n                 \'../esi.rst\',\n-                optionflags=doctest.ELLIPSIS\n+                optionflags=doctest.ELLIPSIS,\n+                checker=Py23DocChecker(),\n             ),\n             layer=PLONE_TILES_INTEGRATION_TESTING\n         ),\ndiff --git a/plone/tiles/tiles.rst b/plone/tiles/tiles.rst\nindex 1686e60..f7c0b39 100644\n--- a/plone/tiles/tiles.rst\n+++ b/plone/tiles/tiles.rst\n@@ -37,7 +37,7 @@ To use the package, you should first load its ZCML configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -297,8 +297,8 @@ Therefore, there is a corresponding ``decode()`` method that may be used to ensu\n     >>> marshaled = {\'title\': u\'My tile\', \'count\': 5, \'cssClass\': u\'foo\'}\n \n     >>> from plone.tiles.data import decode\n-    >>> decode(marshaled, ISampleTileData)\n-    {\'count\': 5, \'cssClass\': \'foo\', \'title\': u\'My tile\'}\n+    >>> sorted(decode(marshaled, ISampleTileData).items())\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My tile\')]\n \n When saved into a layout, the tile link would now look like:\n \n@@ -318,7 +318,7 @@ Let\'s simulate traversal once more and see how the data is now available to the\n     >>> tile = tile[\'tile1\']\n \n     >>> sorted(tile.data.items())\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n Notice also how the data has been properly decoded according to the schema.\n \n@@ -338,7 +338,7 @@ this one will be used instead:\n     >>> tile = tile[\'tile1\']\n \n     >>> sorted(tile.data.items())\n-    [(u\'count\', 6), (u\'cssClass\', u\'bar\'), (u\'title\', u\'Your title\')]\n+    [(\'count\', 6), (\'cssClass\', \'bar\'), (\'title\', \'Your title\')]\n \n This way we can use transient tiles safely in contexts where the tile data can be confused with raw data coming from a form, e.g. in an edit form.\n \n@@ -367,7 +367,7 @@ We can also update the tile data:\n \n     >>> dataManager.set({\'count\': 1, \'cssClass\': \'bar\', \'title\': u\'Another title\'})\n     >>> sorted(dataManager.get().items())\n-    [(\'count\', 1), (\'cssClass\', \'bar\'), (\'title\', u\'Another title\')]\n+    [(\'count\', 1), (\'cssClass\', \'bar\'), (\'title\', \'Another title\')]\n \n The data can also be deleted:\n \n@@ -453,13 +453,13 @@ By default, there is no data, and the field\'s missing value will be used.\n     \'tile2\'\n \n     >>> tile()\n-    u\'<b>You said</b> Missing!\'\n+    \'<b>You said</b> Missing!\'\n \n At this point, there is nothing in the annotations for the type either:\n \n .. code-block:: python\n \n-    >>> dict(getattr(context, \'__annotations__\', {})).keys()\n+    >>> list(dict(getattr(context, \'__annotations__\', {})).keys())\n     []\n \n We can write data to the context\'s annotations using an ``ITileDataManager``:\n@@ -467,23 +467,23 @@ We can write data to the context\'s annotations using an ``ITileDataManager``:\n .. code-block:: python\n \n     >>> dataManager = ITileDataManager(tile)\n-    >>> dataManager.set({\'text\': u\'Hello!\'})\n+    >>> dataManager.set({\'text\': \'Hello!\'})\n \n This writes data to annotations:\n \n .. code-block:: python\n \n-    >>> dict(context.__annotations__).keys()\n-    [u\'plone.tiles.data.tile2\']\n+    >>> list(dict(context.__annotations__).keys())\n+    [\'plone.tiles.data.tile2\']\n     >>> context.__annotations__[u\'plone.tiles.data.tile2\']\n-    {\'text\': u\'Hello!\'}\n+    {\'text\': \'Hello!\'}\n \n We can get this from the data manager too, of course:\n \n .. code-block:: python\n \n     >>> dataManager.get()\n-    {\'text\': u\'Hello!\'}\n+    {\'text\': \'Hello!\'}\n \n Note that as with transient tiles,\n the ``data`` attribute is cached and will only be looked up once.\n@@ -495,10 +495,10 @@ If we now look up the tile again, we will get the new value:\n     >>> tile = getMultiAdapter((context, request), name=u\'sample.persistenttile\')\n     >>> tile = tile[\'tile2\']\n     >>> tile()\n-    u\'<b>You said</b> Hello!\'\n+    \'<b>You said</b> Hello!\'\n \n     >>> tile.data\n-    {\'text\': u\'Hello!\'}\n+    {\'text\': \'Hello!\'}\n \n We can also remove the annotation using the data manager:\n \n@@ -533,7 +533,7 @@ Yet, just adding the flag, doesn\'t create new persistent annotations on GET requ\n     <plone.tiles.data.PersistentTileDataManager object at ...>\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> list(IAnnotations(context).keys())\n     []\n@@ -546,13 +546,13 @@ That\'s because the data is persistent only once it\'s set:\n     >>> data.update({\'count\': 6})\n     >>> ITileDataManager(tile).set(data)\n     >>> list(IAnnotations(context).keys())\n-    [u\'plone.tiles.data...\']\n+    [\'plone.tiles.data...\']\n \n-    >>> sorted(IAnnotations(context).values()[0].items(), key=lambda x: x[0])\n-    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    >>> sorted(list(IAnnotations(context).values())[0].items(), key=lambda x: x[0])\n+    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n Without the persistent flag, fixed transient data would be returned:\n \n@@ -567,7 +567,7 @@ Without the persistent flag, fixed transient data would be returned:\n \n     >>> data = ITileDataManager(tile).get()\n     >>> sorted(data.items(), key=lambda x: x[0])\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n Finally, the persistent override could also be deleted:\n \n@@ -582,14 +582,14 @@ Finally, the persistent override could also be deleted:\n     <plone.tiles.data.PersistentTileDataManager object at ...>\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 6), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> ITileDataManager(tile).delete()\n     >>> list(IAnnotations(context).keys())\n     []\n \n     >>> sorted(ITileDataManager(tile).get().items(), key=lambda x: x[0])\n-    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', u\'My title\')]\n+    [(\'count\', 5), (\'cssClass\', \'foo\'), (\'title\', \'My title\')]\n \n     >>> request = TestRequest(\n     ...     form={\'title\': u\'My title\', \'count\': 5, \'cssClass\': u\'foo\'},\n@@ -614,15 +614,15 @@ We\'ll achieve that with a dummy adapter:\n \n .. code-block:: python\n \n-    >>> from zope.interface import implements\n-    >>> from zope.component import adapts\n+    >>> from zope.interface import implementer\n+    >>> from zope.component import adapter\n \n     >>> from zope.traversing.browser.interfaces import IAbsoluteURL\n     >>> from zope.publisher.interfaces.http import IHTTPRequest\n \n-    >>> class DummyAbsoluteURL(object):\n-    ...     implements(IAbsoluteURL)\n-    ...     adapts(IContext, IHTTPRequest)\n+    >>> @implementer(IAbsoluteURL)\n+    ... @adapter(IContext, IHTTPRequest)\n+    ... class DummyAbsoluteURL(object):\n     ...\n     ...     def __init__(self, context, request):\n     ...         self.context = context\n@@ -769,7 +769,7 @@ Data should not contain unfiltered field:\n .. code-block:: python\n \n     >>> sorted(tile.data.items())\n-    [(\'filtered\', u\'safe\')]\n+    [(\'filtered\', \'safe\')]\n \n \n Rendering the tile should not include ignored query string:\ndiff --git a/setup.py b/setup.py\nindex 07f20a4..5e78e72 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -27,6 +27,8 @@\n         \'License :: OSI Approved :: GNU General Public License v2 (GPLv2)\',\n         \'Programming Language :: Python\',\n         \'Programming Language :: Python :: 2.7\',\n+        \'Programming Language :: Python :: 3.6\',\n+        \'Programming Language :: Python :: 3.7\',\n         \'Topic :: Internet :: WWW/HTTP\',\n         \'Topic :: Internet :: WWW/HTTP :: Dynamic Content\',\n         \'Topic :: Software Development :: Libraries :: Python Modules\',\n'

