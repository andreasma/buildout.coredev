Repository: plone.supermodel


Branch: refs/heads/master
Date: 2019-12-05T17:41:45+01:00
Author: Jonas Baumann (jone) <jone@jone.ch>
Commit: https://github.com/plone/plone.supermodel/commit/ef3c16e3bf583731d61d520ccfce1ce0a9442c79

Add support for choices of integers for improved registry.xml export.

This adds support for vocabularies with choices of integers in the
registry.xml export.

Files changed:
M CHANGES.rst
M plone/supermodel/exportimport.py
M plone/supermodel/tests.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 5f2b3b9..bbb755d 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -16,6 +16,9 @@ Bug fixes:\n \n - tests to ensure schema.Set is serialized consistently (#30)\n \n+- Add support for choices of integers for improved registry.xml export.\n+  [jone]\n+\n \n 1.4.0 (2018-09-28)\n ------------------\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 0694f61..247de45 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -398,17 +398,21 @@ def write(self, field, name, type, elementName=\'field\'):\n             value = []\n             for term in field.vocabulary:\n                 if (\n-                    not isinstance(term.value, six.string_types) or\n-                    six.b(term.token) != term.value.encode(\'unicode_escape\')\n+                    isinstance(term.value, six.integer_types)\n+                    or (\n+                        isinstance(term.value, six.string_types)\n+                        and six.b(term.token) == term.value.encode(\'unicode_escape\')\n+                    )\n                 ):\n+                    if term.title and term.title != term.value:\n+                        value.append((term.value, term.title))\n+                    else:\n+                        value.append(term.value)\n+                else:\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\n                         u"based on a simple list of values"\n                     )\n-                if term.title and term.title != term.value:\n-                    value.append((term.value, term.title))\n-                else:\n-                    value.append(term.value)\n \n             attributeField = self.fieldAttributes[\'values\']\n             if any(map(lambda v: isinstance(v, tuple), value)):\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex be630e2..ccd45d8 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -503,6 +503,15 @@ def _choice_with_term_titles_and_ns(self):\n             \'</field>\'\n         return (schema.Choice(vocabulary=vocab), expected)\n \n+    def _choice_with_integers(self):\n+        vocab = SimpleVocabulary([SimpleTerm(1, title=u\'One\')])\n+        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n+            \'<values>\'\\\n+            \'<element key="1">One</element>\'\\\n+            \'</values>\'\\\n+            \'</field>\'\n+        return (schema.Choice(vocabulary=vocab), expected)\n+\n     def test_choice_serialized(self):\n         """ Tests a regular choice, one with empty string term in vocab,\n         and another with terms that have titles\n@@ -510,7 +519,8 @@ def test_choice_serialized(self):\n         choice = self._choice()\n         choice_with_empty = self._choice_with_empty()\n         choice_with_term_titles = self._choice_with_term_titles()\n-        for case in (choice, choice_with_empty, choice_with_term_titles):\n+        choice_with_integers = self._choice_with_integers()\n+        for case in (choice, choice_with_empty, choice_with_term_titles, choice_with_integers):\n             field, expected = case\n             expected = six.binary_type(expected) if six.PY2 \\\n                 else six.binary_type(expected, encoding=\'latin-1\')\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2019-12-05T21:27:05+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.supermodel/commit/32dba325450dab47957c3e93a886ccd4f0e6a9f7

Merge pull request #32 from plone/jone-choice-integers

Add support for choices of integers for improved registry.xml export.

Files changed:
M CHANGES.rst
M plone/supermodel/exportimport.py
M plone/supermodel/tests.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 5f2b3b9..bbb755d 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -16,6 +16,9 @@ Bug fixes:\n \n - tests to ensure schema.Set is serialized consistently (#30)\n \n+- Add support for choices of integers for improved registry.xml export.\n+  [jone]\n+\n \n 1.4.0 (2018-09-28)\n ------------------\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 0694f61..247de45 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -398,17 +398,21 @@ def write(self, field, name, type, elementName=\'field\'):\n             value = []\n             for term in field.vocabulary:\n                 if (\n-                    not isinstance(term.value, six.string_types) or\n-                    six.b(term.token) != term.value.encode(\'unicode_escape\')\n+                    isinstance(term.value, six.integer_types)\n+                    or (\n+                        isinstance(term.value, six.string_types)\n+                        and six.b(term.token) == term.value.encode(\'unicode_escape\')\n+                    )\n                 ):\n+                    if term.title and term.title != term.value:\n+                        value.append((term.value, term.title))\n+                    else:\n+                        value.append(term.value)\n+                else:\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\n                         u"based on a simple list of values"\n                     )\n-                if term.title and term.title != term.value:\n-                    value.append((term.value, term.title))\n-                else:\n-                    value.append(term.value)\n \n             attributeField = self.fieldAttributes[\'values\']\n             if any(map(lambda v: isinstance(v, tuple), value)):\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex be630e2..ccd45d8 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -503,6 +503,15 @@ def _choice_with_term_titles_and_ns(self):\n             \'</field>\'\n         return (schema.Choice(vocabulary=vocab), expected)\n \n+    def _choice_with_integers(self):\n+        vocab = SimpleVocabulary([SimpleTerm(1, title=u\'One\')])\n+        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n+            \'<values>\'\\\n+            \'<element key="1">One</element>\'\\\n+            \'</values>\'\\\n+            \'</field>\'\n+        return (schema.Choice(vocabulary=vocab), expected)\n+\n     def test_choice_serialized(self):\n         """ Tests a regular choice, one with empty string term in vocab,\n         and another with terms that have titles\n@@ -510,7 +519,8 @@ def test_choice_serialized(self):\n         choice = self._choice()\n         choice_with_empty = self._choice_with_empty()\n         choice_with_term_titles = self._choice_with_term_titles()\n-        for case in (choice, choice_with_empty, choice_with_term_titles):\n+        choice_with_integers = self._choice_with_integers()\n+        for case in (choice, choice_with_empty, choice_with_term_titles, choice_with_integers):\n             field, expected = case\n             expected = six.binary_type(expected) if six.PY2 \\\n                 else six.binary_type(expected, encoding=\'latin-1\')\n'

