Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-11-05T13:19:26+01:00
Author: Timo Stollenwerk (tisto) <tisto@users.noreply.github.com>
Commit: https://github.com/plone/plone.restapi/commit/d00494f31a90a5d5070bea5e6f96254413148f54

Check black on Travis. (#823)

* Check black on Travis.

* Black

* Fix flake8 config for black.

* Fix black on Travis.

Files changed:
M .travis.yml
M base.cfg
M src/plone/restapi/__init__.py
M src/plone/restapi/batching.py
M src/plone/restapi/deserializer/atfields.py
M src/plone/restapi/deserializer/dxcontent.py
M src/plone/restapi/deserializer/local_roles.py
M src/plone/restapi/deserializer/relationfield.py
M src/plone/restapi/serializer/atfields.py
M src/plone/restapi/serializer/summary.py
M src/plone/restapi/serializer/vocabularies.py
M src/plone/restapi/services/auth/login.py
M src/plone/restapi/services/copymove/copymove.py
M src/plone/restapi/services/multilingual/pam.py
M src/plone/restapi/services/navigation/get.py
M src/plone/restapi/services/querysources/get.py
M src/plone/restapi/services/querystring/get.py
M src/plone/restapi/services/querystringsearch/get.py
M src/plone/restapi/services/sources/get.py
M src/plone/restapi/services/types/get.py
M src/plone/restapi/services/users/get.py
M src/plone/restapi/testing.py
M src/plone/restapi/tests/dxtypes.py
M src/plone/restapi/tests/statictime.py
M src/plone/restapi/tests/test_documentation.py
M src/plone/restapi/tests/test_dxcontent_deserializer.py
M src/plone/restapi/tests/test_dxfield_serializer.py
M src/plone/restapi/tests/test_expansion.py
M src/plone/restapi/tests/test_serializer_summary.py
M src/plone/restapi/tests/test_services_querysources.py
M src/plone/restapi/tests/test_services_querystring.py
M src/plone/restapi/tests/test_services_sources.py
M src/plone/restapi/tests/test_services_vocabularies.py
M src/plone/restapi/tests/test_statictime.py
M src/plone/restapi/tests/test_types.py
M src/plone/restapi/types/adapters.py
M src/plone/restapi/types/utils.py

b'diff --git a/.travis.yml b/.travis.yml\nindex 88eddced..f8088972 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -46,6 +46,7 @@ install:\n   - buildout -t 10 -c travis.cfg\n script:\n   - bin/code-analysis\n+  - if [ -f "bin/black" ]; then bin/black src/ --check ; fi\n   - bin/sphinxbuilder\n   - bin/test\n   - bin/test-no-uncommitted-doc-changes\ndiff --git a/base.cfg b/base.cfg\nindex c89b0a13..3fbb6442 100644\n--- a/base.cfg\n+++ b/base.cfg\n@@ -102,7 +102,7 @@ recipe = plone.recipe.codeanalysis\n directory = ${buildout:directory}/src\n flake8-exclude=bootstrap.py,bootstrap-buildout.py,docs,bin,*.egg,setup.py,overrides,omelette\n flake8-max-complexity = 25\n-# flake8-ignore = E203, E266, E501, W503\n+flake8-ignore = E203, E266, E501, W503\n flake8-max-line-length = 200\n # flake8-select = B,C,E,F,W,T4,B9\n flake8-extensions =\ndiff --git a/src/plone/restapi/__init__.py b/src/plone/restapi/__init__.py\nindex b3a1526d..0872fac9 100644\n--- a/src/plone/restapi/__init__.py\n+++ b/src/plone/restapi/__init__.py\n@@ -2,9 +2,7 @@\n from AccessControl import allow_module\n from AccessControl.Permissions import add_user_folders\n from plone.restapi.pas import plugin\n-from Products.PluggableAuthService.PluggableAuthService import (\n-    registerMultiPlugin,\n-)\n+from Products.PluggableAuthService.PluggableAuthService import registerMultiPlugin\n from zope.i18nmessageid import MessageFactory\n \n import pkg_resources\ndiff --git a/src/plone/restapi/batching.py b/src/plone/restapi/batching.py\nindex 46407c3b..1dee04e1 100644\n--- a/src/plone/restapi/batching.py\n+++ b/src/plone/restapi/batching.py\n@@ -12,8 +12,12 @@ class HypermediaBatch(object):\n     def __init__(self, request, results):\n         self.request = request\n \n-        self.b_start = int(json_body(self.request).get(\'b_start\', False)) or int(self.request.form.get("b_start", 0))\n-        self.b_size = int(json_body(self.request).get(\'b_size\', False)) or int(self.request.form.get("b_size", DEFAULT_BATCH_SIZE))\n+        self.b_start = int(json_body(self.request).get("b_start", False)) or int(\n+            self.request.form.get("b_start", 0)\n+        )\n+        self.b_size = int(json_body(self.request).get("b_size", False)) or int(\n+            self.request.form.get("b_size", DEFAULT_BATCH_SIZE)\n+        )\n \n         self.batch = Batch(results, self.b_size, self.b_start)\n \ndiff --git a/src/plone/restapi/deserializer/atfields.py b/src/plone/restapi/deserializer/atfields.py\nindex d743697c..a316afa1 100644\n--- a/src/plone/restapi/deserializer/atfields.py\n+++ b/src/plone/restapi/deserializer/atfields.py\n@@ -59,6 +59,7 @@ def __call__(self, value):\n \n \n if HAS_BLOB:\n+\n     @implementer(IFieldDeserializer)\n     @adapter(IBlobField, IBaseObject, IBrowserRequest)\n     class BlobFieldDeserializer(FileFieldDeserializer):\n@@ -80,7 +81,7 @@ def __call__(self, value):\n         for i, v in enumerate(value):\n             # Resolve references given by URL\n             if v.startswith(portal_url):\n-                path = v[len(portal_url) + 1:].encode("utf8")\n+                path = v[len(portal_url) + 1 :].encode("utf8")\n                 value[i] = portal.unrestrictedTraverse(path, None)\n \n         return value, {}\ndiff --git a/src/plone/restapi/deserializer/dxcontent.py b/src/plone/restapi/deserializer/dxcontent.py\nindex 79dfc4e4..6fd857ef 100644\n--- a/src/plone/restapi/deserializer/dxcontent.py\n+++ b/src/plone/restapi/deserializer/dxcontent.py\n@@ -154,7 +154,7 @@ def mark_field_as_changed(self, schema, fieldname):\n         z3c.form does so.\n         """\n \n-        prefixed_name = schema.__name__ + \'.\' + fieldname\n+        prefixed_name = schema.__name__ + "." + fieldname\n         self.modified.setdefault(schema, []).append(prefixed_name)\n \n     def check_permission(self, permission_name):\ndiff --git a/src/plone/restapi/deserializer/local_roles.py b/src/plone/restapi/deserializer/local_roles.py\nindex 86f0d65c..73540a68 100644\n--- a/src/plone/restapi/deserializer/local_roles.py\n+++ b/src/plone/restapi/deserializer/local_roles.py\n@@ -56,8 +56,9 @@ def __call__(self):\n             roles_reindex = sharing_view.update_role_settings(new_roles, reindex=False)\n \n         # reindex object security\n-        can_reindex = (ICatalogAware(self.context, None) or\n-                       IPloneSiteRoot.providedBy(self.context))\n+        can_reindex = ICatalogAware(self.context, None) or IPloneSiteRoot.providedBy(\n+            self.context\n+        )\n         if can_reindex and (inherit_reindex or roles_reindex):\n             self.context.reindexObjectSecurity()\n             if LOCALROLES_MODIFIED_EVENT_AVAILABLE:\ndiff --git a/src/plone/restapi/deserializer/relationfield.py b/src/plone/restapi/deserializer/relationfield.py\nindex 669fd787..4765c72f 100644\n--- a/src/plone/restapi/deserializer/relationfield.py\n+++ b/src/plone/restapi/deserializer/relationfield.py\n@@ -39,7 +39,7 @@ def __call__(self, value):\n             portal_url = portal.absolute_url()\n             if value.startswith(portal_url):\n                 # Resolve by URL\n-                obj = portal.restrictedTraverse(value[len(portal_url) + 1:], None)\n+                obj = portal.restrictedTraverse(value[len(portal_url) + 1 :], None)\n                 resolved_by = "URL"\n             elif value.startswith("/"):\n                 # Resolve by path\ndiff --git a/src/plone/restapi/serializer/atfields.py b/src/plone/restapi/serializer/atfields.py\nindex c6a4b366..461cb144 100644\n--- a/src/plone/restapi/serializer/atfields.py\n+++ b/src/plone/restapi/serializer/atfields.py\n@@ -107,6 +107,7 @@ def __call__(self):\n \n \n if HAS_BLOB:\n+\n     @adapter(IBlobField, IBaseObject, Interface)\n     @implementer(IFieldSerializer)\n     class BlobFieldSerializer(FileFieldSerializer):\n@@ -133,6 +134,7 @@ def __call__(self):\n \n \n if IQueryField is not None:\n+\n     @adapter(IQueryField, IBaseObject, Interface)\n     @implementer(IFieldSerializer)\n     class QueryFieldSerializer(DefaultFieldSerializer):\ndiff --git a/src/plone/restapi/serializer/summary.py b/src/plone/restapi/serializer/summary.py\nindex 9eb5eed4..3387658e 100644\n--- a/src/plone/restapi/serializer/summary.py\n+++ b/src/plone/restapi/serializer/summary.py\n@@ -71,11 +71,11 @@ def metadata_fields(self):\n         additional_metadata_fields = set(additional_metadata_fields)\n \n         if "_all" in additional_metadata_fields:\n-            fields_cache = self.request.get(\'_summary_fields_cache\', None)\n+            fields_cache = self.request.get("_summary_fields_cache", None)\n             if fields_cache is None:\n                 catalog = getToolByName(self.context, "portal_catalog")\n                 fields_cache = set(catalog.schema()) | NON_METADATA_ATTRIBUTES\n-                self.request.set(\'_summary_fields_cache\', fields_cache)\n+                self.request.set("_summary_fields_cache", fields_cache)\n             additional_metadata_fields = fields_cache\n \n         return DEFAULT_METADATA_FIELDS | additional_metadata_fields\ndiff --git a/src/plone/restapi/serializer/vocabularies.py b/src/plone/restapi/serializer/vocabularies.py\nindex f6ad6b8a..4e1ebab8 100644\n--- a/src/plone/restapi/serializer/vocabularies.py\n+++ b/src/plone/restapi/serializer/vocabularies.py\n@@ -20,6 +20,7 @@ class SerializeVocabLikeToJson(object):\n \n     Implements server-side filtering as well as batching.\n     """\n+\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\ndiff --git a/src/plone/restapi/services/auth/login.py b/src/plone/restapi/services/auth/login.py\nindex 3937ce65..2f0bae47 100644\n--- a/src/plone/restapi/services/auth/login.py\n+++ b/src/plone/restapi/services/auth/login.py\n@@ -4,9 +4,7 @@\n from plone.restapi.deserializer import json_body\n from plone.restapi.services import Service\n from Products.CMFCore.utils import getToolByName\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    IAuthenticationPlugin,\n-)\n+from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin\n from zope.interface import alsoProvides\n \n import plone.protect.interfaces\ndiff --git a/src/plone/restapi/services/copymove/copymove.py b/src/plone/restapi/services/copymove/copymove.py\nindex bfa11666..05e9374f 100644\n--- a/src/plone/restapi/services/copymove/copymove.py\n+++ b/src/plone/restapi/services/copymove/copymove.py\n@@ -29,7 +29,7 @@ def get_object(self, key):\n         if isinstance(key, six.string_types):\n             if key.startswith(self.portal_url):\n                 # Resolve by URL\n-                key = key[len(self.portal_url) + 1:]\n+                key = key[len(self.portal_url) + 1 :]\n                 if six.PY2:\n                     key = key.encode("utf8")\n                 return self.portal.restrictedTraverse(key, None)\ndiff --git a/src/plone/restapi/services/multilingual/pam.py b/src/plone/restapi/services/multilingual/pam.py\nindex 29fab72f..2a33a204 100644\n--- a/src/plone/restapi/services/multilingual/pam.py\n+++ b/src/plone/restapi/services/multilingual/pam.py\n@@ -97,7 +97,7 @@ def _traverse(self, url):\n         portal = purl.getPortalObject()\n         portal_url = portal.absolute_url()\n         if url.startswith(portal_url):\n-            content_path = url[len(portal_url) + 1:]\n+            content_path = url[len(portal_url) + 1 :]\n             content_path = content_path.split("/")\n             content_item = portal.restrictedTraverse(content_path)\n             return content_item\ndiff --git a/src/plone/restapi/services/navigation/get.py b/src/plone/restapi/services/navigation/get.py\nindex c34815cd..e3fbedda 100644\n--- a/src/plone/restapi/services/navigation/get.py\n+++ b/src/plone/restapi/services/navigation/get.py\n@@ -51,7 +51,7 @@ def getRootPath(self, topLevel=1):\n         contextPath = "/".join(self.context.getPhysicalPath())\n         if not contextPath.startswith(rootPath):\n             return None\n-        contextSubPathElements = contextPath[len(rootPath) + 1:]\n+        contextSubPathElements = contextPath[len(rootPath) + 1 :]\n         if contextSubPathElements:\n             contextSubPathElements = contextSubPathElements.split("/")\n             if len(contextSubPathElements) < topLevel:\ndiff --git a/src/plone/restapi/services/querysources/get.py b/src/plone/restapi/services/querysources/get.py\nindex ac2b76ae..fa6b8a44 100644\n--- a/src/plone/restapi/services/querysources/get.py\n+++ b/src/plone/restapi/services/querysources/get.py\n@@ -11,38 +11,33 @@\n \n @implementer(IPublishTraverse)\n class QuerySourcesGet(SourcesGet):\n-\n     def reply(self):\n         if len(self.params) != 1:\n             return self._error(\n-                400, "Bad Request",\n-                "Must supply exactly one path parameter (fieldname)"\n+                400, "Bad Request", "Must supply exactly one path parameter (fieldname)"\n             )\n         fieldname = self.params[0]\n \n         field = get_field_by_name(fieldname, self.context)\n         if field is None:\n-            return self._error(\n-                404, "Not Found",\n-                "No such field: %r" % fieldname\n-            )\n+            return self._error(404, "Not Found", "No such field: %r" % fieldname)\n         bound_field = field.bind(self.context)\n \n         source = bound_field.source\n         if not IQuerySource.providedBy(source):\n             return self._error(\n-                404, "Not Found",\n-                "Field %r does not have an IQuerySource" % fieldname\n+                404, "Not Found", "Field %r does not have an IQuerySource" % fieldname\n             )\n \n-        if \'query\' not in self.request.form:\n+        if "query" not in self.request.form:\n             return self._error(\n-                400, "Bad Request",\n-                u\'Enumerating querysources is not supported. Please search \'\n-                u\'the source using the ?query= QS parameter\'\n+                400,\n+                "Bad Request",\n+                u"Enumerating querysources is not supported. Please search "\n+                u"the source using the ?query= QS parameter",\n             )\n \n-        query = self.request.form[\'query\']\n+        query = self.request.form["query"]\n \n         result = source.search(query)\n \ndiff --git a/src/plone/restapi/services/querystring/get.py b/src/plone/restapi/services/querystring/get.py\nindex 57b5adfa..58097512 100644\n--- a/src/plone/restapi/services/querystring/get.py\n+++ b/src/plone/restapi/services/querystring/get.py\n@@ -15,9 +15,8 @@ class QuerystringGet(Service):\n \n     def reply(self):\n         registry = getUtility(IRegistry)\n-        reader = getMultiAdapter(\n-            (registry, self.request), IQuerystringRegistryReader)\n+        reader = getMultiAdapter((registry, self.request), IQuerystringRegistryReader)\n \n         result = reader()\n-        result[\'@id\'] = \'%s/@querystring\' % self.context.absolute_url()\n+        result["@id"] = "%s/@querystring" % self.context.absolute_url()\n         return result\ndiff --git a/src/plone/restapi/services/querystringsearch/get.py b/src/plone/restapi/services/querystringsearch/get.py\nindex 01aae2fe..4625351a 100644\n--- a/src/plone/restapi/services/querystringsearch/get.py\n+++ b/src/plone/restapi/services/querystringsearch/get.py\n@@ -23,7 +23,7 @@ def reply(self):\n             raise Exception("No query supplied")\n \n         if sort_order:\n-            sort_order = \'descending\' if sort_order else \'ascending\'\n+            sort_order = "descending" if sort_order else "ascending"\n \n         querybuilder = getMultiAdapter(\n             (self.context, self.request), name="querybuilderresults"\ndiff --git a/src/plone/restapi/services/sources/get.py b/src/plone/restapi/services/sources/get.py\nindex 9653d1f4..a6280470 100644\n--- a/src/plone/restapi/services/sources/get.py\n+++ b/src/plone/restapi/services/sources/get.py\n@@ -28,35 +28,27 @@ def _error(self, status, type, message):\n     def reply(self):\n         if len(self.params) != 1:\n             return self._error(\n-                400, "Bad Request",\n-                "Must supply exactly one path parameter (fieldname)"\n+                400, "Bad Request", "Must supply exactly one path parameter (fieldname)"\n             )\n         fieldname = self.params[0]\n \n         field = get_field_by_name(fieldname, self.context)\n         if field is None:\n-            return self._error(\n-                404, "Not Found",\n-                "No such field: %r" % fieldname\n-            )\n+            return self._error(404, "Not Found", "No such field: %r" % fieldname)\n         bound_field = field.bind(self.context)\n \n         source = bound_field.source\n         if not ISource.providedBy(source):\n             return self._error(\n-                404, "Not Found",\n-                "Field %r does not have a source" % fieldname\n+                404, "Not Found", "Field %r does not have a source" % fieldname\n             )\n \n         if not IIterableSource.providedBy(source):\n             return self._error(\n-                400, "Bad Request",\n-                "Source for field %r is not iterable. " % fieldname\n+                400, "Bad Request", "Source for field %r is not iterable. " % fieldname\n             )\n \n-        serializer = getMultiAdapter(\n-            (source, self.request), interface=ISerializeToJson\n-        )\n+        serializer = getMultiAdapter((source, self.request), interface=ISerializeToJson)\n         return serializer(\n             "{}/@sources/{}".format(self.context.absolute_url(), fieldname)\n         )\ndiff --git a/src/plone/restapi/services/types/get.py b/src/plone/restapi/services/types/get.py\nindex dc392cf4..24b0edac 100644\n--- a/src/plone/restapi/services/types/get.py\n+++ b/src/plone/restapi/services/types/get.py\n@@ -26,15 +26,12 @@ def check_security(context):\n @implementer(IExpandableElement)\n @adapter(IDexterityContent, Interface)\n class TypesInfo(object):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n \n     def __call__(self, expand=False):\n-        result = {\n-            "types": {"@id": "{}/@types".format(self.context.absolute_url())}\n-        }\n+        result = {"types": {"@id": "{}/@types".format(self.context.absolute_url())}}\n         if not expand:\n             return result\n \n@@ -62,7 +59,7 @@ def __call__(self, expand=False):\n         ftis = [portal_types[x.value] for x in vocab_factory(self.context)]\n         ftis = [fti for fti in ftis if getattr(fti, "lookupSchema", None)]\n \n-        result[\'types\'] = [\n+        result["types"] = [\n             {\n                 "@id": "{}/@types/{}".format(portal_url, fti.getId()),\n                 "title": translate(fti.Title(), context=self.request),\ndiff --git a/src/plone/restapi/services/users/get.py b/src/plone/restapi/services/users/get.py\nindex aac2aedb..d4d87a2a 100644\n--- a/src/plone/restapi/services/users/get.py\n+++ b/src/plone/restapi/services/users/get.py\n@@ -59,7 +59,8 @@ def has_permission_to_enumerate(self):\n     def has_permission_to_access_user_info(self):\n         sm = getSecurityManager()\n         return sm.checkPermission(\n-            "plone.restapi: Access Plone user information", self.context)\n+            "plone.restapi: Access Plone user information", self.context\n+        )\n \n     def reply(self):\n         if len(self.query) > 0 and len(self.params) == 0:\n@@ -102,7 +103,8 @@ def reply(self):\n         current_user_id = mt.getAuthenticatedMember().getId()\n \n         if self.has_permission_to_access_user_info() or (\n-                current_user_id and current_user_id == self._get_user_id):\n+            current_user_id and current_user_id == self._get_user_id\n+        ):\n \n             # we retrieve the user on the user id not the username\n             user = self._get_user(self._get_user_id)\ndiff --git a/src/plone/restapi/testing.py b/src/plone/restapi/testing.py\nindex ad01c533..341247cb 100644\n--- a/src/plone/restapi/testing.py\n+++ b/src/plone/restapi/testing.py\n@@ -106,29 +106,33 @@ def enable_request_language_negotiation(portal):\n class DateTimeFixture(Layer):\n     def setUp(self):\n         tz = "UTC"\n-        os.environ[\'TZ\'] = tz\n+        os.environ["TZ"] = tz\n         time.tzset()\n \n         # Patch DateTime\'s timezone for deterministic behavior.\n         from DateTime import DateTime\n+\n         self.DT_orig_localZone = DateTime.localZone\n         DateTime.localZone = lambda cls=None, ltm=None: tz\n \n         from plone.dexterity import content\n+\n         content.FLOOR_DATE = DateTime(1970, 0)\n         content.CEILING_DATE = DateTime(2500, 0)\n         self._orig_content_zone = content._zone\n         content._zone = tz\n \n     def tearDown(self):\n-        if \'TZ\' in os.environ:\n-            del os.environ[\'TZ\']\n+        if "TZ" in os.environ:\n+            del os.environ["TZ"]\n         time.tzset()\n \n         from DateTime import DateTime\n+\n         DateTime.localZone = self.DT_orig_localZone\n \n         from plone.dexterity import content\n+\n         content._zone = self._orig_content_zone\n         content.FLOOR_DATE = DateTime(1970, 0)\n         content.CEILING_DATE = DateTime(2500, 0)\ndiff --git a/src/plone/restapi/tests/dxtypes.py b/src/plone/restapi/tests/dxtypes.py\nindex 46a9eed0..606aec01 100644\n--- a/src/plone/restapi/tests/dxtypes.py\n+++ b/src/plone/restapi/tests/dxtypes.py\n@@ -52,8 +52,10 @@ def __contains__(self, value):\n         return value in self.values\n \n     def __iter__(self):\n-        terms = [SimpleTerm(value=v, token=\'token%s\' % v, title=\'Title %s\' % v)\n-                 for v in self.values]\n+        terms = [\n+            SimpleTerm(value=v, token="token%s" % v, title="Title %s" % v)\n+            for v in self.values\n+        ]\n         return iter(terms)\n \n \n@@ -65,8 +67,10 @@ def __contains__(self, value):\n         return value in self.values\n \n     def search(self, query):\n-        terms = [SimpleTerm(value=v, token=\'token%s\' % v, title=\'Title %s\' % v)\n-                 for v in self.values]\n+        terms = [\n+            SimpleTerm(value=v, token="token%s" % v, title="Title %s" % v)\n+            for v in self.values\n+        ]\n         return [t for t in terms if query in str(t.token)]\n \n     def __iter__(self):\n@@ -76,13 +80,13 @@ def __iter__(self):\n \n @implementer(IIterableSource)\n class MyIterableContextSource(object):\n-\n     def __init__(self, context):\n         self.context = context\n \n         title_words = self.context.title.split()\n-        self.terms = [SimpleTerm(value=w.lower(), token=w.lower(), title=w)\n-                      for w in title_words]\n+        self.terms = [\n+            SimpleTerm(value=w.lower(), token=w.lower(), title=w) for w in title_words\n+        ]\n \n     def __contains__(self, value):\n         return value in [t.value for t in self.terms]\n@@ -93,13 +97,13 @@ def __iter__(self):\n \n @implementer(IQuerySource)\n class MyContextQuerySource(object):\n-\n     def __init__(self, context):\n         self.context = context\n \n         title_words = self.context.title.split()\n-        self.terms = [SimpleTerm(value=w.lower(), token=w.lower(), title=w)\n-                      for w in title_words]\n+        self.terms = [\n+            SimpleTerm(value=w.lower(), token=w.lower(), title=w) for w in title_words\n+        ]\n \n     def __contains__(self, value):\n         return value in [t.value for t in self.terms]\n@@ -156,15 +160,16 @@ class IDXTestDocumentSchema(model.Schema):\n     )\n \n     test_choice_with_non_iterable_source = schema.Choice(\n-        required=False, source=my_non_iterable_source)\n-    test_choice_with_source = schema.Choice(\n-        required=False, source=my_iterable_source)\n+        required=False, source=my_non_iterable_source\n+    )\n+    test_choice_with_source = schema.Choice(required=False, source=my_iterable_source)\n     test_choice_with_context_source = schema.Choice(\n-        required=False, source=my_context_source_binder)\n-    test_choice_with_querysource = schema.Choice(\n-        required=False, source=my_querysource)\n+        required=False, source=my_context_source_binder\n+    )\n+    test_choice_with_querysource = schema.Choice(required=False, source=my_querysource)\n     test_choice_with_context_querysource = schema.Choice(\n-        required=False, source=my_context_querysource_binder)\n+        required=False, source=my_context_querysource_binder\n+    )\n \n     test_date_field = schema.Date(required=False)\n     test_datetime_field = schema.Datetime(required=False)\ndiff --git a/src/plone/restapi/tests/statictime.py b/src/plone/restapi/tests/statictime.py\nindex a3a2b2dc..2545793a 100644\n--- a/src/plone/restapi/tests/statictime.py\n+++ b/src/plone/restapi/tests/statictime.py\n@@ -10,9 +10,9 @@\n \n \n _originals = {\n-    \'WorkflowTool.getInfoFor\': WorkflowTool.getInfoFor,\n-    \'ContentHistoryViewlet.fullHistory\': ContentHistoryViewlet.fullHistory,\n-    \'TTWLockable.lock_info\': TTWLockable.lock_info,\n+    "WorkflowTool.getInfoFor": WorkflowTool.getInfoFor,\n+    "ContentHistoryViewlet.fullHistory": ContentHistoryViewlet.fullHistory,\n+    "TTWLockable.lock_info": TTWLockable.lock_info,\n }\n \n \n@@ -67,9 +67,11 @@ def __enter__(self):\n     def __exit__(self, _type, exc, _traceback):\n         self.stop()\n \n-    def __init__(self,\n-                 created=datetime(1995, 7, 31, 13, 45),\n-                 modified=datetime(1995, 7, 31, 17, 30)):\n+    def __init__(\n+        self,\n+        created=datetime(1995, 7, 31, 13, 45),\n+        modified=datetime(1995, 7, 31, 17, 30),\n+    ):\n         self.static_created = created\n         self.static_modified = modified\n         """Set up a static time helper.\n@@ -98,38 +100,41 @@ def start(self):\n         # __init__. In order to fake the returned times we patch a property\n         # onto the class which will shadow these instance attributes.\n         DexterityContent.creation_date = property(\n-            static_creation_date_getter_factory(self.static_created),\n-            nop_setter)\n+            static_creation_date_getter_factory(self.static_created), nop_setter\n+        )\n         DexterityContent.modification_date = property(\n-            static_modification_date_getter_factory(self.static_modified),\n-            nop_setter)\n+            static_modification_date_getter_factory(self.static_modified), nop_setter\n+        )\n \n         # Patch the lightweight p.a.discussion \'Comment\' type. Its dates are\n         # Python datetimes, unlike DX Content types which use zope DateTimes.\n         Comment.creation_date = property(\n-            static_creation_date_getter_factory(\n-                self.static_created, type_=datetime),\n-            nop_setter)\n+            static_creation_date_getter_factory(self.static_created, type_=datetime),\n+            nop_setter,\n+        )\n         Comment.modification_date = property(\n             static_modification_date_getter_factory(\n-                self.static_modified, type_=datetime),\n-            nop_setter)\n+                self.static_modified, type_=datetime\n+            ),\n+            nop_setter,\n+        )\n \n-        WorkflowTool.getInfoFor = static_get_info_for_factory(\n-            self.static_modified)\n+        WorkflowTool.getInfoFor = static_get_info_for_factory(self.static_modified)\n \n         ContentHistoryViewlet.fullHistory = static_full_history_factory(\n-            self.static_modified)\n+            self.static_modified\n+        )\n \n-        TTWLockable.lock_info = static_lock_info_factory(\n-            self.static_modified)\n+        TTWLockable.lock_info = static_lock_info_factory(self.static_modified)\n \n     def stop(self):\n         """Undo all the patches.\n         """\n-        TTWLockable.lock_info = _originals[\'TTWLockable.lock_info\']\n-        ContentHistoryViewlet.fullHistory = _originals[\'ContentHistoryViewlet.fullHistory\']\n-        WorkflowTool.getInfoFor = _originals[\'WorkflowTool.getInfoFor\']\n+        TTWLockable.lock_info = _originals["TTWLockable.lock_info"]\n+        ContentHistoryViewlet.fullHistory = _originals[\n+            "ContentHistoryViewlet.fullHistory"\n+        ]\n+        WorkflowTool.getInfoFor = _originals["WorkflowTool.getInfoFor"]\n \n         Comment.modification_date = None\n         Comment.creation_date = None\n@@ -157,9 +162,10 @@ def static_get_info_for(self, ob, name, default=_marker, wf_id=None, *args, **kw\n         In other words, they will be stable (static), but different for each\n         event, and should still reflect proper order of events.\n         """\n-        res = _originals[\'WorkflowTool.getInfoFor\'](\n-            self, ob, name, default=default, wf_id=wf_id, *args, **kw)\n-        if name == \'review_history\':\n+        res = _originals["WorkflowTool.getInfoFor"](\n+            self, ob, name, default=default, wf_id=wf_id, *args, **kw\n+        )\n+        if name == "review_history":\n             base_date = dt_value\n \n             # The ContentHistoryViewlet.fullHistory method assembles results\n@@ -174,14 +180,15 @@ def static_get_info_for(self, ob, name, default=_marker, wf_id=None, *args, **kw\n             # will also be patched, timestamps in the combined results will be\n             # replaced there.)\n             import traceback\n+\n             stack = traceback.format_stack()\n-            if \'static_full_history\' in str(stack):\n+            if "static_full_history" in str(stack):\n                 return res\n \n             for idx, item in enumerate(res):\n                 fake_date = base_date + (idx / 24.0)  # plus one hour\n-                if \'time\' in item:\n-                    item[\'time\'] = fake_date\n+                if "time" in item:\n+                    item["time"] = fake_date\n \n         return res\n \n@@ -207,21 +214,21 @@ def static_full_history(self):\n         In other words, they will be stable (static), but different for each\n         event, and should still reflect proper order of events.\n         """\n-        actions = _originals[\'ContentHistoryViewlet.fullHistory\'](self)\n+        actions = _originals["ContentHistoryViewlet.fullHistory"](self)\n \n         base_date = dt_value\n         for idx, action in enumerate(actions):\n-            if \'time\' in action:\n+            if "time" in action:\n                 fake_date = base_date + (idx / 24.0)  # plus one hour\n \n                 # Depending on the kind of action, timestamps may either\n                 # be zope DateTimes or floats. Let\'s reserve the same type.\n-                if isinstance(action[\'time\'], float):\n-                    action[\'time\'] = float(fake_date)\n-                elif isinstance(action[\'time\'], DateTime):\n-                    action[\'time\'] = fake_date\n+                if isinstance(action["time"], float):\n+                    action["time"] = float(fake_date)\n+                elif isinstance(action["time"], DateTime):\n+                    action["time"] = fake_date\n                 else:\n-                    raise Exception("Don\'t know how to patch %r" % action[\'time\'])\n+                    raise Exception("Don\'t know how to patch %r" % action["time"])\n \n         return actions\n \n@@ -279,12 +286,12 @@ def static_lock_info(self):\n         In other words, they will be stable (static), but different for each\n         lock_info, and should still reflect proper order of events.\n         """\n-        infos = _originals[\'TTWLockable.lock_info\'](self)\n+        infos = _originals["TTWLockable.lock_info"](self)\n         base_date = dt_value\n         for idx, info in enumerate(infos):\n             fake_date = base_date + (idx / 24.0)  # plus one hour\n-            if \'time\' in info:\n-                info[\'time\'] = float(fake_date)\n+            if "time" in info:\n+                info["time"] = float(fake_date)\n \n         return infos\n \ndiff --git a/src/plone/restapi/tests/test_documentation.py b/src/plone/restapi/tests/test_documentation.py\nindex c7b4a6a2..9c1d828b 100644\n--- a/src/plone/restapi/tests/test_documentation.py\n+++ b/src/plone/restapi/tests/test_documentation.py\n@@ -149,7 +149,6 @@ def save_request_and_response_for_docs(name, response):\n \n \n class TestDocumentationBase(unittest.TestCase):\n-\n     def setUp(self):\n         self.statictime = self.setup_with_context_manager(StaticTime())\n \n@@ -1053,9 +1052,7 @@ def test_documentation_sources_get(self):\n             container=self.portal, id="doc", type="DXTestDocument", title=u"DX Document"\n         )\n         transaction.commit()\n-        response = self.api_session.get(\n-            "/doc/@sources/test_choice_with_source"\n-        )\n+        response = self.api_session.get("/doc/@sources/test_choice_with_source")\n         save_request_and_response_for_docs("sources_get", response)\n \n     def test_documentation_sharing_folder_get(self):\n@@ -1309,9 +1306,7 @@ def test_querystring_get(self):\n     def test_querystringsearch_post(self):\n         url = "/@querystring-search"\n \n-        self.portal.invokeFactory("Document",\n-                                  "testdocument",\n-                                  title="Test Document")\n+        self.portal.invokeFactory("Document", "testdocument", title="Test Document")\n         transaction.commit()\n \n         response = self.api_session.post(\n@@ -1324,7 +1319,8 @@ def test_querystringsearch_post(self):\n                         "v": ["Document"],\n                     }\n                 ]\n-            })\n+            },\n+        )\n         save_request_and_response_for_docs("querystringsearch_post", response)\n \n \n@@ -1455,7 +1451,9 @@ def clean_comment_id_from_urls(response, _id="123456"):\n \n         # and the response\n         if response.content:\n-            response._content = re.sub(pattern_bytes, repl.encode(\'utf-8\'), response._content)\n+            response._content = re.sub(\n+                pattern_bytes, repl.encode("utf-8"), response._content\n+            )\n \n     @staticmethod\n     def clean_comment_id_from_body(response):\n@@ -1466,10 +1464,11 @@ def clean_comment_id_from_body(response):\n         comment_ids = re.findall(pattern_bytes, response._content)\n \n         def new_cid(idx):\n-            return str(idx + 1400000000000000).encode(\'ascii\')\n+            return str(idx + 1400000000000000).encode("ascii")\n \n-        static_comment_ids = {old_cid: new_cid(idx)\n-                              for idx, old_cid in enumerate(comment_ids)}\n+        static_comment_ids = {\n+            old_cid: new_cid(idx) for idx, old_cid in enumerate(comment_ids)\n+        }\n \n         for cid, idx in static_comment_ids.items():\n             response._content = re.sub(cid, idx, response._content)\ndiff --git a/src/plone/restapi/tests/test_dxcontent_deserializer.py b/src/plone/restapi/tests/test_dxcontent_deserializer.py\nindex 986c2b5d..32bab960 100644\n--- a/src/plone/restapi/tests/test_dxcontent_deserializer.py\n+++ b/src/plone/restapi/tests/test_dxcontent_deserializer.py\n@@ -95,13 +95,17 @@ def test_deserializer_notifies_when_field_is_set_to_null(self):\n         def handler(obj, event):\n             obj._handler_called = True\n             self.event = event\n-        provideHandler(handler, (IDexterityItem, IObjectModifiedEvent,))\n+\n+        provideHandler(handler, (IDexterityItem, IObjectModifiedEvent))\n         self.deserialize(body=\'{"test_textline_field": null}\')\n-        self.assertTrue(getattr(self.portal.doc1, \'_handler_called\', False),\n-                        \'IObjectModifiedEvent not notified\')\n+        self.assertTrue(\n+            getattr(self.portal.doc1, "_handler_called", False),\n+            "IObjectModifiedEvent not notified",\n+        )\n         self.assertEqual(\n-            (\'IDXTestDocumentSchema.test_textline_field\',),\n-            self.event.descriptions[0].attributes)\n+            ("IDXTestDocumentSchema.test_textline_field",),\n+            self.event.descriptions[0].attributes,\n+        )\n \n     def test_deserializer_does_not_update_field_without_write_permission(self):\n         self.portal.doc1.test_write_permission_field = u"Test Write Permission"\ndiff --git a/src/plone/restapi/tests/test_dxfield_serializer.py b/src/plone/restapi/tests/test_dxfield_serializer.py\nindex 1df304da..725ca752 100644\n--- a/src/plone/restapi/tests/test_dxfield_serializer.py\n+++ b/src/plone/restapi/tests/test_dxfield_serializer.py\n@@ -271,7 +271,7 @@ def test_namedimage_field_serialization_returns_dict(self):\n             )\n \n     def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n-        image_data = b\'INVALID IMAGE DATA\'\n+        image_data = b"INVALID IMAGE DATA"\n         fn = "test_namedimage_field"\n         with patch.object(storage, "uuid4", return_value="uuid_1"):\n             value = self.serialize(\n@@ -282,15 +282,16 @@ def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n             )\n         self.assertEqual(\n             {\n-                u\'content-type\': u\'image/gif\',\n-                u\'download\': None,\n-                u\'filename\': u\'1024x768.gif\',\n-                u\'height\': -1,\n-                u\'scales\': {},\n-                u\'size\': 18,\n-                u\'width\': -1,\n+                u"content-type": u"image/gif",\n+                u"download": None,\n+                u"filename": u"1024x768.gif",\n+                u"height": -1,\n+                u"scales": {},\n+                u"size": 18,\n+                u"width": -1,\n             },\n-            value)\n+            value,\n+        )\n \n     def test_namedblobfile_field_serialization_returns_dict(self):\n         value = self.serialize(\ndiff --git a/src/plone/restapi/tests/test_expansion.py b/src/plone/restapi/tests/test_expansion.py\nindex 91190e36..9dbeda39 100644\n--- a/src/plone/restapi/tests/test_expansion.py\n+++ b/src/plone/restapi/tests/test_expansion.py\n@@ -274,35 +274,56 @@ def test_types_expanded(self):\n \n         base_url = self.portal.absolute_url()\n \n-        self.assertEqual([\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/Collection\')),\n-             u\'addable\': True,\n-             u\'title\': u\'Collection\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/DXTestDocument\')),\n-             u\'addable\': True,\n-             u\'title\': u\'DX Test Document\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/Event\')),\n-             u\'addable\': True,\n-             u\'title\': u\'Event\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/File\')),\n-             u\'addable\': True,\n-             u\'title\': u\'File\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/Folder\')),\n-             u\'addable\': True,\n-             u\'title\': u\'Folder\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/Image\')),\n-             u\'addable\': True,\n-             u\'title\': u\'Image\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/Link\')),\n-             u\'addable\': True,\n-             u\'title\': u\'Link\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/News Item\')),\n-             u\'addable\': True,\n-             u\'title\': u\'News Item\'},\n-            {u\'@id\': u\'/\'.join((base_url, \'@types/Document\')),\n-             u\'addable\': True,\n-             u\'title\': u\'Page\'}],\n-            response.json().get("@components").get("types"))\n+        self.assertEqual(\n+            [\n+                {\n+                    u"@id": u"/".join((base_url, "@types/Collection")),\n+                    u"addable": True,\n+                    u"title": u"Collection",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/DXTestDocument")),\n+                    u"addable": True,\n+                    u"title": u"DX Test Document",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/Event")),\n+                    u"addable": True,\n+                    u"title": u"Event",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/File")),\n+                    u"addable": True,\n+                    u"title": u"File",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/Folder")),\n+                    u"addable": True,\n+                    u"title": u"Folder",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/Image")),\n+                    u"addable": True,\n+                    u"title": u"Image",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/Link")),\n+                    u"addable": True,\n+                    u"title": u"Link",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/News Item")),\n+                    u"addable": True,\n+                    u"title": u"News Item",\n+                },\n+                {\n+                    u"@id": u"/".join((base_url, "@types/Document")),\n+                    u"addable": True,\n+                    u"title": u"Page",\n+                },\n+            ],\n+            response.json().get("@components").get("types"),\n+        )\n \n \n @unittest.skipUnless(\ndiff --git a/src/plone/restapi/tests/test_serializer_summary.py b/src/plone/restapi/tests/test_serializer_summary.py\nindex 4df69407..2b102fc9 100644\n--- a/src/plone/restapi/tests/test_serializer_summary.py\n+++ b/src/plone/restapi/tests/test_serializer_summary.py\n@@ -42,7 +42,7 @@ def setUp(self):\n \n         self.doc1.creation_date = DateTime("2016-01-21T01:14:48+00:00")\n         self.doc1.modification_date = DateTime("2017-01-21T01:14:48+00:00")\n-        self.doc1.reindexObject([\'modified\'])\n+        self.doc1.reindexObject(["modified"])\n \n     def tearDown(self):\n         popGlobalRegistry(getSite())\n@@ -115,17 +115,17 @@ def test_brain_summary_with_missing_value(self):\n \n     def test_brain_summary_includes_additional_metadata_fields(self):\n         brain = self.catalog(UID=self.doc1.UID())[0]\n-        self.request.form.update({\'metadata_fields\': [\'UID\', \'Creator\']})\n+        self.request.form.update({"metadata_fields": ["UID", "Creator"]})\n         summary = getMultiAdapter((brain, self.request), ISerializeToJsonSummary)()\n \n         self.assertDictEqual(\n             {\n                 "@id": "http://nohost/plone/doc1",\n                 "@type": "DXTestDocument",\n-                \'UID\': \'c6dcbd55ab2746e199cd4ed458000001\',\n-                \'Creator\': \'test_user_1_\',\n+                "UID": "c6dcbd55ab2746e199cd4ed458000001",\n+                "Creator": "test_user_1_",\n                 "title": "Lorem Ipsum",\n-                "description": \'Description\',\n+                "description": "Description",\n                 "review_state": "private",\n             },\n             summary,\n@@ -133,60 +133,60 @@ def test_brain_summary_includes_additional_metadata_fields(self):\n \n     def test_brain_summary_includes_all_metadata_fields(self):\n         brain = self.catalog(UID=self.doc1.UID())[0]\n-        self.request.form.update({\'metadata_fields\': \'_all\'})\n+        self.request.form.update({"metadata_fields": "_all"})\n         summary = getMultiAdapter((brain, self.request), ISerializeToJsonSummary)()\n \n         # mime_type was added in Plone 5.1\n         # Make sure tests pass on older Plone versions\n-        if \'mime_type\' not in summary:\n-            summary[\'mime_type\'] = u\'text/plain\'\n+        if "mime_type" not in summary:\n+            summary["mime_type"] = u"text/plain"\n \n         self.maxDiff = None\n         self.assertDictEqual(\n             {\n-                \'@id\': u\'http://nohost/plone/doc1\',\n-                \'@type\': u\'DXTestDocument\',\n-                \'CreationDate\': u\'2016-01-21T01:14:48+00:00\',\n-                \'Creator\': u\'test_user_1_\',\n-                \'Date\': u\'2017-01-21T01:14:48+00:00\',\n-                \'Description\': u\'Description\',\n-                \'EffectiveDate\': u\'None\',\n-                \'ExpirationDate\': u\'None\',\n-                \'ModificationDate\': u\'2017-01-21T01:14:48+00:00\',\n-                \'Subject\': [],\n-                \'Title\': u\'Lorem Ipsum\',\n-                \'Type\': u\'DX Test Document\',\n-                \'UID\': u\'c6dcbd55ab2746e199cd4ed458000001\',\n-                \'author_name\': None,\n-                \'cmf_uid\': None,\n-                \'commentators\': [],\n-                \'created\': u\'2016-01-21T01:14:48+00:00\',\n-                \'description\': u\'Description\',\n-                \'effective\': u\'1969-12-31T00:00:00+00:00\',\n-                \'end\': None,\n-                \'exclude_from_nav\': False,\n-                \'expires\': u\'2499-12-31T00:00:00+00:00\',\n-                \'getIcon\': None,\n-                \'getId\': u\'doc1\',\n-                \'getObjSize\': u\'0 KB\',\n-                \'getPath\': u\'/plone/doc1\',\n-                \'getRemoteUrl\': None,\n-                \'getURL\': u\'http://nohost/plone/doc1\',\n-                \'id\': u\'doc1\',\n-                \'in_response_to\': None,\n-                \'is_folderish\': False,\n-                \'last_comment_date\': None,\n-                \'listCreators\': [u\'test_user_1_\'],\n-                \'location\': None,\n-                \'meta_type\': u\'Dexterity Item\',\n-                \'mime_type\': u\'text/plain\',\n-                \'modified\': u\'2017-01-21T01:14:48+00:00\',\n-                \'portal_type\': u\'DXTestDocument\',\n-                \'review_state\': u\'private\',\n-                \'start\': None,\n-                \'sync_uid\': None,\n-                \'title\': u\'Lorem Ipsum\',\n-                \'total_comments\': 0,\n+                "@id": u"http://nohost/plone/doc1",\n+                "@type": u"DXTestDocument",\n+                "CreationDate": u"2016-01-21T01:14:48+00:00",\n+                "Creator": u"test_user_1_",\n+                "Date": u"2017-01-21T01:14:48+00:00",\n+                "Description": u"Description",\n+                "EffectiveDate": u"None",\n+                "ExpirationDate": u"None",\n+                "ModificationDate": u"2017-01-21T01:14:48+00:00",\n+                "Subject": [],\n+                "Title": u"Lorem Ipsum",\n+                "Type": u"DX Test Document",\n+                "UID": u"c6dcbd55ab2746e199cd4ed458000001",\n+                "author_name": None,\n+                "cmf_uid": None,\n+                "commentators": [],\n+                "created": u"2016-01-21T01:14:48+00:00",\n+                "description": u"Description",\n+                "effective": u"1969-12-31T00:00:00+00:00",\n+                "end": None,\n+                "exclude_from_nav": False,\n+                "expires": u"2499-12-31T00:00:00+00:00",\n+                "getIcon": None,\n+                "getId": u"doc1",\n+                "getObjSize": u"0 KB",\n+                "getPath": u"/plone/doc1",\n+                "getRemoteUrl": None,\n+                "getURL": u"http://nohost/plone/doc1",\n+                "id": u"doc1",\n+                "in_response_to": None,\n+                "is_folderish": False,\n+                "last_comment_date": None,\n+                "listCreators": [u"test_user_1_"],\n+                "location": None,\n+                "meta_type": u"Dexterity Item",\n+                "mime_type": u"text/plain",\n+                "modified": u"2017-01-21T01:14:48+00:00",\n+                "portal_type": u"DXTestDocument",\n+                "review_state": u"private",\n+                "start": None,\n+                "sync_uid": None,\n+                "title": u"Lorem Ipsum",\n+                "total_comments": 0,\n             },\n             summary,\n         )\ndiff --git a/src/plone/restapi/tests/test_services_querysources.py b/src/plone/restapi/tests/test_services_querysources.py\nindex e8054a96..9eca5459 100644\n--- a/src/plone/restapi/tests/test_services_querysources.py\n+++ b/src/plone/restapi/tests/test_services_querysources.py\n@@ -28,13 +28,17 @@ def setUp(self):\n         self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n \n         self.doc = api.content.create(\n-            container=self.portal, id="testdoc", type="DXTestDocument", title=u"Document 1"\n+            container=self.portal,\n+            id="testdoc",\n+            type="DXTestDocument",\n+            title=u"Document 1",\n         )\n         transaction.commit()\n \n     def test_get_querysource_xxx(self):\n         response = self.api_session.get(\n-            "%s/@querysources/test_choice_with_querysource?query=2" % self.doc.absolute_url()\n+            "%s/@querysources/test_choice_with_querysource?query=2"\n+            % self.doc.absolute_url()\n         )\n \n         self.assertEqual(200, response.status_code)\n@@ -42,17 +46,17 @@ def test_get_querysource_xxx(self):\n         self.assertEqual(\n             response,\n             {\n-                u"@id": self.doc.absolute_url() + u"/@querysources/test_choice_with_querysource?query=2",  # noqa\n-                u"items": [\n-                    {u"title": u"Title 2", u"token": u"token2"},\n-                ],\n+                u"@id": self.doc.absolute_url()\n+                + u"/@querysources/test_choice_with_querysource?query=2",  # noqa\n+                u"items": [{u"title": u"Title 2", u"token": u"token2"}],\n                 u"items_total": 1,\n             },\n         )\n \n     def test_get_querysource_batched(self):\n         response = self.api_session.get(\n-            "%s/@querysources/test_choice_with_querysource?query=token&b_size=1" % self.doc.absolute_url()\n+            "%s/@querysources/test_choice_with_querysource?query=token&b_size=1"\n+            % self.doc.absolute_url()\n         )\n \n         self.assertEqual(200, response.status_code)\n@@ -60,7 +64,8 @@ def test_get_querysource_batched(self):\n         self.assertEqual(\n             response,\n             {\n-                u"@id": self.doc.absolute_url() + u"/@querysources/test_choice_with_querysource?query=token",  # noqa\n+                u"@id": self.doc.absolute_url()\n+                + u"/@querysources/test_choice_with_querysource?query=token",  # noqa\n                 u"batching": {\n                     u"@id": self.doc.absolute_url()\n                     + u"/@querysources/test_choice_with_querysource?query=token&b_size=1",  # noqa\n@@ -71,9 +76,7 @@ def test_get_querysource_batched(self):\n                     u"next": self.doc.absolute_url()\n                     + u"/@querysources/test_choice_with_querysource?b_start=1&query=token&b_size=1",  # noqa\n                 },\n-                u"items": [\n-                    {u"title": u"Title 1", u"token": u"token1"},\n-                ],\n+                u"items": [{u"title": u"Title 1", u"token": u"token1"}],\n                 u"items_total": 3,\n             },\n         )\n@@ -90,27 +93,35 @@ def test_querysource_cant_be_enumerated(self):\n             response.get("error"),\n             {\n                 u"type": u"Bad Request",\n-                u"message": u\'Enumerating querysources is not supported. \'\n-                            u\'Please search the source using the ?query= QS parameter\',\n+                u"message": u"Enumerating querysources is not supported. "\n+                u"Please search the source using the ?query= QS parameter",\n             },\n         )\n \n     def test_get_querysource_for_unknown_field(self):\n-        response = self.api_session.get("%s/@querysources/unknown_field" % self.doc.absolute_url())\n+        response = self.api_session.get(\n+            "%s/@querysources/unknown_field" % self.doc.absolute_url()\n+        )\n \n         self.assertEqual(404, response.status_code)\n         response = response.json()\n-        self.assertEqual(response, {\n-            u\'error\': {\n-                u\'type\': u\'Not Found\',\n-                u\'message\': u"No such field: \'unknown_field\'"}})\n+        self.assertEqual(\n+            response,\n+            {\n+                u"error": {\n+                    u"type": u"Not Found",\n+                    u"message": u"No such field: \'unknown_field\'",\n+                }\n+            },\n+        )\n \n     def test_context_querysource_xxx(self):\n-        self.doc.title = \'Foo Bar Baz\'\n+        self.doc.title = "Foo Bar Baz"\n         transaction.commit()\n \n         response = self.api_session.get(\n-            "%s/@querysources/test_choice_with_context_querysource?query=foo" % self.doc.absolute_url()\n+            "%s/@querysources/test_choice_with_context_querysource?query=foo"\n+            % self.doc.absolute_url()\n         )\n \n         self.assertEqual(response.status_code, 200)\n@@ -119,9 +130,7 @@ def test_context_querysource_xxx(self):\n             {\n                 u"@id": self.portal_url\n                 + u"/testdoc/@querysources/test_choice_with_context_querysource?query=foo",  # noqa\n-                u"items": [\n-                    {u\'token\': u\'foo\', u\'title\': u\'Foo\'},\n-                ],\n+                u"items": [{u"token": u"foo", u"title": u"Foo"}],\n                 u"items_total": 1,\n             },\n         )\ndiff --git a/src/plone/restapi/tests/test_services_querystring.py b/src/plone/restapi/tests/test_services_querystring.py\nindex f8098007..3730b7c2 100644\n--- a/src/plone/restapi/tests/test_services_querystring.py\n+++ b/src/plone/restapi/tests/test_services_querystring.py\n@@ -30,110 +30,132 @@ def test_endpoint_lists_indexes(self):\n         response = self.api_session.get("/@querystring")\n \n         self.assertEqual(response.status_code, 200)\n-        self.assertIn(\'indexes\', response.json())\n-        self.assertIn(\'isFolderish\', response.json()[\'indexes\'])\n+        self.assertIn("indexes", response.json())\n+        self.assertIn("isFolderish", response.json()["indexes"])\n \n     def test_endpoint_lists_sortable_indexes(self):\n         response = self.api_session.get("/@querystring")\n \n         self.assertEqual(response.status_code, 200)\n-        self.assertIn(\'sortable_indexes\', response.json())\n-        self.assertIn(\'sortable_title\', response.json()[\'sortable_indexes\'])\n+        self.assertIn("sortable_indexes", response.json())\n+        self.assertIn("sortable_title", response.json()["sortable_indexes"])\n \n     def test_endpoint_shows_field_config(self):\n         response = self.api_session.get("/@querystring")\n \n         self.assertEqual(response.status_code, 200)\n-        indexes = response.json()[\'indexes\']\n-        idx = indexes[\'Title\']\n+        indexes = response.json()["indexes"]\n+        idx = indexes["Title"]\n \n         expected_field_config = {\n-            u\'description\': u"Text search of an item\'s title",\n-            u\'enabled\': True,\n-            u\'group\': u\'Text\',\n-            u\'operations\': [u\'plone.app.querystring.operation.string.contains\'],\n-            u\'operators\': {\n-                u\'plone.app.querystring.operation.string.contains\': {\n-                    u\'description\': None,\n-                    u\'operation\': u\'plone.app.querystring.queryparser._contains\',\n-                    u\'title\': u\'Contains\',\n-                    u\'widget\': u\'StringWidget\'}},\n-            u\'sortable\': False,\n-            u\'title\': u\'Title\',\n-            u\'values\': {},\n-            u\'vocabulary\': None}\n+            u"description": u"Text search of an item\'s title",\n+            u"enabled": True,\n+            u"group": u"Text",\n+            u"operations": [u"plone.app.querystring.operation.string.contains"],\n+            u"operators": {\n+                u"plone.app.querystring.operation.string.contains": {\n+                    u"description": None,\n+                    u"operation": u"plone.app.querystring.queryparser._contains",\n+                    u"title": u"Contains",\n+                    u"widget": u"StringWidget",\n+                }\n+            },\n+            u"sortable": False,\n+            u"title": u"Title",\n+            u"values": {},\n+            u"vocabulary": None,\n+        }\n         self.assertEqual(expected_field_config, idx)\n \n     def test_endpoint_inlines_vocabularies(self):\n         response = self.api_session.get("/@querystring")\n \n         self.assertEqual(response.status_code, 200)\n-        indexes = response.json()[\'indexes\']\n-        idx = indexes[\'review_state\']\n+        indexes = response.json()["indexes"]\n+        idx = indexes["review_state"]\n \n-        self.assertDictContainsSubset({\n-            \'title\': u\'Review state\',\n-            \'vocabulary\': u\'plone.app.vocabularies.WorkflowStates\'},\n-            idx)\n+        self.assertDictContainsSubset(\n+            {\n+                "title": u"Review state",\n+                "vocabulary": u"plone.app.vocabularies.WorkflowStates",\n+            },\n+            idx,\n+        )\n \n         expected_vocab_values = {\n-            u\'external\': {u\'title\': u\'Externally visible [external]\'},\n-            u\'internal\': {u\'title\': u\'Internal draft [internal]\'},\n-            u\'internally_published\': {u\'title\': u\'Internally published [internally_published]\'},\n-            u\'pending\': {u\'title\': u\'Pending [pending]\'},\n-            u\'private\': {u\'title\': u\'Private [private]\'},\n-            u\'published\': {u\'title\': u\'Published with accent \\xe9 [published]\'},\n-            u\'visible\': {u\'title\': u\'Public draft [visible]\'},\n+            u"external": {u"title": u"Externally visible [external]"},\n+            u"internal": {u"title": u"Internal draft [internal]"},\n+            u"internally_published": {\n+                u"title": u"Internally published [internally_published]"\n+            },\n+            u"pending": {u"title": u"Pending [pending]"},\n+            u"private": {u"title": u"Private [private]"},\n+            u"published": {u"title": u"Published with accent \\xe9 [published]"},\n+            u"visible": {u"title": u"Public draft [visible]"},\n         }\n-        self.assertEqual(expected_vocab_values, idx[\'values\'])\n+        self.assertEqual(expected_vocab_values, idx["values"])\n \n     def test_endpoint_inlines_operators(self):\n         response = self.api_session.get("/@querystring")\n \n         self.assertEqual(response.status_code, 200)\n-        indexes = response.json()[\'indexes\']\n-        idx = indexes[\'isDefaultPage\']\n-\n-        self.assertDictContainsSubset({\n-            \'title\': u\'Default Page\',\n-            \'operations\': [\n-                u\'plone.app.querystring.operation.boolean.isTrue\',\n-                u\'plone.app.querystring.operation.boolean.isFalse\']},\n-            idx)\n+        indexes = response.json()["indexes"]\n+        idx = indexes["isDefaultPage"]\n+\n+        self.assertDictContainsSubset(\n+            {\n+                "title": u"Default Page",\n+                "operations": [\n+                    u"plone.app.querystring.operation.boolean.isTrue",\n+                    u"plone.app.querystring.operation.boolean.isFalse",\n+                ],\n+            },\n+            idx,\n+        )\n \n         expected_operators = {\n-            u\'plone.app.querystring.operation.boolean.isFalse\': {\n-                u\'description\': None,\n-                u\'operation\': u\'plone.app.querystring.queryparser._isFalse\',\n-                u\'title\': u\'No\',\n-                u\'widget\': None},\n-            u\'plone.app.querystring.operation.boolean.isTrue\': {\n-                u\'description\': None,\n-                u\'operation\': u\'plone.app.querystring.queryparser._isTrue\',\n-                u\'title\': u\'Yes\',\n-                u\'widget\': None}}\n-        self.assertEqual(expected_operators, idx[\'operators\'])\n+            u"plone.app.querystring.operation.boolean.isFalse": {\n+                u"description": None,\n+                u"operation": u"plone.app.querystring.queryparser._isFalse",\n+                u"title": u"No",\n+                u"widget": None,\n+            },\n+            u"plone.app.querystring.operation.boolean.isTrue": {\n+                u"description": None,\n+                u"operation": u"plone.app.querystring.queryparser._isTrue",\n+                u"title": u"Yes",\n+                u"widget": None,\n+            },\n+        }\n+        self.assertEqual(expected_operators, idx["operators"])\n \n     def test_endpoint_includes_widgets_for_operators(self):\n         response = self.api_session.get("/@querystring")\n \n         self.assertEqual(response.status_code, 200)\n-        indexes = response.json()[\'indexes\']\n-        idx = indexes[\'getObjPositionInParent\']\n-\n-        self.assertDictContainsSubset({\n-            \'title\': u\'Order in folder\',\n-            \'operations\': [\n-                \'plone.app.querystring.operation.int.is\',\n-                \'plone.app.querystring.operation.int.lessThan\',\n-                \'plone.app.querystring.operation.int.largerThan\']},\n-            idx)\n-\n-        ops = idx[\'operators\']\n-\n-        self.assertEqual({\n-            \'description\': None,\n-            \'operation\': \'plone.app.querystring.queryparser._intLargerThan\',\n-            \'title\': \'Larger than\',\n-            \'widget\': \'StringWidget\'},\n-            ops[\'plone.app.querystring.operation.int.largerThan\'])\n+        indexes = response.json()["indexes"]\n+        idx = indexes["getObjPositionInParent"]\n+\n+        self.assertDictContainsSubset(\n+            {\n+                "title": u"Order in folder",\n+                "operations": [\n+                    "plone.app.querystring.operation.int.is",\n+                    "plone.app.querystring.operation.int.lessThan",\n+                    "plone.app.querystring.operation.int.largerThan",\n+                ],\n+            },\n+            idx,\n+        )\n+\n+        ops = idx["operators"]\n+\n+        self.assertEqual(\n+            {\n+                "description": None,\n+                "operation": "plone.app.querystring.queryparser._intLargerThan",\n+                "title": "Larger than",\n+                "widget": "StringWidget",\n+            },\n+            ops["plone.app.querystring.operation.int.largerThan"],\n+        )\ndiff --git a/src/plone/restapi/tests/test_services_sources.py b/src/plone/restapi/tests/test_services_sources.py\nindex e724d4e7..fa79ec88 100644\n--- a/src/plone/restapi/tests/test_services_sources.py\n+++ b/src/plone/restapi/tests/test_services_sources.py\n@@ -28,7 +28,10 @@ def setUp(self):\n         self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n \n         self.doc = api.content.create(\n-            container=self.portal, id="testdoc", type="DXTestDocument", title=u"Document 1"\n+            container=self.portal,\n+            id="testdoc",\n+            type="DXTestDocument",\n+            title=u"Document 1",\n         )\n         transaction.commit()\n \n@@ -42,7 +45,8 @@ def test_get_source(self):\n         self.assertEqual(\n             response,\n             {\n-                u"@id": self.doc.absolute_url() + u"/@sources/test_choice_with_source",  # noqa\n+                u"@id": self.doc.absolute_url()\n+                + u"/@sources/test_choice_with_source",  # noqa\n                 u"items": [\n                     {u"title": u"Title 1", u"token": u"token1"},\n                     {u"title": u"Title 2", u"token": u"token2"},\n@@ -62,7 +66,8 @@ def test_get_source_batched(self):\n         self.assertEqual(\n             response,\n             {\n-                u"@id": self.doc.absolute_url() + u"/@sources/test_choice_with_source",  # noqa\n+                u"@id": self.doc.absolute_url()\n+                + u"/@sources/test_choice_with_source",  # noqa\n                 u"batching": {\n                     u"@id": self.doc.absolute_url()\n                     + u"/@sources/test_choice_with_source?b_size=1",  # noqa\n@@ -73,9 +78,7 @@ def test_get_source_batched(self):\n                     u"next": self.doc.absolute_url()\n                     + u"/@sources/test_choice_with_source?b_start=1&b_size=1",  # noqa\n                 },\n-                u"items": [\n-                    {u"title": u"Title 1", u"token": u"token1"},\n-                ],\n+                u"items": [{u"title": u"Title 1", u"token": u"token1"}],\n                 u"items_total": 3,\n             },\n         )\n@@ -133,7 +136,8 @@ def test_get_source_filtered_by_token_partial_not_match(self):\n \n     def test_get_source_filtered_by_title_and_token_returns_error(self):\n         response = self.api_session.get(\n-            "%s/@sources/test_choice_with_source?token=token1&title=Title" % self.doc.absolute_url()  # noqa\n+            "%s/@sources/test_choice_with_source?token=token1&title=Title"\n+            % self.doc.absolute_url()  # noqa\n         )\n \n         self.assertEqual(400, response.status_code)\n@@ -162,21 +166,20 @@ def test_get_non_iterable_source_returns_error(self):\n         )\n \n     def test_get_source_for_unknown_field(self):\n-        response = self.api_session.get("%s/@sources/unknown_field" % self.doc.absolute_url())\n+        response = self.api_session.get(\n+            "%s/@sources/unknown_field" % self.doc.absolute_url()\n+        )\n \n         self.assertEqual(404, response.status_code)\n         response = response.json()\n \n         self.assertEqual(\n             response.get("error"),\n-            {\n-                u"type": u"Not Found",\n-                u"message": u"No such field: \'unknown_field\'",\n-            },\n+            {u"type": u"Not Found", u"message": u"No such field: \'unknown_field\'"},\n         )\n \n     def test_context_source(self):\n-        self.doc.title = \'Foo Bar Baz\'\n+        self.doc.title = "Foo Bar Baz"\n         transaction.commit()\n \n         response = self.api_session.get(\n@@ -190,9 +193,9 @@ def test_context_source(self):\n                 u"@id": self.portal_url\n                 + u"/testdoc/@sources/test_choice_with_context_source",  # noqa\n                 u"items": [\n-                    {u\'token\': u\'foo\', u\'title\': u\'Foo\'},\n-                    {u\'token\': u\'bar\', u\'title\': u\'Bar\'},\n-                    {u\'token\': u\'baz\', u\'title\': u\'Baz\'},\n+                    {u"token": u"foo", u"title": u"Foo"},\n+                    {u"token": u"bar", u"title": u"Bar"},\n+                    {u"token": u"baz", u"title": u"Baz"},\n                 ],\n                 u"items_total": 3,\n             },\ndiff --git a/src/plone/restapi/tests/test_services_vocabularies.py b/src/plone/restapi/tests/test_services_vocabularies.py\nindex bddfb0d0..f391c9d0 100644\n--- a/src/plone/restapi/tests/test_services_vocabularies.py\n+++ b/src/plone/restapi/tests/test_services_vocabularies.py\n@@ -208,10 +208,15 @@ def test_get_unknown_vocabulary(self):\n         self.assertEqual(404, response.status_code)\n         response = response.json()\n \n-        self.assertEqual(response, {\n-            u\'error\': {\n-                u\'type\': u\'Not Found\',\n-                u\'message\': u"The vocabulary \'unknown.vocabulary\' does not exist"}})\n+        self.assertEqual(\n+            response,\n+            {\n+                u"error": {\n+                    u"type": u"Not Found",\n+                    u"message": u"The vocabulary \'unknown.vocabulary\' does not exist",\n+                }\n+            },\n+        )\n \n     def test_get_all_vocabularies(self):\n         response = self.api_session.get("/@vocabularies")\ndiff --git a/src/plone/restapi/tests/test_statictime.py b/src/plone/restapi/tests/test_statictime.py\nindex ff8cd7b7..163701aa 100644\n--- a/src/plone/restapi/tests/test_statictime.py\n+++ b/src/plone/restapi/tests/test_statictime.py\n@@ -85,28 +85,32 @@ def assert_roughly_now(self, dt):\n         self.assertTrue(\n             lower < pydt < upper,\n             "Expected %r to be now (within +/- %r). "\n-            "It\'s currently %s though, and the date time is off by %r" % (\n-                pydt, epsilon, now, now - pydt))\n+            "It\'s currently %s though, and the date time is off by %r"\n+            % (pydt, epsilon, now, now - pydt),\n+        )\n \n     def assert_of_same_type(self, fake_datetimes, real_datetimes):\n         for fake, real in zip(fake_datetimes, real_datetimes):\n             # Guard against accidentally comparing the same objects\n             self.assertNotEqual(fake, real)\n-            self.assertIsInstance(fake, real.__class__,\n-                                  "Faked static time %r is of a different "\n-                                  "type than the real %r" % (fake, real))\n+            self.assertIsInstance(\n+                fake,\n+                real.__class__,\n+                "Faked static time %r is of a different "\n+                "type than the real %r" % (fake, real),\n+            )\n \n     def test_statictime_dxcontent_created(self):\n         frozen_time = datetime(1950, 7, 31, 13, 45)\n         statictime = StaticTime(created=frozen_time)\n \n         statictime.start()\n-        doc1 = self.create_document(\'doc1\')\n+        doc1 = self.create_document("doc1")\n         self.assertEqual(DateTime(frozen_time), doc1.creation_date)\n         fake_datetimes = [doc1.creation_date]\n \n         statictime.stop()\n-        doc2 = self.create_document(\'doc2\')\n+        doc2 = self.create_document("doc2")\n         self.assert_roughly_now(doc2.creation_date)\n         real_datetimes = [doc2.creation_date]\n \n@@ -117,12 +121,12 @@ def test_statictime_dxcontent_modified(self):\n         statictime = StaticTime(modified=frozen_time)\n \n         statictime.start()\n-        doc1 = self.create_document(\'doc1\')\n+        doc1 = self.create_document("doc1")\n         self.assertEqual(DateTime(frozen_time), doc1.modification_date)\n         fake_datetimes = [doc1.modification_date]\n \n         statictime.stop()\n-        doc2 = self.create_document(\'doc2\')\n+        doc2 = self.create_document("doc2")\n         self.assert_roughly_now(doc2.modification_date)\n         real_datetimes = [doc2.modification_date]\n \n@@ -133,13 +137,13 @@ def test_statictime_comment_created(self):\n         statictime = StaticTime(created=frozen_time)\n \n         statictime.start()\n-        doc1 = self.create_document(\'doc1\')\n+        doc1 = self.create_document("doc1")\n         comments = self.create_comments(doc1)\n         self.assertEqual(frozen_time, comments[0].creation_date)\n         fake_datetimes = [comments[0].creation_date]\n \n         statictime.stop()\n-        doc2 = self.create_document(\'doc2\')\n+        doc2 = self.create_document("doc2")\n         comments = self.create_comments(doc2)\n         self.assert_roughly_now(comments[0].creation_date)\n         real_datetimes = [comments[0].creation_date]\n@@ -151,13 +155,13 @@ def test_statictime_comment_modified(self):\n         statictime = StaticTime(modified=frozen_time)\n \n         statictime.start()\n-        doc1 = self.create_document(\'doc1\')\n+        doc1 = self.create_document("doc1")\n         comments = self.create_comments(doc1)\n         self.assertEqual(frozen_time, comments[0].modification_date)\n         fake_datetimes = [comments[0].modification_date]\n \n         statictime.stop()\n-        doc2 = self.create_document(\'doc2\')\n+        doc2 = self.create_document("doc2")\n         comments = self.create_comments(doc2)\n         self.assert_roughly_now(comments[0].modification_date)\n         real_datetimes = [comments[0].modification_date]\n@@ -166,28 +170,27 @@ def test_statictime_comment_modified(self):\n \n     def test_statictime_get_info_for(self):\n         frozen_time = datetime(1950, 7, 31, 17, 30)\n-        wftool = api.portal.get_tool(\'portal_workflow\')\n+        wftool = api.portal.get_tool("portal_workflow")\n         statictime = StaticTime(modified=frozen_time)\n \n         statictime.start()\n-        doc1 = self.create_document(\'doc1\')\n-        api.content.transition(doc1, \'publish\')\n+        doc1 = self.create_document("doc1")\n+        api.content.transition(doc1, "publish")\n \n-        history = wftool.getInfoFor(doc1, \'review_history\')\n+        history = wftool.getInfoFor(doc1, "review_history")\n \n-        fake_datetimes = list(map(itemgetter(\'time\'), history))\n+        fake_datetimes = list(map(itemgetter("time"), history))\n         self.assertEqual(\n             fake_datetimes,\n-            [DateTime(\'1950/07/31 17:30:00 UTC\'),\n-             DateTime(\'1950/07/31 18:30:00 UTC\')]\n+            [DateTime("1950/07/31 17:30:00 UTC"), DateTime("1950/07/31 18:30:00 UTC")],\n         )\n \n         statictime.stop()\n-        doc2 = self.create_document(\'doc2\')\n-        api.content.transition(doc2, \'publish\')\n+        doc2 = self.create_document("doc2")\n+        api.content.transition(doc2, "publish")\n \n-        history = wftool.getInfoFor(doc2, \'review_history\')\n-        real_datetimes = list(map(itemgetter(\'time\'), history))\n+        history = wftool.getInfoFor(doc2, "review_history")\n+        real_datetimes = list(map(itemgetter("time"), history))\n         for ts in real_datetimes:\n             self.assert_roughly_now(ts)\n \n@@ -198,7 +201,7 @@ def test_statictime_full_history(self):\n         statictime = StaticTime(modified=frozen_time)\n \n         statictime.start()\n-        doc1 = self.create_document(\'doc1\')\n+        doc1 = self.create_document("doc1")\n         doc1.setTitle("Current version")\n         api.content.transition(doc1, "publish")\n         viewlet = ContentHistoryViewlet(doc1, doc1.REQUEST, None)\n@@ -206,16 +209,18 @@ def test_statictime_full_history(self):\n \n         history = viewlet.fullHistory()\n \n-        real_datetimes = list(map(itemgetter(\'time\'), history))\n+        real_datetimes = list(map(itemgetter("time"), history))\n         self.assertEqual(\n             real_datetimes,\n-            [DateTime(\'1950/07/31 17:30:00 UTC\'),\n-             -612855000.0,\n-             DateTime(\'1950/07/31 19:30:00 UTC\')]\n+            [\n+                DateTime("1950/07/31 17:30:00 UTC"),\n+                -612855000.0,\n+                DateTime("1950/07/31 19:30:00 UTC"),\n+            ],\n         )\n \n         statictime.stop()\n-        doc2 = self.create_document(\'doc2\')\n+        doc2 = self.create_document("doc2")\n         doc2.setTitle("Current version")\n         api.content.transition(doc2, "publish")\n         viewlet = ContentHistoryViewlet(doc2, doc2.REQUEST, None)\n@@ -223,7 +228,7 @@ def test_statictime_full_history(self):\n \n         history = viewlet.fullHistory()\n \n-        fake_datetimes = list(map(itemgetter(\'time\'), history))\n+        fake_datetimes = list(map(itemgetter("time"), history))\n         for ts in fake_datetimes:\n             self.assert_roughly_now(ts)\n \n@@ -233,7 +238,7 @@ def test_statictime_lockinfo(self):\n         frozen_time = datetime(1950, 7, 31, 17, 30)\n         statictime = StaticTime(modified=frozen_time)\n \n-        doc1 = self.create_document(\'doc1\')\n+        doc1 = self.create_document("doc1")\n         alsoProvides(doc1, ITTWLockable)\n         lockable = ILockable(doc1)\n         lockable.lock()\n@@ -241,13 +246,13 @@ def test_statictime_lockinfo(self):\n         statictime.start()\n         lock_infos = lockable.lock_info()\n         self.assertEqual(1, len(lock_infos))\n-        self.assertEqual(-612858600.0, lock_infos[0][\'time\'])\n-        fake_datetimes = [lock_infos[0][\'time\']]\n+        self.assertEqual(-612858600.0, lock_infos[0]["time"])\n+        fake_datetimes = [lock_infos[0]["time"]]\n \n         statictime.stop()\n         lock_infos = lockable.lock_info()\n         self.assertEqual(1, len(lock_infos))\n-        self.assert_roughly_now(lock_infos[0][\'time\'])\n-        real_datetimes = [lock_infos[0][\'time\']]\n+        self.assert_roughly_now(lock_infos[0]["time"])\n+        real_datetimes = [lock_infos[0]["time"]]\n \n         self.assert_of_same_type(fake_datetimes, real_datetimes)\ndiff --git a/src/plone/restapi/tests/test_types.py b/src/plone/restapi/tests/test_types.py\nindex bf82475a..5f2cc5e2 100644\n--- a/src/plone/restapi/tests/test_types.py\n+++ b/src/plone/restapi/tests/test_types.py\n@@ -374,7 +374,7 @@ def test_choice(self):\n                 "enum": ["foo", "bar"],\n                 "enumNames": ["Foo", "Bar"],\n                 "choices": [("foo", "Foo"), ("bar", "Bar")],\n-                \'vocabulary\': {\'@id\': \'http://nohost/plone/@sources/myfield\'},\n+                "vocabulary": {"@id": "http://nohost/plone/@sources/myfield"},\n             },\n             adapter.get_schema(),\n         )\n@@ -420,7 +420,7 @@ def test_choice_source_vocab(self):\n                 "enum": ["foo", "bar"],\n                 "enumNames": ["Foo", "Bar"],\n                 "choices": [("foo", "Foo"), ("bar", "Bar")],\n-                "vocabulary": {\'@id\': \'http://nohost/plone/@sources/myfield\'},\n+                "vocabulary": {"@id": "http://nohost/plone/@sources/myfield"},\n             },\n             adapter.get_schema(),\n         )\n@@ -519,7 +519,7 @@ def test_collection(self):\n                     "enum": ["foo", "bar"],\n                     "enumNames": ["Foo", "Bar"],\n                     "choices": [("foo", "Foo"), ("bar", "Bar")],\n-                    \'vocabulary\': {\'@id\': \'http://nohost/plone/@sources/\'},\n+                    "vocabulary": {"@id": "http://nohost/plone/@sources/"},\n                 },\n             },\n             adapter.get_schema(),\ndiff --git a/src/plone/restapi/types/adapters.py b/src/plone/restapi/types/adapters.py\nindex 5ec9a837..09612e06 100644\n--- a/src/plone/restapi/types/adapters.py\n+++ b/src/plone/restapi/types/adapters.py\n@@ -299,10 +299,7 @@ def additional(self):\n                 enum.append(term.token)\n                 enum_names.append(title)\n \n-            result.update(\n-                {"enum": enum,\n-                 "enumNames": enum_names,\n-                 "choices": choices})\n+            result.update({"enum": enum, "enumNames": enum_names, "choices": choices})\n \n         return result\n \ndiff --git a/src/plone/restapi/types/utils.py b/src/plone/restapi/types/utils.py\nindex 3dd562d5..92cf026d 100644\n--- a/src/plone/restapi/types/utils.py\n+++ b/src/plone/restapi/types/utils.py\n@@ -205,16 +205,16 @@ def get_vocab_like_url(endpoint, locator, context, request):\n     except AttributeError:\n         portal = getSite()\n         context_url = portal.absolute_url()\n-    return \'/\'.join((context_url, endpoint, locator))\n+    return "/".join((context_url, endpoint, locator))\n \n \n def get_vocabulary_url(vocab_name, context, request):\n-    return get_vocab_like_url(\'@vocabularies\', vocab_name, context, request)\n+    return get_vocab_like_url("@vocabularies", vocab_name, context, request)\n \n \n def get_querysource_url(field, context, request):\n-    return get_vocab_like_url(\'@querysources\', field.getName(), context, request)\n+    return get_vocab_like_url("@querysources", field.getName(), context, request)\n \n \n def get_source_url(field, context, request):\n-    return get_vocab_like_url(\'@sources\', field.getName(), context, request)\n+    return get_vocab_like_url("@sources", field.getName(), context, request)\n'

