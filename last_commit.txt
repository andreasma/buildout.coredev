Repository: plone.app.contentrules


Branch: refs/heads/master
Date: 2019-10-29T12:36:19+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/adebc95ee9c3f3309a42947e15c34b80d4608e4d

fix genericsetup export of properties of rules that have more complex fields such as IDict.

Files changed:
A news/50.bugfix
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/news/50.bugfix b/news/50.bugfix\nnew file mode 100644\nindex 0000000..8ccab66\n--- /dev/null\n+++ b/news/50.bugfix\n@@ -0,0 +1 @@\n+fix genericsetup export of properties of rules that have more complex fields such as IDict.\n\\ No newline at end of file\ndiff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex 821084d..d0588e6 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -26,6 +26,9 @@\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n+from plone.supermodel.utils import elementToValue, valueToElement\n+from lxml import etree\n+from xml.dom import minidom\n \n \n import six\n@@ -81,25 +84,9 @@ def import_node(self, interface, child):\n             return\n \n         field = field.bind(self.element)\n-        value = None\n-\n-        # If we have a collection, we need to look at the value_type.\n-        # We look for <element>value</element> child nodes and get the\n-        # value from there\n-        if ICollection.providedBy(field):\n-            value_type = field.value_type\n-            value = []\n-            for element in child.childNodes:\n-                if element.nodeName != \'element\':\n-                    continue\n-                element_value = self.extract_text(element)\n-                value.append(self.from_unicode(value_type, element_value))\n-            value = self.field_typecast(field, value)\n+        child = etree.fromstring(child.toxml())\n \n-        # Otherwise, just get the value of the <property /> node\n-        else:\n-            value = self.extract_text(child)\n-            value = self.from_unicode(field, value)\n+        value = elementToValue(field, child)\n \n         field.validate(value)\n         field.set(self.element, value)\n@@ -113,54 +100,16 @@ def export_field(self, doc, field):\n \n         child = doc.createElement(\'property\')\n         child.setAttribute(\'name\', field.__name__)\n-\n-        if value is not None:\n-            if ICollection.providedBy(field):\n-                for e in sorted(value):\n-                    list_element = doc.createElement(\'element\')\n-                    list_element.appendChild(doc.createTextNode(str(e)))\n-                    child.appendChild(list_element)\n-            else:\n-                child.appendChild(doc.createTextNode(six.text_type(value)))\n-\n+        \n+        node = valueToElement(field, value)\n+        if node.text:\n+            child.appendChild(doc.createTextNode(six.text_type(node.text)))\n+        # Assumes there are not other text nodes and we can throw away the parent node    \n+        for node in node.iterchildren():\n+            xml = etree.tostring(node).decode()\n+            child.appendChild(minidom.parseString(xml).firstChild)\n         return child\n \n-    def extract_text(self, node):\n-        node.normalize()\n-        text = u\'\'\n-        for child in node.childNodes:\n-            if child.nodeType == node.TEXT_NODE:\n-                text += child.nodeValue\n-        return text\n-\n-    def from_unicode(self, field, value):\n-\n-        # XXX: Bool incorrectly omits to declare that it implements\n-        # IFromUnicode, even though it does.\n-        import zope.schema\n-        if (\n-            IFromUnicode.providedBy(field) or\n-            isinstance(field, zope.schema.Bool)\n-        ):\n-            return field.fromUnicode(value)\n-        else:\n-            return self.field_typecast(field, value)\n-\n-    def field_typecast(self, field, value):\n-        # A slight hack to force sequence types to the right type\n-        typecast = getattr(field, \'_type\', None)\n-        if typecast is not None:\n-            if not isinstance(typecast, (list, tuple)):\n-                typecast = (typecast, )\n-            for tc in reversed(typecast):\n-                if callable(tc):\n-                    try:\n-                        value = tc(value)\n-                        break\n-                    except Exception:\n-                        pass\n-        return value\n-\n \n @adapter(ISiteRoot, ISetupEnviron)\n @implementer(IBody)\ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 2bb73b5..c28ba14 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -118,8 +118,8 @@ def testExport(self):\n   <conditions>\n    <condition type="plone.conditions.PortalType">\n     <property name="check_types">\n-     <element>Document</element>\n      <element>News Item</element>\n+     <element>Document</element>\n     </property>\n    </condition>\n    <condition type="plone.conditions.Role">\n'

Repository: plone.app.contentrules


Branch: refs/heads/master
Date: 2019-10-29T14:09:25+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/22b70489f3981b1555950c3c9362160ed7bd85db

try to fix unicode errors during export

Files changed:
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex d0588e6..41235fd 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -106,7 +106,7 @@ def export_field(self, doc, field):\n             child.appendChild(doc.createTextNode(six.text_type(node.text)))\n         # Assumes there are not other text nodes and we can throw away the parent node    \n         for node in node.iterchildren():\n-            xml = etree.tostring(node).decode()\n+            xml = etree.tostring(node, encoding="utf8")\n             child.appendChild(minidom.parseString(xml).firstChild)\n         return child\n \ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex c28ba14..2bb73b5 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -118,8 +118,8 @@ def testExport(self):\n   <conditions>\n    <condition type="plone.conditions.PortalType">\n     <property name="check_types">\n-     <element>News Item</element>\n      <element>Document</element>\n+     <element>News Item</element>\n     </property>\n    </condition>\n    <condition type="plone.conditions.Role">\n'

Repository: plone.app.contentrules


Branch: refs/heads/master
Date: 2019-10-29T15:06:24+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/fae615bb1d35ba75860b087b595937f5df2b5ee3

remove random failures

Files changed:
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 2bb73b5..f564242 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -109,6 +109,18 @@ def testExport(self):\n         exporter = getMultiAdapter(\n             (site, context), IBody, name=u\'plone.contentrules\')\n \n+        body = exporter.body.decode(\'utf8\')\n+\n+        # There is a bug in supermodel such that Set fields can be exported in a random order\n+        body = body.replace("""\n+     <element>News Item</element>\n+     <element>Document</element>\n+""","""\n+     <element>Document</element>\n+     <element>News Item</element>\n+"""\n+        )\n+\n         expected = u"""<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n  <rule name="test1" title="Test rule 1" cascading="False"\n@@ -206,5 +218,5 @@ def testExport(self):\n </contentrules>\n """\n \n-        body = exporter.body.decode(\'utf8\')\n-        self.assertEqual(expected.strip(), body.strip(), body)\n+        \n+        self.assertEqual(expected.strip(), body.strip())\n'

Repository: plone.app.contentrules


Branch: refs/heads/master
Date: 2019-10-30T09:55:20+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/135048b5b66939fd946773be31fa4e4b04f72202

Put in comments about conversion minidom&lt;&gt;lxml

Files changed:
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/profiles/testing/contentrules.xml
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex 41235fd..f26fa4d 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -84,6 +84,7 @@ def import_node(self, interface, child):\n             return\n \n         field = field.bind(self.element)\n+        # child is minidom but supermodel needs an etree node so we need to convert it\n         child = etree.fromstring(child.toxml())\n \n         value = elementToValue(field, child)\n@@ -100,7 +101,8 @@ def export_field(self, doc, field):\n \n         child = doc.createElement(\'property\')\n         child.setAttribute(\'name\', field.__name__)\n-        \n+\n+        # supermodel gives us an etree node but GS uses minidom so we need to convert it\n         node = valueToElement(field, value)\n         if node.text:\n             child.appendChild(doc.createTextNode(six.text_type(node.text)))\ndiff --git a/plone/app/contentrules/tests/profiles/testing/contentrules.xml b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\nindex af08103..9446c81 100644\n--- a/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n+++ b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n \n     <rule\ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex f564242..885cd7a 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -217,6 +217,5 @@ def testExport(self):\n  <assignment name="test3" bubbles="False" enabled="False" location="/news"/>\n </contentrules>\n """\n-\n-        \n+     \n         self.assertEqual(expected.strip(), body.strip())\n'

Repository: plone.app.contentrules


Branch: refs/heads/master
Date: 2019-10-30T11:07:52+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/019c2c437b261869e7f7c900253f83ad0b6ec67a

add in code to ensure utf8 encoding

Files changed:
M plone/app/contentrules/exportimport/rules.py

b"diff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex f26fa4d..6dda435 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -365,5 +365,9 @@ def exportRules(context):\n     if exporter is not None:\n         filename = '{0}{1}'.format(exporter.name, exporter.suffix)\n         body = exporter.body\n+        # make sure it's encoded as earlier version of GS didn't do this\n+        if isinstance(body, six.text_type):\n+            encoding = context.getEncoding() or 'utf-8'\n+            body = body.encode(encoding)\n         if body is not None:\n             context.writeDataFile(filename, body, exporter.mime_type)\n"

Repository: plone.app.contentrules


Branch: refs/heads/master
Date: 2019-11-03T18:34:55+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.contentrules/commit/2e6516191f8a80f24696de80c7b0ac63cbcbd2f5

Merge pull request #51 from plone/fix_complex_export

fix genericsetup export with complex properties

Files changed:
A news/50.bugfix
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/profiles/testing/contentrules.xml
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/news/50.bugfix b/news/50.bugfix\nnew file mode 100644\nindex 0000000..8ccab66\n--- /dev/null\n+++ b/news/50.bugfix\n@@ -0,0 +1 @@\n+fix genericsetup export of properties of rules that have more complex fields such as IDict.\n\\ No newline at end of file\ndiff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex 821084d..6dda435 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -26,6 +26,9 @@\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n+from plone.supermodel.utils import elementToValue, valueToElement\n+from lxml import etree\n+from xml.dom import minidom\n \n \n import six\n@@ -81,25 +84,10 @@ def import_node(self, interface, child):\n             return\n \n         field = field.bind(self.element)\n-        value = None\n-\n-        # If we have a collection, we need to look at the value_type.\n-        # We look for <element>value</element> child nodes and get the\n-        # value from there\n-        if ICollection.providedBy(field):\n-            value_type = field.value_type\n-            value = []\n-            for element in child.childNodes:\n-                if element.nodeName != \'element\':\n-                    continue\n-                element_value = self.extract_text(element)\n-                value.append(self.from_unicode(value_type, element_value))\n-            value = self.field_typecast(field, value)\n+        # child is minidom but supermodel needs an etree node so we need to convert it\n+        child = etree.fromstring(child.toxml())\n \n-        # Otherwise, just get the value of the <property /> node\n-        else:\n-            value = self.extract_text(child)\n-            value = self.from_unicode(field, value)\n+        value = elementToValue(field, child)\n \n         field.validate(value)\n         field.set(self.element, value)\n@@ -114,53 +102,16 @@ def export_field(self, doc, field):\n         child = doc.createElement(\'property\')\n         child.setAttribute(\'name\', field.__name__)\n \n-        if value is not None:\n-            if ICollection.providedBy(field):\n-                for e in sorted(value):\n-                    list_element = doc.createElement(\'element\')\n-                    list_element.appendChild(doc.createTextNode(str(e)))\n-                    child.appendChild(list_element)\n-            else:\n-                child.appendChild(doc.createTextNode(six.text_type(value)))\n-\n+        # supermodel gives us an etree node but GS uses minidom so we need to convert it\n+        node = valueToElement(field, value)\n+        if node.text:\n+            child.appendChild(doc.createTextNode(six.text_type(node.text)))\n+        # Assumes there are not other text nodes and we can throw away the parent node    \n+        for node in node.iterchildren():\n+            xml = etree.tostring(node, encoding="utf8")\n+            child.appendChild(minidom.parseString(xml).firstChild)\n         return child\n \n-    def extract_text(self, node):\n-        node.normalize()\n-        text = u\'\'\n-        for child in node.childNodes:\n-            if child.nodeType == node.TEXT_NODE:\n-                text += child.nodeValue\n-        return text\n-\n-    def from_unicode(self, field, value):\n-\n-        # XXX: Bool incorrectly omits to declare that it implements\n-        # IFromUnicode, even though it does.\n-        import zope.schema\n-        if (\n-            IFromUnicode.providedBy(field) or\n-            isinstance(field, zope.schema.Bool)\n-        ):\n-            return field.fromUnicode(value)\n-        else:\n-            return self.field_typecast(field, value)\n-\n-    def field_typecast(self, field, value):\n-        # A slight hack to force sequence types to the right type\n-        typecast = getattr(field, \'_type\', None)\n-        if typecast is not None:\n-            if not isinstance(typecast, (list, tuple)):\n-                typecast = (typecast, )\n-            for tc in reversed(typecast):\n-                if callable(tc):\n-                    try:\n-                        value = tc(value)\n-                        break\n-                    except Exception:\n-                        pass\n-        return value\n-\n \n @adapter(ISiteRoot, ISetupEnviron)\n @implementer(IBody)\n@@ -414,5 +365,9 @@ def exportRules(context):\n     if exporter is not None:\n         filename = \'{0}{1}\'.format(exporter.name, exporter.suffix)\n         body = exporter.body\n+        # make sure it\'s encoded as earlier version of GS didn\'t do this\n+        if isinstance(body, six.text_type):\n+            encoding = context.getEncoding() or \'utf-8\'\n+            body = body.encode(encoding)\n         if body is not None:\n             context.writeDataFile(filename, body, exporter.mime_type)\ndiff --git a/plone/app/contentrules/tests/profiles/testing/contentrules.xml b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\nindex af08103..9446c81 100644\n--- a/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n+++ b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n \n     <rule\ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 2bb73b5..885cd7a 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -109,6 +109,18 @@ def testExport(self):\n         exporter = getMultiAdapter(\n             (site, context), IBody, name=u\'plone.contentrules\')\n \n+        body = exporter.body.decode(\'utf8\')\n+\n+        # There is a bug in supermodel such that Set fields can be exported in a random order\n+        body = body.replace("""\n+     <element>News Item</element>\n+     <element>Document</element>\n+""","""\n+     <element>Document</element>\n+     <element>News Item</element>\n+"""\n+        )\n+\n         expected = u"""<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n  <rule name="test1" title="Test rule 1" cascading="False"\n@@ -205,6 +217,5 @@ def testExport(self):\n  <assignment name="test3" bubbles="False" enabled="False" location="/news"/>\n </contentrules>\n """\n-\n-        body = exporter.body.decode(\'utf8\')\n-        self.assertEqual(expected.strip(), body.strip(), body)\n+     \n+        self.assertEqual(expected.strip(), body.strip())\n'

