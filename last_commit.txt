Repository: plone.versioncheck


Branch: refs/heads/master
Date: 2019-03-08T11:39:57+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.versioncheck/commit/f8470943fe418cea7fcc1ccd3329fe0c07ea4af7

fix to use new pypi url and fix logging

Files changed:
M CHANGES.rst
M src/plone/__init__.py
M src/plone/versioncheck/analyser.py
M src/plone/versioncheck/formatter.py
M src/plone/versioncheck/parser.py
M src/plone/versioncheck/pypi.py
M src/plone/versioncheck/script.py
M src/plone/versioncheck/tracking.py
M src/plone/versioncheck/utils.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 784934e..4bcb2ae 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -4,7 +4,8 @@ Changelog\n 1.6.11 (unreleased)\n -------------------\n \n-- Nothing changed yet.\n+- Fix PyPI url and add output of URL in case of a problem.\n+  [jensens]\n \n \n 1.6.10 (2018-08-20)\ndiff --git a/src/plone/__init__.py b/src/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/src/plone/__init__.py\n+++ b/src/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/src/plone/versioncheck/analyser.py b/src/plone/versioncheck/analyser.py\nindex a8bde45..cc07111 100644\n--- a/src/plone/versioncheck/analyser.py\n+++ b/src/plone/versioncheck/analyser.py\n@@ -14,7 +14,7 @@ def uptodate_analysis(pkginfo, pypiinfo):\n     """\n     result = []\n     if is_cfg_newer(pkginfo):\n-        result.append(\'cfg\')\n+        result.append("cfg")\n     newer = is_pypi_newer(pypiinfo)\n     if newer:\n         result.append(newer)\n@@ -28,7 +28,7 @@ def is_cfgidx_newer(pkginfo, target_idx):\n     """\n     vcur = None\n     for idx, key in enumerate(pkginfo):\n-        version = pkginfo[key][\'v\']\n+        version = pkginfo[key]["v"]\n         if not version:\n             continue\n         if idx == 0:\n@@ -48,14 +48,14 @@ def is_cfg_newer(pkginfo):\n             return True\n \n \n-TEST_FINALS = set([\'major\', \'minor\', \'bugfix\'])\n-TEST_PRERELEASE = set([\'majorpre\', \'minorpre\', \'bugfixpre\'])\n+TEST_FINALS = set(["major", "minor", "bugfix"])\n+TEST_PRERELEASE = set(["majorpre", "minorpre", "bugfixpre"])\n \n \n def is_pypi_newer(pypiinfo):\n     keys = {_ for _ in pypiinfo if pypiinfo.get(_, False)}\n     if TEST_FINALS.intersection(keys):\n-        return \'pypifinal\'\n+        return "pypifinal"\n     if TEST_PRERELEASE.intersection(keys):\n-        return \'pypiprerelease\'\n+        return "pypiprerelease"\n     return False\ndiff --git a/src/plone/versioncheck/formatter.py b/src/plone/versioncheck/formatter.py\nindex 3de0e9c..25f2aa0 100644\n--- a/src/plone/versioncheck/formatter.py\n+++ b/src/plone/versioncheck/formatter.py\n@@ -16,55 +16,54 @@\n import textwrap\n \n \n-jenv = Environment(loader=PackageLoader(\'plone.versioncheck\', \'tpl\'))\n+jenv = Environment(loader=PackageLoader("plone.versioncheck", "tpl"))\n \n \n def build_version(\n-    name,\n-    pkg,\n-    pypi,\n-    tracked,\n-    key,\n-    idx,\n-    flavor=\'versions\',\n-    orphaned=False,\n+    name, pkg, pypi, tracked, key, idx, flavor="versions", orphaned=False\n ):\n     record = {}\n-    if flavor == \'versions\':\n-        record[\'description\'] = key\n-        record[\'annotation\'] = pkg[key][\'a\'].strip()\n-        if pkg[key][\'v\'] is None:\n-            record[\'version\'] = \'(annotation)\'\n-            record[\'state\'] = \'\'\n+    if flavor == "versions":\n+        record["description"] = key\n+        record["annotation"] = pkg[key]["a"].strip()\n+        if pkg[key]["v"] is None:\n+            record["version"] = "(annotation)"\n+            record["state"] = ""\n             return record\n         else:\n-            record[\'version\'] = pkg[key][\'v\'] or \'(unset)\'\n-        if pkg[key].get(\'release_date\', datetime.date(1970, 1, 1)) != datetime.date(1970, 1, 1):  # NOQA: E501\n-            record[\'release_date\'] = pkg[key].get(\'release_date\')\n+            record["version"] = pkg[key]["v"] or "(unset)"\n+        if pkg[key].get(\n+            "release_date", datetime.date(1970, 1, 1)\n+        ) != datetime.date(\n+            1970, 1, 1\n+        ):  # NOQA: E501\n+            record["release_date"] = pkg[key].get("release_date")\n         if idx == 0:\n             if orphaned:\n-                record[\'state\'] = \'O\'\n+                record["state"] = "O"\n             elif tracked and tracked[1]:\n-                record[\'state\'] = \'I\'\n+                record["state"] = "I"\n             else:\n-                record[\'state\'] = \'A\'\n+                record["state"] = "A"\n         elif analyser.is_cfgidx_newer(pkg, idx):\n-            record[\'state\'] = \'In\'\n+            record["state"] = "In"\n         else:\n-            record[\'state\'] = \'I\'\n+            record["state"] = "I"\n     else:  # pypi\n-        record[\'version\'] = pypi[key].version\n-        record[\'release_date\'] = pypi[key].release_date\n-        record[\'description\'] = key.capitalize()\n-        record[\'annotation\'] = None\n-        if \'pre\' in key:\n-            record[\'state\'] = \'P\'\n+        record["version"] = pypi[key].version\n+        record["release_date"] = pypi[key].release_date\n+        record["description"] = key.capitalize()\n+        record["annotation"] = None\n+        if "pre" in key:\n+            record["state"] = "P"\n         else:\n-            record[\'state\'] = \'U\'\n+            record["state"] = "U"\n     return record\n \n \n-def builder(pkgsinfo, newer_only=False, newer_orphaned_only=False, limit=None):  # noqa: C901, E501\n+def builder(\n+    pkgsinfo, newer_only=False, newer_orphaned_only=False, limit=None\n+):  # noqa: C901, E501\n     """build\n     - OrderedDict with pkgname as keys\n     - each entry an record:\n@@ -76,20 +75,20 @@ def builder(pkgsinfo, newer_only=False, newer_orphaned_only=False, limit=None):\n     """\n     result = OrderedDict()\n     ver_maxlen = 0\n-    pkgs = pkgsinfo[\'pkgs\']\n-    pypi = pkgsinfo.get(\'pypi\', {})\n-    tracked = pkgsinfo.get(\'tracking\', {}).get(\'versions\', {})\n-    requ = pkgsinfo.get(\'tracking\', {}).get(\'required_by\', {})\n+    pkgs = pkgsinfo["pkgs"]\n+    pypi = pkgsinfo.get("pypi", {})\n+    tracked = pkgsinfo.get("tracking", {}).get("versions", {})\n+    requ = pkgsinfo.get("tracking", {}).get("required_by", {})\n     names = sorted(set(tracked.keys()) | set(pkgs.keys()))\n \n     for nidx, name in enumerate(names):\n         current_pkg = pkgs.get(name, {})\n         record = dict()\n-        versions = record[\'versions\'] = list()\n+        versions = record["versions"] = list()\n         unpinned = False\n         required_by = requ.get(name, None)\n         if required_by:\n-            record[\'required_by\'] = required_by\n+            record["required_by"] = required_by\n \n         # handle dev-eggs\n         devegg = False\n@@ -97,12 +96,14 @@ def builder(pkgsinfo, newer_only=False, newer_orphaned_only=False, limit=None):\n         if current_tracked is not None:\n             ver_maxlen = max([ver_maxlen, len(current_tracked[0])])\n             if current_tracked[1]:\n-                versions.append({\n-                    \'version\': current_tracked[0],\n-                    \'state\': \'D\',\n-                    \'description\': current_tracked[1],\n-                    \'release_date\': \'\'\n-                })\n+                versions.append(\n+                    {\n+                        "version": current_tracked[0],\n+                        "state": "D",\n+                        "description": current_tracked[1],\n+                        "release_date": "",\n+                    }\n+                )\n                 devegg = True\n \n         # handle versions.cfg and inherited\n@@ -116,18 +117,24 @@ def builder(pkgsinfo, newer_only=False, newer_orphaned_only=False, limit=None):\n                     current_tracked,\n                     location,\n                     idx,\n-                    flavor=\'versions\',\n-                    orphaned=tracked and current_tracked is None and not devegg\n+                    flavor="versions",\n+                    orphaned=tracked\n+                    and current_tracked is None\n+                    and not devegg,\n                 )\n             )\n         if not devegg and current_tracked is not None and not len(versions):\n             ver_maxlen = max([ver_maxlen, len(current_tracked[0])])\n-            versions.append({\n-                \'version\': current_tracked[0],\n-                \'state\': \'X\',\n-                \'description\': \'unpinned\',\n-                \'release_date\': current_tracked[2] if len(current_tracked) >= 3 else \'\'  # NOQA: E501\n-            })\n+            versions.append(\n+                {\n+                    "version": current_tracked[0],\n+                    "state": "X",\n+                    "description": "unpinned",\n+                    "release_date": current_tracked[2]\n+                    if len(current_tracked) >= 3\n+                    else "",  # NOQA: E501\n+                }\n+            )\n             unpinned = True\n \n         if pypi.get(name, None) is not None:\n@@ -144,37 +151,34 @@ def builder(pkgsinfo, newer_only=False, newer_orphaned_only=False, limit=None):\n                         current_tracked,\n                         label,\n                         idx,\n-                        flavor=\'pypi\',\n+                        flavor="pypi",\n                     )\n                 )\n \n-        pkgsinfo[\'ver_maxlen\'] = ver_maxlen\n-        states = analyser.uptodate_analysis(\n-            current_pkg,\n-            pypi.get(name, {}),\n-        )\n+        pkgsinfo["ver_maxlen"] = ver_maxlen\n+        states = analyser.uptodate_analysis(current_pkg, pypi.get(name, {}))\n         if devegg:\n             # dev always wins - not true!\n-            record[\'state\'] = \'D\'\n+            record["state"] = "D"\n         elif unpinned:\n-            record[\'state\'] = \'X\'\n+            record["state"] = "X"\n         elif tracked and name in pkgs and name not in tracked:\n-            record[\'state\'] = \'O\'\n-        elif \'pypifinal\' in states:\n-            record[\'state\'] = \'U\'\n-        elif \'cfg\' in states:\n-            record[\'state\'] = \'In\'\n-        elif \'pypifinal\' in states:\n-            record[\'state\'] = \'P\'\n+            record["state"] = "O"\n+        elif "pypifinal" in states:\n+            record["state"] = "U"\n+        elif "cfg" in states:\n+            record["state"] = "In"\n+        elif "pypifinal" in states:\n+            record["state"] = "P"\n         else:\n-            record[\'state\'] = \'A\'\n+            record["state"] = "A"\n \n-        if newer_only and record[\'state\'] == \'A\':\n+        if newer_only and record["state"] == "A":\n             continue\n         if (\n-            newer_orphaned_only and\n-            record[\'versions\'][0][\'state\'] == \'O\' and\n-            len(record[\'versions\']) == 1\n+            newer_orphaned_only\n+            and record["versions"][0]["state"] == "O"\n+            and len(record["versions"]) == 1\n         ):\n             continue\n \n@@ -187,49 +191,51 @@ def human(\n     newer_only=False,\n     newer_orphaned_only=False,\n     limit=None,\n-    show_requiredby=False\n+    show_requiredby=False,\n ):\n     color_init()\n-    sys.stderr.write(\'\\nReport for humans\\n\\n\')\n+    sys.stderr.write("\\nReport for humans\\n\\n")\n     data = builder(\n         pkgsinfo,\n         newer_only=newer_only,\n         newer_orphaned_only=newer_orphaned_only,\n-        limit=limit\n+        limit=limit,\n     )\n     termx, termy = get_terminal_size()\n     for name, record in data.items():\n-        print(color_by_state(record[\'state\']) + name)\n-        for version in record[\'versions\']:\n+        print(color_by_state(record["state"]) + name)\n+        for version in record["versions"]:\n             print(\n-                \' \' * 4 +\n-                color_by_state(version[\'state\']) +\n-                version[\'version\'] +\n-                dots(version[\'version\'], pkgsinfo[\'ver_maxlen\']) +\n-                \' \' + color_by_state(version[\'state\']) +\n-                version[\'state\'][0] if version[\'state\'] else \'\' +\n-                \' \' + version[\'description\']\n+                " " * 4\n+                + color_by_state(version["state"])\n+                + version["version"]\n+                + dots(version["version"], pkgsinfo["ver_maxlen"])\n+                + " "\n+                + color_by_state(version["state"])\n+                + version["state"][0]\n+                if version["state"]\n+                else "" + " " + version["description"]\n             )\n-            if version.get(\'annotation\', None):\n-                indent = (pkgsinfo[\'ver_maxlen\'] + 5) * \' \' + \'a \'\n+            if version.get("annotation", None):\n+                indent = (pkgsinfo["ver_maxlen"] + 5) * " " + "a "\n                 print(\n-                    color_dimmed() +\n-                    textwrap.fill(\n-                        version[\'annotation\'],\n-                        termx - pkgsinfo[\'ver_maxlen\'],\n+                    color_dimmed()\n+                    + textwrap.fill(\n+                        version["annotation"],\n+                        termx - pkgsinfo["ver_maxlen"],\n                         initial_indent=indent,\n                         subsequent_indent=indent,\n                     )\n                 )\n \n-        if show_requiredby and record.get(\'required_by\', False):\n-            req = \' \'.join(sorted(record.get(\'required_by\')))\n-            indent = (pkgsinfo[\'ver_maxlen\'] + 5) * \' \' + \'r \'\n+        if show_requiredby and record.get("required_by", False):\n+            req = " ".join(sorted(record.get("required_by")))\n+            indent = (pkgsinfo["ver_maxlen"] + 5) * " " + "r "\n             print(\n-                color_dimmed() +\n-                textwrap.fill(\n+                color_dimmed()\n+                + textwrap.fill(\n                     req,\n-                    termx - pkgsinfo[\'ver_maxlen\'],\n+                    termx - pkgsinfo["ver_maxlen"],\n                     initial_indent=indent,\n                     subsequent_indent=indent,\n                 )\n@@ -242,7 +248,7 @@ def json_serial(obj):\n     if isinstance(obj, datetime.date):\n         serial = obj.isoformat()\n         return serial\n-    raise TypeError(\'Type not serializable\')\n+    raise TypeError("Type not serializable")\n \n \n def browser(\n@@ -252,22 +258,23 @@ def browser(\n     limit=None,\n     show_requiredby=False,\n     show_release_dates=False,\n-    file=sys.stdout\n+    file=sys.stdout,\n ):\n     color_init()\n-    sys.stderr.write(\'\\nReport for browsers\\n\\n\')\n+    sys.stderr.write("\\nReport for browsers\\n\\n")\n     data = builder(\n         pkgsinfo,\n         newer_only=newer_only,\n         newer_orphaned_only=newer_orphaned_only,\n-        limit=limit\n+        limit=limit,\n+    )\n+    template = jenv.get_template("browser.jinja")\n+    print(\n+        template.render(\n+            data=data, req_by=show_requiredby, rel_date=show_release_dates\n+        ),\n+        file=file,\n     )\n-    template = jenv.get_template(\'browser.jinja\')\n-    print(template.render(data=data,\n-                          req_by=show_requiredby,\n-                          rel_date=show_release_dates,\n-                          ),\n-          file=file)\n \n \n def machine(\n@@ -275,13 +282,13 @@ def machine(\n     newer_only=False,\n     newer_orphaned_only=False,\n     limit=None,\n-    file=sys.stdout\n+    file=sys.stdout,\n ):\n-    sys.stderr.write(\'\\nReport for machines\\n\\n\')\n+    sys.stderr.write("\\nReport for machines\\n\\n")\n     data = builder(\n         pkgsinfo,\n         newer_only=newer_only,\n         newer_orphaned_only=newer_orphaned_only,\n-        limit=limit\n+        limit=limit,\n     )\n     print(json.dumps(data, indent=4, default=json_serial), file=file)\ndiff --git a/src/plone/versioncheck/parser.py b/src/plone/versioncheck/parser.py\nindex 7095774..d7001f4 100644\n--- a/src/plone/versioncheck/parser.py\n+++ b/src/plone/versioncheck/parser.py\n@@ -39,7 +39,7 @@ def _extract_versions_section(  # NOQA: C901\n     annotations=None,\n     relative=None,\n     version_section_name=None,\n-    versionannotation_section_name=\'versionannotations\'\n+    versionannotation_section_name="versionannotations",\n ):\n     if base_dir is None:\n         base_dir = os.path.dirname(os.path.abspath(filename))\n@@ -47,44 +47,43 @@ def _extract_versions_section(  # NOQA: C901\n         version_sections = OrderedDict()\n     if annotations is None:\n         annotations = OrderedDict()\n-    if \'://\' not in filename:\n-        if relative and \'://\' in relative:\n+    if "://" not in filename:\n+        if relative and "://" in relative:\n             # relative to url!\n-            filename = \'{0}/{1}\'.format(relative, filename)\n+            filename = "{0}/{1}".format(relative, filename)\n         else:\n             if relative:\n-                if filename.startswith(relative + \'/\'):\n-                    filename = filename[len(relative + \'/\'):]\n+                if filename.startswith(relative + "/"):\n+                    filename = filename[len(relative + "/") :]\n                 filename = os.path.join(base_dir, relative, filename)\n             else:\n                 filename = os.path.join(base_dir, filename)\n \n-    sys.stderr.write(\'\\n- {0}\'.format(filename))\n+    sys.stderr.write("\\n- {0}".format(filename))\n \n     try:\n         with nostdout():\n             buildout = Buildout(filename, [])  # Use zc.buildout parser\n     except UserError:\n-        buildout = {\'buildout\': {}}\n+        buildout = {"buildout": {}}\n     config = ConfigParser()\n     if os.path.isfile(filename):\n         config.read(filename)\n-    elif \'://\' in filename:\n+    elif "://" in filename:\n         resp = session.get(filename)\n         config.readfp(StringIO(resp.text))\n         if resp.from_cache:\n-            sys.stderr.write(\'\\n  from cache\')\n+            sys.stderr.write("\\n  from cache")\n         elif resp.status_code != 200:\n-            sys.stderr.write(\'\\n  ERROR {0:d}\'.format(resp.status_code))\n+            sys.stderr.write("\\n  ERROR {0:d}".format(resp.status_code))\n         else:\n-            sys.stderr.write(\'\\n  fresh from server\')\n+            sys.stderr.write("\\n  fresh from server")\n     else:\n-        raise ValueError(\'{0} does not exist!\'.format(filename))\n+        raise ValueError("{0} does not exist!".format(filename))\n \n     # first read own versions section\n-    current_version_section_name = buildout[\'buildout\'].get(\n-        \'versions\',\n-        \'versions\',\n+    current_version_section_name = buildout["buildout"].get(\n+        "versions", "versions"\n     )\n     if version_section_name is None:\n         # initial name\n@@ -92,15 +91,17 @@ def _extract_versions_section(  # NOQA: C901\n     elif version_section_name != current_version_section_name:\n         # name changed, not sure if this works as expected! - jensens\n         sys.stderr.write(\n-            \'\\nName of [versions] (versions = versions) has changed.\'\n+            "\\nName of [versions] (versions = versions) has changed."\n             \'\\nGlobal versions section name: "{gname}"\'\n             \'\\nVersions pinned under that new Section namespace "{nname}"\'\n-            \' will be ignored.\'.format(\n+            " will be ignored.".format(\n                 gname=version_section_name,\n-                nname=buildout[\'buildout\'].get(\'versions\')))\n+                nname=buildout["buildout"].get("versions"),\n+            )\n+        )\n \n     if filename.startswith(base_dir):\n-        key_name = filename[len(base_dir) + 1:]\n+        key_name = filename[len(base_dir) + 1 :]\n     else:\n         key_name = filename\n \n@@ -109,25 +110,26 @@ def _extract_versions_section(  # NOQA: C901\n             config.items(version_section_name)\n         )\n         sys.stderr.write(\n-            \'\\n  {0:d} entries in versions section.\'.format(\n+            "\\n  {0:d} entries in versions section.".format(\n                 len(version_sections[key_name])\n             )\n         )\n \n     # read versionannotations\n-    versionannotation_section_name = buildout[\'buildout\'].get(\n-        \'versionannotations\', versionannotation_section_name)\n+    versionannotation_section_name = buildout["buildout"].get(\n+        "versionannotations", versionannotation_section_name\n+    )\n     if config.has_section(versionannotation_section_name):\n         annotations[key_name] = OrderedDict(\n             config.items(versionannotation_section_name)\n         )\n         sys.stderr.write(\n-            \'\\n  {0:d} entries in annotations section.\'.format(\n+            "\\n  {0:d} entries in annotations section.".format(\n                 len(annotations[key_name])\n             )\n         )\n     try:\n-        extends = config.get(\'buildout\', \'extends\').strip()\n+        extends = config.get("buildout", "extends").strip()\n     except (NoSectionError, NoOptionError):\n         return version_sections, annotations\n     for extend in reversed(extends.splitlines()):\n@@ -143,23 +145,21 @@ def _extract_versions_section(  # NOQA: C901\n             annotations,\n             sub_relative,\n             version_section_name,\n-            versionannotation_section_name\n+            versionannotation_section_name,\n         )\n     return version_sections, annotations\n \n \n def parse(buildout_filename, nocache=False):\n-    sys.stderr.write(\'Parsing buildout files:\')\n+    sys.stderr.write("Parsing buildout files:")\n     if nocache:\n-        sys.stderr.write(\'\\n(not using caches)\')\n+        sys.stderr.write("\\n(not using caches)")\n     base_relative, buildout_filename = find_relative(buildout_filename)\n     session = requests_session(nocache=nocache)\n     version_sections, annotations = _extract_versions_section(\n-        session,\n-        buildout_filename,\n-        relative=base_relative\n+        session, buildout_filename, relative=base_relative\n     )\n-    sys.stderr.write(\'\\nparsing finished.\\n\')\n+    sys.stderr.write("\\nparsing finished.\\n")\n     pkgs = {}\n \n     for name in version_sections:\n@@ -171,13 +171,13 @@ def parse(buildout_filename, nocache=False):\n         pkg = pkgs[pkgname]\n         for name in version_sections.keys():\n             if pkgname in version_sections.get(name, {}):\n-                pkg[name] = {\'v\': version_sections[name][pkgname], \'a\': \'\'}\n+                pkg[name] = {"v": version_sections[name][pkgname], "a": ""}\n \n         for name in annotations.keys():\n             if pkgname in annotations.get(name, {}):\n                 if name in pkg:\n-                    pkg[name][\'a\'] = annotations[name][pkgname]\n+                    pkg[name]["a"] = annotations[name][pkgname]\n                 else:\n-                    pkg[name] = {\'v\': None, \'a\': annotations[name][pkgname]}\n+                    pkg[name] = {"v": None, "a": annotations[name][pkgname]}\n \n     return pkgs\ndiff --git a/src/plone/versioncheck/pypi.py b/src/plone/versioncheck/pypi.py\nindex 3d33170..95c4d49 100644\n--- a/src/plone/versioncheck/pypi.py\n+++ b/src/plone/versioncheck/pypi.py\n@@ -9,14 +9,13 @@\n import sys\n \n \n-PYPI_URL = \'https://pypi.python.org/pypi\'\n+PYPI_URL = "https://pypi.org"\n \n \n-Release = namedtuple(\'Release\', [\'version\', \'release_date\'])\n+Release = namedtuple("Release", ["version", "release_date"])\n \n FLOOR_RELEASE = Release(\n-    version=u\'0.0.0.0\',\n-    release_date=datetime.date(1970, 1, 1),\n+    version=u"0.0.0.0", release_date=datetime.date(1970, 1, 1)\n )\n \n \n@@ -28,182 +27,184 @@ def mmbp_tuple(version):\n     - 1.3.4   -> 1.3.4.0\n     - 1.3.4.5 -> 1.3.4.5\n     """\n-    parts = version.base_version.split(\'.\')\n-    parts += [\'0\'] * (4 - len(parts))\n+    parts = version.base_version.split(".")\n+    parts += ["0"] * (4 - len(parts))\n     return [int(_) for _ in parts]\n \n \n def check(name, version, session):  # noqa: C901\n-    result = OrderedDict([\n-        (\'major\', FLOOR_RELEASE),\n-        (\'minor\', FLOOR_RELEASE),\n-        (\'bugfix\', FLOOR_RELEASE),\n-        (\'majorpre\', FLOOR_RELEASE),\n-        (\'minorpre\', FLOOR_RELEASE),\n-        (\'bugfixpre\', FLOOR_RELEASE),\n-    ])\n+    result = OrderedDict(\n+        [\n+            ("major", FLOOR_RELEASE),\n+            ("minor", FLOOR_RELEASE),\n+            ("bugfix", FLOOR_RELEASE),\n+            ("majorpre", FLOOR_RELEASE),\n+            ("minorpre", FLOOR_RELEASE),\n+            ("bugfixpre", FLOOR_RELEASE),\n+        ]\n+    )\n \n     # parse version to test against:\n     try:\n         version = parse_version(version)\n     except TypeError:\n-        return False, \'Version broken/ not checkable.\'\n+        return False, "Version broken/ not checkable."\n     try:\n         vtuple = mmbp_tuple(version)\n     except ValueError:\n-        return False, \'Can not check legacy version number.\'\n+        return False, "Can not check legacy version number."\n \n     # fetch pkgs json info from pypi\n-    url = \'{url}/{name}/json\'.format(url=PYPI_URL, name=name)\n-    resp = session.get(url)\n+    url = "{url}/pypi/{name}/json".format(url=PYPI_URL, name=name)\n+    try:\n+        resp = session.get(url)\n+    except Exception:\n+        print("Fatal problem while fetching URL: {0}".format(url))\n+        raise\n \n     # check status code\n     if resp.status_code == 404:\n-        return False, \'Package "{name}" not on pypi.\'.format(name=name)\n+        return (\n+            False,\n+            \'Package "{name}" not on pypi ({url}).\'.format(name=name, url=url),\n+        )\n     elif resp.status_code != 200:\n         return False, str(resp.status_code)\n     data = resp.json()\n \n     # get information about possible updates\n-    releases = sorted(data[\'releases\'])\n+    releases = sorted(data["releases"])\n     for release in releases:\n         # major check (overall)\n         rel_v = parse_version(release)\n-#        if not isinstance(rel_v, SetuptoolsVersion) or not rel_v > version:\n         if rel_v <= version:\n             continue\n         rel_vtuple = mmbp_tuple(rel_v)\n-        rel_data = data[\'releases\'][release]\n+        rel_data = data["releases"][release]\n         rel_date = datetime.date(1970, 1, 1)\n         for rel_pkg in rel_data:\n-            time_string = rel_pkg.get(\'upload_time\')\n+            time_string = rel_pkg.get("upload_time")\n             if time_string:\n                 crel_date = datetime.datetime.strptime(\n-                    time_string, \'%Y-%m-%dT%H:%M:%S\').date()\n+                    time_string, "%Y-%m-%dT%H:%M:%S"\n+                ).date()\n                 if crel_date > rel_date:\n                     rel_date = crel_date\n         if rel_vtuple[0] > vtuple[0]:\n-            if (\n-                rel_v.is_prerelease and\n-                rel_v > parse_version(result[\'majorpre\'].version)\n+            if rel_v.is_prerelease and rel_v > parse_version(\n+                result["majorpre"].version\n             ):\n-                result[\'majorpre\'] = Release(version=release,\n-                                             release_date=rel_date)\n-            elif (\n-                not rel_v.is_prerelease and\n-                rel_v > parse_version(result[\'major\'].version)\n+                result["majorpre"] = Release(\n+                    version=release, release_date=rel_date\n+                )\n+            elif not rel_v.is_prerelease and rel_v > parse_version(\n+                result["major"].version\n             ):\n-                result[\'major\'] = Release(version=release,\n-                                          release_date=rel_date)\n+                result["major"] = Release(\n+                    version=release, release_date=rel_date\n+                )\n             continue\n         if (  # Only compare same version line\n-            rel_vtuple[0] == vtuple[0] and\n-            rel_vtuple[1] > vtuple[1]\n+            rel_vtuple[0] == vtuple[0] and rel_vtuple[1] > vtuple[1]\n         ):\n-            if (\n-                rel_v.is_prerelease and\n-                rel_v > parse_version(result[\'minorpre\'].version)\n+            if rel_v.is_prerelease and rel_v > parse_version(\n+                result["minorpre"].version\n             ):\n-                result[\'minorpre\'] = Release(version=release,\n-                                             release_date=rel_date)\n-            elif (\n-                not rel_v.is_prerelease and\n-                rel_v > parse_version(result[\'minor\'].version)\n+                result["minorpre"] = Release(\n+                    version=release, release_date=rel_date\n+                )\n+            elif not rel_v.is_prerelease and rel_v > parse_version(\n+                result["minor"].version\n             ):\n-                result[\'minor\'] = Release(version=release,\n-                                          release_date=rel_date)\n+                result["minor"] = Release(\n+                    version=release, release_date=rel_date\n+                )\n             continue\n         if (  # Only compare same version line\n-            rel_vtuple[0] == vtuple[0] and\n-            rel_vtuple[1] == vtuple[1] and\n-            rel_vtuple[2] > vtuple[2]\n+            rel_vtuple[0] == vtuple[0]\n+            and rel_vtuple[1] == vtuple[1]\n+            and rel_vtuple[2] > vtuple[2]\n         ):\n-            if (\n-                rel_v.is_prerelease and\n-                rel_v > parse_version(result[\'bugfixpre\'].version)\n+            if rel_v.is_prerelease and rel_v > parse_version(\n+                result["bugfixpre"].version\n             ):\n-                result[\'bugfixpre\'] = Release(version=release,\n-                                              release_date=rel_date)\n-            elif (\n-                not rel_v.is_prerelease and\n-                rel_v > parse_version(result[\'bugfix\'].version)\n+                result["bugfixpre"] = Release(\n+                    version=release, release_date=rel_date\n+                )\n+            elif not rel_v.is_prerelease and rel_v > parse_version(\n+                result["bugfix"].version\n             ):\n-                    result[\'bugfix\'] = Release(version=release,\n-                                               release_date=rel_date)\n+                result["bugfix"] = Release(\n+                    version=release, release_date=rel_date\n+                )\n             continue\n \n     # reset non existing versions\n     for version_tag in result.keys():\n-        if result[version_tag].version == u\'0.0.0.0\':\n+        if result[version_tag].version == u"0.0.0.0":\n             result[version_tag] = None\n \n     # filter out older\n     if (\n-        result[\'major\'] and\n-        result[\'majorpre\'] and\n-        parse_version(result[\'majorpre\'].version) <\n-            parse_version(result[\'major\'].version)\n+        result["major"]\n+        and result["majorpre"]\n+        and parse_version(result["majorpre"].version)\n+        < parse_version(result["major"].version)\n     ):\n-        result[\'majorpre\'] = None\n+        result["majorpre"] = None\n     if (\n-        result[\'minor\'] and\n-        result[\'minorpre\'] and\n-        parse_version(result[\'minorpre\'].version) <\n-            parse_version(result[\'minor\'].version)\n+        result["minor"]\n+        and result["minorpre"]\n+        and parse_version(result["minorpre"].version)\n+        < parse_version(result["minor"].version)\n     ):\n-        result[\'minorpre\'] = None\n+        result["minorpre"] = None\n     if (\n-        result[\'bugfix\'] and\n-        result[\'bugfixpre\'] and\n-        parse_version(result[\'bugfixpre\'].version) <\n-            parse_version(result[\'bugfix\'].version)\n+        result["bugfix"]\n+        and result["bugfixpre"]\n+        and parse_version(result["bugfixpre"].version)\n+        < parse_version(result["bugfix"].version)\n     ):\n-        result[\'bugfixpre\'] = None\n+        result["bugfixpre"] = None\n \n     return 2 if resp.from_cache else 1, result\n \n \n def check_all(pkgsinfo, limit=None, nocache=False):\n     session = requests_session(nocache=nocache)\n-    pkgs = pkgsinfo[\'pkgs\']\n+    pkgs = pkgsinfo["pkgs"]\n     sys.stderr.write(\n-        \'Check PyPI for updates of {0:d} packages.\'.format(len(pkgs))\n+        "Check PyPI for updates of {0:d} packages.".format(len(pkgs))\n     )\n     if limit:\n-        sys.stderr.write(\' Check limited to {0:d} packages.\'.format(limit))\n-    pkgsinfo[\'pypi\'] = {}\n+        sys.stderr.write(" Check limited to {0:d} packages.".format(limit))\n+    pkgsinfo["pypi"] = {}\n     errors = []\n     for idx, pkgname in enumerate(sorted(pkgs)):\n         if not idx % 20 and idx != limit:\n-            sys.stderr.write(\'\\n{0:4d} \'.format(idx))\n+            sys.stderr.write("\\n{0:4d} ".format(idx))\n         current = next(iter(pkgs[pkgname]))\n-        state, result = check(\n-            pkgname,\n-            pkgs[pkgname][current][\'v\'],\n-            session\n-        )\n+        state, result = check(pkgname, pkgs[pkgname][current]["v"], session)\n         if not state:\n-            sys.stderr.write(\'E\')\n-            errors.append((pkgname, pkgs[pkgname][current][\'v\'], str(result)))\n+            sys.stderr.write("E")\n+            errors.append((pkgname, pkgs[pkgname][current]["v"], str(result)))\n             continue\n-        pkgsinfo[\'pypi\'][pkgname] = result\n-        sys.stderr.write(\'O\' if state == 1 else \'o\')\n+        pkgsinfo["pypi"][pkgname] = result\n+        sys.stderr.write("O" if state == 1 else "o")\n         if limit and idx == limit:\n             break\n     for error in errors:\n         sys.stderr.write(\n-            \'\\nError in {0} version {1} reason: {2}\'.format(\n-                *error\n-            )\n+            "\\nError in {0} version {1} reason: {2}".format(*error)\n         )\n \n-    sys.stderr.write(\'\\nPyPI check finished\\n\')\n+    sys.stderr.write("\\nPyPI check finished\\n")\n \n \n def update_pkg_info(pkg_name, pkg_data, session):\n     for filename, elemdata in pkg_data.items():\n         # fetch pkgs json info from pypi\n-        url = \'{url}/{name}/json\'.format(url=PYPI_URL, name=pkg_name)\n+        url = "{url}/pypi/{name}/json".format(url=PYPI_URL, name=pkg_name)\n         resp = session.get(url)\n \n         # check status code\n@@ -213,78 +214,78 @@ def update_pkg_info(pkg_name, pkg_data, session):\n \n         rel_date = datetime.date(1970, 1, 1)\n         try:\n-            urls = data[\'releases\'][elemdata[\'v\']]\n+            urls = data["releases"][elemdata["v"]]\n         except KeyError:\n             # release not on PyPI\n             continue\n         for rel_pkg in urls:\n-            time_string = rel_pkg.get(\'upload_time\')\n+            time_string = rel_pkg.get("upload_time")\n             if time_string:\n                 crel_date = datetime.datetime.strptime(\n-                    time_string, \'%Y-%m-%dT%H:%M:%S\').date()\n+                    time_string, "%Y-%m-%dT%H:%M:%S"\n+                ).date()\n                 if crel_date > rel_date:\n                     rel_date = crel_date\n-        elemdata[\'release_date\'] = rel_date\n+        elemdata["release_date"] = rel_date\n \n     return True\n \n \n def update_pkgs_info(pkgsinfo, limit=None, nocache=False):\n     session = requests_session(nocache=nocache)\n-    pkgs = pkgsinfo[\'pkgs\']\n+    pkgs = pkgsinfo["pkgs"]\n     sys.stderr.write(\n-        \'Check PyPI for data of {0:d} packages.\'.format(len(pkgs))\n+        "Check PyPI for data of {0:d} packages.".format(len(pkgs))\n     )\n     if limit:\n-        sys.stderr.write(\' Check limited to {0:d} packages.\'.format(limit))\n+        sys.stderr.write(" Check limited to {0:d} packages.".format(limit))\n     errors = []\n \n     idx = 0\n     for pkg_name, pkg_data in pkgs.items():\n         if not idx % 20 and idx != limit:\n-            sys.stderr.write(\'\\n{0:4d} \'.format(idx))\n+            sys.stderr.write("\\n{0:4d} ".format(idx))\n \n         state = update_pkg_info(pkg_name, pkg_data, session)\n         if not state:\n-            sys.stderr.write(\'E\')\n-            errors.append((pkg_name, ))\n+            sys.stderr.write("E")\n+            errors.append((pkg_name,))\n             continue\n-        sys.stderr.write(\'O\' if state == 1 else \'o\')\n+        sys.stderr.write("O" if state == 1 else "o")\n         if limit and idx == limit:\n             break\n         idx += 1\n \n     for error in errors:\n-        sys.stderr.write(\n-            \'\\nError in {0}\'.format(\n-                *error\n-            )\n-        )\n+        sys.stderr.write("\\nError in {0}".format(*error))\n \n-    sys.stderr.write(\'\\nPyPI check finished\\n\')\n+    sys.stderr.write("\\nPyPI check finished\\n")\n \n \n def update_tracking_version_info(pkg_name, pkg_data, session):\n     # fetch pkgs json info from pypi\n-    url = \'{url}/{name}/{version}/json\'.format(url=PYPI_URL,\n-                                               name=pkg_name,\n-                                               # version=pkg_data[\'version\'])\n-                                               version=pkg_data[0])\n+    url = "{url}/pypi/{name}/{version}/json".format(\n+        url=PYPI_URL,\n+        name=pkg_name,\n+        # version=pkg_data[\'version\'])\n+        version=pkg_data[0],\n+    )\n     resp = session.get(url)\n \n     # check status code\n     if resp.status_code == 404:\n-        return False, \'Package Version not on pypi.\'\n+        return False, "Package Version not on pypi."\n     elif resp.status_code != 200:\n         return False, str(resp.status_code)\n     data = resp.json()\n \n     rel_date = datetime.date(1970, 1, 1)\n-    for rel_pkg in data[\'urls\']:\n-        time_string = rel_pkg.get(\'upload_time\')\n+    for rel_pkg in data["urls"]:\n+        time_string = rel_pkg.get("upload_time")\n         if time_string:\n             crel_date = datetime.datetime.strptime(\n-                time_string, \'%Y-%m-%dT%H:%M:%S\').date()\n+                time_string, "%Y-%m-%dT%H:%M:%S"\n+            ).date()\n             if crel_date > rel_date:\n                 rel_date = crel_date\n     # pkg_data[\'release_date\'] = rel_date\n@@ -295,32 +296,28 @@ def update_tracking_version_info(pkg_name, pkg_data, session):\n \n def update_tracking_info(pkgsinfo, nocache=False):\n     session = requests_session(nocache=nocache)\n-    pkgs = pkgsinfo[\'tracking\'][\'versions\']\n+    pkgs = pkgsinfo["tracking"]["versions"]\n     sys.stderr.write(\n-        \'Check PyPI for data of {0:d} packages.\'.format(len(pkgs))\n+        "Check PyPI for data of {0:d} packages.".format(len(pkgs))\n     )\n     errors = []\n \n     idx = 0\n     for pkg_name, pkg_data in pkgs.items():\n         if not idx % 20:\n-            sys.stderr.write(\'\\n{0:4d} \'.format(idx))\n+            sys.stderr.write("\\n{0:4d} ".format(idx))\n \n-        state, result = update_tracking_version_info(pkg_name,\n-                                                     pkg_data,\n-                                                     session)\n+        state, result = update_tracking_version_info(\n+            pkg_name, pkg_data, session\n+        )\n         if not state:\n-            sys.stderr.write(\'E\')\n+            sys.stderr.write("E")\n             errors.append((pkg_name, str(result)))\n             continue\n-        sys.stderr.write(\'O\' if state == 1 else \'o\')\n+        sys.stderr.write("O" if state == 1 else "o")\n         idx += 1\n \n     for error in errors:\n-        sys.stderr.write(\n-            \'\\nError in {0} reason: {1}\'.format(\n-                *error\n-            )\n-        )\n+        sys.stderr.write("\\nError in {0} reason: {1}".format(*error))\n \n-    sys.stderr.write(\'\\nPyPI check finished\\n\')\n+    sys.stderr.write("\\nPyPI check finished\\n")\ndiff --git a/src/plone/versioncheck/script.py b/src/plone/versioncheck/script.py\nindex 4dad995..c99da1e 100644\n--- a/src/plone/versioncheck/script.py\n+++ b/src/plone/versioncheck/script.py\n@@ -30,99 +30,89 @@\n \n \n parser = ArgumentParser(\n-    description=\'Fetch information about pinned versions and its overrides in \'\n-                \'simple and complex/cascaded buildouts.\',\n+    description="Fetch information about pinned versions and its overrides in "\n+    "simple and complex/cascaded buildouts.",\n     epilog=EPILOG,\n     formatter_class=RawDescriptionHelpFormatter,\n )\n parser.add_argument(\n-    \'buildout\',\n-    nargs=\'?\',\n-    default=\'buildout.cfg\',\n-    help=\'path to buildout.cfg or other *.cfg file\'\n+    "buildout",\n+    nargs="?",\n+    default="buildout.cfg",\n+    help="path to buildout.cfg or other *.cfg file",\n )\n parser.add_argument(\n-    \'-p\',\n-    \'--pypi\',\n-    help=\'check PyPI for newer versions\',\n-    action=\'store_true\'\n+    "-p", "--pypi", help="check PyPI for newer versions", action="store_true"\n )\n parser.add_argument(\n-    \'-n\',\n-    \'--newer\',\n-    help=\'display only packages with newer version than active\',\n-    action=\'store_true\'\n+    "-n",\n+    "--newer",\n+    help="display only packages with newer version than active",\n+    action="store_true",\n )\n parser.add_argument(\n-    \'-N\',\n-    \'--newer-orphaned\',\n-    help=\'display orphaned packages only when newer versions available\',\n-    action=\'store_true\'\n+    "-N",\n+    "--newer-orphaned",\n+    help="display orphaned packages only when newer versions available",\n+    action="store_true",\n )\n parser.add_argument(\n-    \'-r\',\n-    \'--required-by\',\n-    help=\'show information about requirements (only if tracking file is \'\n-         \'available)\',\n+    "-r",\n+    "--required-by",\n+    help="show information about requirements (only if tracking file is "\n+    "available)",\n     default=False,\n-    action=\'store_true\'\n+    action="store_true",\n )\n parser.add_argument(\n-    \'-d\',\n-    \'--show-release-dates\',\n-    help=\'show information about release dates \'\n-         \'(only for package lookup from PyPI)\',\n+    "-d",\n+    "--show-release-dates",\n+    help="show information about release dates "\n+    "(only for package lookup from PyPI)",\n     default=False,\n-    action=\'store_true\',\n-    dest=\'show_release_dates\'\n+    action="store_true",\n+    dest="show_release_dates",\n )\n parser.add_argument(\n-    \'-i\',\n-    \'--ignore-tracking\',\n-    help=\'ignore tracking file (if present)\',\n-    action=\'store_true\'\n+    "-i",\n+    "--ignore-tracking",\n+    help="ignore tracking file (if present)",\n+    action="store_true",\n )\n parser.add_argument(\n-    \'-m\',\n-    \'--machine\',\n-    help=\'show as machine readable output (json)\',\n-    action=\'store_true\'\n+    "-m",\n+    "--machine",\n+    help="show as machine readable output (json)",\n+    action="store_true",\n )\n parser.add_argument(\n-    \'--no-cache\',\n-    help=\'do not use a cache for PyPI\',\n-    action=\'store_true\'\n+    "--no-cache", help="do not use a cache for PyPI", action="store_true"\n )\n parser.add_argument(\n-    \'-b\',\n-    \'--browser\',\n-    help=\'show as html for webbrowser\',\n-    action=\'store_true\'\n+    "-b", "--browser", help="show as html for webbrowser", action="store_true"\n )\n parser.add_argument(\n-    \'-o\',\n-    \'--output\',\n-    help=\'safe output to output-file\',\n-    nargs=\'?\',\n-    type=argparse.FileType(\'w\'),\n-    default=sys.stdout\n+    "-o",\n+    "--output",\n+    help="safe output to output-file",\n+    nargs="?",\n+    type=argparse.FileType("w"),\n+    default=sys.stdout,\n )\n parser.add_argument(\n-    \'--no-colors\',\n-    help=\'do not show colors\',\n-    action=\'store_true\'\n+    "--no-colors", help="do not show colors", action="store_true"\n )\n parser.add_argument(\n-    \'--debug-limit\',\n+    "--debug-limit",\n     type=int,\n-    help=\'Limit the number of PyPI versions fetched for debugging\'\n+    help="Limit the number of PyPI versions fetched for debugging",\n )\n \n \n def run():\n     args = parser.parse_args()\n     pkgsinfo = {}\n-    pkgsinfo[\'pkgs\'] = parse(args.buildout)\n+    pkgsinfo["pkgs"] = parse(args.buildout)\n \n     # retrieve additional informations\n     if not args.ignore_tracking:\ndiff --git a/src/plone/versioncheck/tracking.py b/src/plone/versioncheck/tracking.py\nindex db1a490..b4ea46f 100644\n--- a/src/plone/versioncheck/tracking.py\n+++ b/src/plone/versioncheck/tracking.py\n@@ -16,7 +16,7 @@\n required_by = {}\n versions_by_name = {}\n \n-TRACKINGFILENAME = \'.plone.versioncheck.tracked.json\'\n+TRACKINGFILENAME = ".plone.versioncheck.tracked.json"\n \n \n def track_get_dist(old_get_dist):\n@@ -27,17 +27,18 @@ def get_dist(self, requirement, *ags, **kw):\n             versions_by_name[dist_name] = (\n                 dist.version,\n                 (\n-                    dist.precedence == DEVELOP_DIST and\n+                    dist.precedence == DEVELOP_DIST\n+                    and\n                     # heuristics, may fail if not named site-packages\n-                    \'site-packages\' not in dist.location and\n-                    dist.location\n-                )\n+                    "site-packages" not in dist.location\n+                    and dist.location\n+                ),\n             )\n             if dist_name not in required_by:\n                 required_by[dist_name] = []\n             if (\n-                requirement.key != dist_name and\n-                requirement.key not in required_by[dist_name]\n+                requirement.key != dist_name\n+                and requirement.key not in required_by[dist_name]\n             ):\n                 required_by[dist_name].append(requirement.key)\n             for req in dist.requires():\n@@ -46,28 +47,28 @@ def get_dist(self, requirement, *ags, **kw):\n                 if dist_name not in required_by[req.key]:\n                     required_by[req.key].append(dist_name)\n         return dists\n+\n     return get_dist\n \n \n def write_tracked(old_logging_shutdown, logfilepath):\n-\n     def logging_shutdown():\n         # WRITE FILE\n         result = {\n-            \'generated\': time.time(),\n-            \'required_by\': required_by,\n-            \'versions\': versions_by_name,\n+            "generated": time.time(),\n+            "required_by": required_by,\n+            "versions": versions_by_name,\n         }\n-        with open(logfilepath, \'w\') as fp:\n+        with open(logfilepath, "w") as fp:\n             json.dump(result, fp, indent=2)\n         old_logging_shutdown()\n+\n     return logging_shutdown\n \n \n def install(buildout):\n     filepath = os.path.join(\n-        buildout[\'buildout\'][\'directory\'],\n-        TRACKINGFILENAME,\n+        buildout["buildout"]["directory"], TRACKINGFILENAME\n     )\n     easy_install.Installer.__tracked_versions = {}\n     easy_install.Installer._get_dist = track_get_dist(\n@@ -86,24 +87,22 @@ def get(pkginfo, buildout):\n         # not available.\n         return\n     sys.stderr.write(\n-        \'\\nRead tracking information from buildout extension: \\n\'\n-        \'- {0}\\n\'.format(\n-            filepath\n-        )\n+        "\\nRead tracking information from buildout extension: \\n"\n+        "- {0}\\n".format(filepath)\n     )\n     try:\n-        with open(filepath, \'r\') as fp:\n-            pkginfo[\'tracking\'] = json.load(fp)\n+        with open(filepath, "r") as fp:\n+            pkginfo["tracking"] = json.load(fp)\n     except (IOError, ValueError) as e:\n-        sys.stderr.write(\' - \' + str(e) + \'\\n\')\n+        sys.stderr.write(" - " + str(e) + "\\n")\n         return\n-    delta = time.time() - pkginfo[\'tracking\'][\'generated\']\n+    delta = time.time() - pkginfo["tracking"]["generated"]\n     days = int(delta // (60 * 60 * 24))\n     hours = int(delta // (60 * 60) - days * 60 * 60)\n     minutes = int(delta // (60) - days * 60 * 60 - hours * 60)\n     seconds = delta % 60\n     sys.stderr.write(\n-        \'- age of gathered data: {0:d}d {1:d}h {2:d}m {3:2.3f}s\\n\'.format(\n-            days, hours, minutes, seconds,\n+        "- age of gathered data: {0:d}d {1:d}h {2:d}m {3:2.3f}s\\n".format(\n+            days, hours, minutes, seconds\n         )\n     )\ndiff --git a/src/plone/versioncheck/utils.py b/src/plone/versioncheck/utils.py\nindex f84f433..d9e684a 100644\n--- a/src/plone/versioncheck/utils.py\n+++ b/src/plone/versioncheck/utils.py\n@@ -26,28 +26,21 @@\n \n _STATEMAP = {\n     # develop egg\n-    \'D\': Style.BRIGHT + Fore.GREEN,\n-\n+    "D": Style.BRIGHT + Fore.GREEN,\n     # Active version\n-    \'A\': Style.BRIGHT + Fore.WHITE,\n-\n+    "A": Style.BRIGHT + Fore.WHITE,\n     # inherited, older or equal\n-    \'I\': Style.NORMAL + Fore.WHITE,\n-\n+    "I": Style.NORMAL + Fore.WHITE,\n     # inherited, newer\n-    \'In\': Style.BRIGHT + Fore.YELLOW,\n-\n+    "In": Style.BRIGHT + Fore.YELLOW,\n     # update\n-    \'U\': Style.BRIGHT + Fore.CYAN,\n-\n+    "U": Style.BRIGHT + Fore.CYAN,\n     # update prerelease\n-    \'P\': Style.BRIGHT + Fore.BLUE,\n-\n+    "P": Style.BRIGHT + Fore.BLUE,\n     # orphaned\n-    \'O\': Style.BRIGHT + Fore.MAGENTA,\n-\n+    "O": Style.BRIGHT + Fore.MAGENTA,\n     # unpinned\n-    \'X\': Style.BRIGHT + Fore.RED,\n+    "X": Style.BRIGHT + Fore.RED,\n }\n \n \n@@ -59,54 +52,46 @@ def color_init():\n def color_by_state(state):\n     if COLORED:\n         return _STATEMAP.get(state, Style.DIM + Fore.RED)\n-    return \'\'\n+    return ""\n \n \n def color_dimmed():\n     if COLORED:\n         return Style.DIM + Fore.WHITE\n-    return \'\'\n+    return ""\n \n \n def dots(value, max):\n     """ljust, but the dots only"""\n-    dots = \'.\' * (max - len(value))\n+    dots = "." * (max - len(value))\n     if dots:\n-        dots = \' \' + dots[1:]\n+        dots = " " + dots[1:]\n     return color_dimmed() + dots\n \n \n-CACHE_FILENAME = \'.plone.versioncheck.cache\'\n+CACHE_FILENAME = ".plone.versioncheck.cache"\n \n \n def requests_session(nocache=False):\n     if nocache:\n         return requests.Session()\n-    return CacheControl(\n-        requests.Session(),\n-        cache=FileCache(CACHE_FILENAME)\n-    )\n+    return CacheControl(requests.Session(), cache=FileCache(CACHE_FILENAME))\n \n \n-def find_relative(extend, relative=\'\'):\n+def find_relative(extend, relative=""):\n     """the base dir or url and the actual filename as tuple\n     """\n-    if \'://\' in extend:\n+    if "://" in extend:\n         parts = list(urlparse(extend))\n-        path = parts[2].split(\'/\')\n-        parts[2] = \'/\'.join(path[:-1])\n+        path = parts[2].split("/")\n+        parts[2] = "/".join(path[:-1])\n         return urlunparse(parts), path[-1]\n-    if \'://\' in relative:\n-            return (\n-                relative.strip(\'/\'),\n-                extend.strip(\'/\'),\n-            )\n+    if "://" in relative:\n+        return (relative.strip("/"), extend.strip("/"))\n     if relative:\n         extend = os.path.join(relative, extend)\n-    return (\n-        os.path.dirname(os.path.abspath(extend)),\n-        os.path.basename(extend),\n-    )\n+    return (os.path.dirname(os.path.abspath(extend)), os.path.basename(extend))\n+\n \n ###########################################################\n # below copied from https://gist.github.com/jtriley/1108174\n@@ -121,21 +106,22 @@ def get_terminal_size():\n     """\n     current_os = platform.system()\n     tuple_xy = None\n-    if current_os == \'Windows\':\n+    if current_os == "Windows":\n         tuple_xy = _get_terminal_size_windows()\n         if tuple_xy is None:\n             tuple_xy = _get_terminal_size_tput()\n             # needed for window\'s python in cygwin\'s xterm!\n-    if current_os in [\'Linux\', \'Darwin\'] or current_os.startswith(\'CYGWIN\'):\n+    if current_os in ["Linux", "Darwin"] or current_os.startswith("CYGWIN"):\n         tuple_xy = _get_terminal_size_linux()\n     if tuple_xy is None:\n-        tuple_xy = (80, 25)      # default value\n+        tuple_xy = (80, 25)  # default value\n     return tuple_xy\n \n \n def _get_terminal_size_windows():\n     try:\n         from ctypes import windll, create_string_buffer\n+\n         # stdin handle is -10\n         # stdout handle is -11\n         # stderr handle is -12\n@@ -143,9 +129,19 @@ def _get_terminal_size_windows():\n         csbi = create_string_buffer(22)\n         res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n         if res:\n-            (bufx, bufy, curx, cury, wattr,\n-             left, top, right, bottom,\n-             maxx, maxy) = struct.unpack(\'hhhhHhhhhhh\', csbi.raw)\n+            (\n+                bufx,\n+                bufy,\n+                curx,\n+                cury,\n+                wattr,\n+                left,\n+                top,\n+                right,\n+                bottom,\n+                maxx,\n+                maxy,\n+            ) = struct.unpack("hhhhHhhhhhh", csbi.raw)\n             sizex = right - left + 1\n             sizey = bottom - top + 1\n             return sizex, sizey\n@@ -157,8 +153,8 @@ def _get_terminal_size_tput():\n     # get terminal width\n     # src: http://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window  # noqa\n     try:\n-        cols = int(subprocess.check_call(shlex.split(\'tput cols\')))\n-        rows = int(subprocess.check_call(shlex.split(\'tput lines\')))\n+        cols = int(subprocess.check_call(shlex.split("tput cols")))\n+        rows = int(subprocess.check_call(shlex.split("tput lines")))\n         return (cols, rows)\n     except Exception:\n         pass\n@@ -169,11 +165,14 @@ def ioctl_GWINSZ(fd):\n         try:\n             import fcntl\n             import termios\n-            cr = struct.unpack(\'hh\',\n-                               fcntl.ioctl(fd, termios.TIOCGWINSZ, \'1234\'))\n+\n+            cr = struct.unpack(\n+                "hh", fcntl.ioctl(fd, termios.TIOCGWINSZ, "1234")\n+            )\n             return cr\n         except Exception:\n             pass\n+\n     cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)\n     if not cr:\n         try:\n@@ -184,7 +183,7 @@ def ioctl_GWINSZ(fd):\n             pass\n     if not cr:\n         try:\n-            cr = (os.environ[\'LINES\'], os.environ[\'COLUMNS\'])\n+            cr = (os.environ["LINES"], os.environ["COLUMNS"])\n         except Exception:\n             return None\n     return int(cr[1]), int(cr[0])\n'

Repository: plone.versioncheck


Branch: refs/heads/master
Date: 2019-03-08T12:00:33+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.versioncheck/commit/dbed84d1209c4e4f91b2122fdafaaf572f7fcbdf

test on python 3.7

Files changed:
M CHANGES.rst
M setup.py
M tox.ini

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 4bcb2ae..6b4f011 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -4,6 +4,9 @@ Changelog\n 1.6.11 (unreleased)\n -------------------\n \n+- Test on Python 3.7\n+  [jensens]\n+\n - Fix PyPI url and add output of URL in case of a problem.\n   [jensens]\n \ndiff --git a/setup.py b/setup.py\nindex 499b89c..6a1831a 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -19,6 +19,8 @@\n     # https://pypi.python.org/pypi?:action=list_classifiers\n     classifiers=[\n         'Development Status :: 5 - Production/Stable',\n+        'Framework :: Buildout :: Extension',\n+        'Framework :: Buildout :: Recipe',\n         'Framework :: Buildout',\n         'Intended Audience :: Developers',\n         'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',\ndiff --git a/tox.ini b/tox.ini\nindex 7bd3ef4..22528fc 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -5,9 +5,11 @@ envlist =\n     py34,\n     py35,\n     py36,\n+    py37,\n     pypy,\n     lint-py27,\n     lint-py36,\n+    lint-py37,\n     coverage-report,\n \n skip_missing_interpreters = False\n@@ -114,6 +116,13 @@ deps = {[lint]deps}\n commands = {[lint]commands}\n whitelist_externals = {[lint]whitelist_externals}\n \n+[testenv:lint-py37]\n+basepython = python3.7\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n [testenv:docs]\n deps =\n     Sphinx\n"

