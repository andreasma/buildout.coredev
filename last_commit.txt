Repository: plone.restapi


Branch: refs/heads/master
Date: 2020-01-22T14:37:16+01:00
Author: Lukas Graf (lukasgraf) <lukas.graf@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/6f7c08b722c39579d2b7103937f60a1bb450a030

Sharing POST: Limit roles to ones the user is allowed to delegate. (#859)

Files changed:
A news/857.bugfix
M src/plone/restapi/deserializer/local_roles.py
M src/plone/restapi/tests/test_content_local_roles.py

b'diff --git a/news/857.bugfix b/news/857.bugfix\nnew file mode 100644\nindex 00000000..acfdabf0\n--- /dev/null\n+++ b/news/857.bugfix\n@@ -0,0 +1,2 @@\n+Sharing POST: Limit roles to ones the user is allowed to delegate.\n+[lgraf]\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/deserializer/local_roles.py b/src/plone/restapi/deserializer/local_roles.py\nindex 73540a68..68a2ec80 100644\n--- a/src/plone/restapi/deserializer/local_roles.py\n+++ b/src/plone/restapi/deserializer/local_roles.py\n@@ -47,11 +47,17 @@ def __call__(self):\n         # roles\n         roles_reindex = False\n         new_roles = data.get("entries", None)\n+        managed_roles = frozenset([r[\'id\'] for r in sharing_view.roles()])\n+\n         if new_roles is not None:\n             # the roles are converted into a FrozenSet so we have to filter\n             # the data structure we get.\n             for user in new_roles:\n                 roles_list = [key for key in user["roles"] if user["roles"][key]]\n+\n+                # Limit roles to ones the user is allowed to delegate\n+                roles_list = set(roles_list).intersection(managed_roles)\n+\n                 user["roles"] = roles_list\n             roles_reindex = sharing_view.update_role_settings(new_roles, reindex=False)\n \ndiff --git a/src/plone/restapi/tests/test_content_local_roles.py b/src/plone/restapi/tests/test_content_local_roles.py\nindex a26e6f38..bd27f9f4 100644\n--- a/src/plone/restapi/tests/test_content_local_roles.py\n+++ b/src/plone/restapi/tests/test_content_local_roles.py\n@@ -6,6 +6,8 @@\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from plone.app.testing import TEST_USER_PASSWORD\n from plone.restapi.serializer.local_roles import SerializeLocalRolesToJson\n from plone.restapi.testing import PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n from Products.CMFCore.utils import getToolByName\n@@ -265,6 +267,129 @@ def test_set_local_roles_for_user(self):\n             ],\n         )\n \n+    def test_may_only_manage_roles_already_held(self):\n+        # Grant Editor role to our test user (which gives them the required\n+        # "plone.DelegateRoles" permission to manage local roles at all)\n+        api.user.grant_roles(username=TEST_USER_ID, obj=self.portal.folder1,\n+                             roles=[\'Editor\'])\n+        transaction.commit()\n+\n+        # Guard assertion - our test user starts with a limited set of roles\n+        existing_roles = api.user.get_roles(username=TEST_USER_ID,\n+                                            obj=self.portal.folder1)\n+        self.assertEqual(\n+            sorted([\'Member\', \'Authenticated\', \'Editor\']),\n+            sorted(existing_roles))\n+\n+        # Attempt to gain additional roles not already held\n+        response = requests.post(\n+            self.portal.folder1.absolute_url() + "/@sharing",\n+            headers={"Accept": "application/json"},\n+            auth=(TEST_USER_NAME, TEST_USER_PASSWORD),\n+            json={\n+                "entries": [\n+                    {\n+                        u"id": TEST_USER_ID,\n+                        u"roles": {\n+                            u"Contributor": True,\n+                            u"Editor": True,\n+                            u"Reader": True,\n+                            u"Publisher": True,\n+                            u"Reviewer": True,\n+                            u"Manager": True,\n+                        },\n+                        u"type": u"user",\n+                    }\n+                ]\n+            },\n+        )\n+\n+        transaction.commit()\n+\n+        self.assertEqual(response.status_code, 204)\n+        new_roles = api.user.get_roles(username=TEST_USER_ID,\n+                                       obj=self.portal.folder1)\n+\n+        # New roles should not contain any new roles that the user didn\'t\n+        # have permission to delegate.\n+        self.assertNotIn(u\'Manager\', new_roles)\n+        self.assertNotIn(u\'Publisher\', new_roles)\n+        self.assertNotIn(u\'Reviewer\', new_roles)\n+        self.assertNotIn(u\'Contributor\', new_roles)\n+\n+        # \'Reader\' gets added because the permission to delegate it is\n+        # assigned to \'Editor\' by default (see p.a.workflow.permissions)\n+        self.assertEqual(\n+            sorted([\'Member\', \'Authenticated\', \'Editor\', \'Reader\']),\n+            sorted(new_roles))\n+\n+    def test_unmanaged_existing_roles_are_retained_on_update(self):\n+        """Make sure that existing roles don\'t get dropped when a user that\n+        doesn\'t manage that roles updates local roles for another user that\n+        already holds that role.\n+        """\n+        # Create another user that holds the Reviewer role, which is not\n+        # managed by our test user\n+        api.user.create(username=\'peter\', email=\'peter@example.org\',\n+                        password=\'secret\', roles=(\'Member\', ))\n+\n+        api.user.grant_roles(username=\'peter\', obj=self.portal.folder1,\n+                             roles=[\'Reviewer\'])\n+        transaction.commit()\n+\n+        peters_existing_roles = api.user.get_roles(username=\'peter\',\n+                                                   obj=self.portal.folder1)\n+        self.assertEqual(sorted([\'Member\', \'Reviewer\', \'Authenticated\']),\n+                         sorted(peters_existing_roles))\n+\n+        # Grant Editor role to our test user (which gives them the required\n+        # "plone.DelegateRoles" permission to manage local roles at all)\n+        api.user.grant_roles(username=TEST_USER_ID, obj=self.portal.folder1,\n+                             roles=[\'Editor\'])\n+        transaction.commit()\n+\n+        # Guard assertion - our test user doesn\'t have/manage Reviewer\n+        existing_roles = api.user.get_roles(username=TEST_USER_ID,\n+                                            obj=self.portal.folder1)\n+        self.assertEqual(\n+            sorted([\'Member\', \'Authenticated\', \'Editor\']),\n+            sorted(existing_roles))\n+\n+        # Test user now gives Editor to peter. This should not lead to\n+        # peter losing the Reviewer role.\n+        response = requests.post(\n+            self.portal.folder1.absolute_url() + "/@sharing",\n+            headers={"Accept": "application/json"},\n+            auth=(TEST_USER_NAME, TEST_USER_PASSWORD),\n+            json={\n+                "entries": [\n+                    {\n+                        u"id": "peter",\n+                        u"roles": {\n+                            u"Contributor": False,\n+                            u"Editor": True,\n+                            u"Reader": True,\n+                            u"Publisher": False,\n+                            u"Reviewer": True,\n+                            u"Manager": False,\n+                        },\n+                        u"type": u"user",\n+                    }\n+                ]\n+            },\n+        )\n+\n+        transaction.commit()\n+\n+        self.assertEqual(response.status_code, 204)\n+        new_roles = api.user.get_roles(username=\'peter\',\n+                                       obj=self.portal.folder1)\n+\n+        self.assertIn(u\'Reviewer\', new_roles)\n+        self.assertEqual(\n+            sorted([\'Member\', \'Authenticated\', \'Editor\', \'Reader\', \'Reviewer\']),\n+            sorted(new_roles))\n+\n     def test_unset_local_roles_for_user(self):\n         api.user.grant_roles(\n             username=TEST_USER_ID, obj=self.portal.folder1, roles=["Reviewer", "Reader"]\n'

