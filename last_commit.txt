Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Florian Schulze (fschulze) <florian.schulze@gmx.net>
Commit: https://github.com/plone/plone.scale/commit/0754dca763658551eb313539fcd2c4c891ea04fc

New ``mode`` argument replacing ``direction``.

Files changed:
A news/29.feature
M CHANGES.rst
M plone/scale/scale.py
M plone/scale/tests/test_scale.py
M plone/scale/tests/test_storage.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex fb709a8..fef5e71 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -19,6 +19,8 @@ Bug fixes:\n 3.0.2 (2018-09-28)\n ------------------\n \n+Changes:\n+\n Bug fixes:\n \n - Fix cleanup of image scales in py3\ndiff --git a/news/29.feature b/news/29.feature\nnew file mode 100644\nindex 0000000..4ffae2e\n--- /dev/null\n+++ b/news/29.feature\n@@ -0,0 +1,5 @@\n+The ``mode`` argument replaces the old, now deprecated, ``direction`` argument.\n+The new names are ``contain`` or ``scale-crop-to-fit`` instead of ``down``,\n+``cover`` or ``scale-crop-to-fill`` instead of ``up``\n+and ``scale`` instead of ``thumbnail``.\n+[fschulze]\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 4bc414e..279cb62 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -28,8 +28,8 @@ def none_as_int(the_int):\n PIL.ImageFile.MAXBLOCK = 1000000\n \n \n-def scaleImage(image, width=None, height=None, direction=\'down\',\n-               quality=88, result=None):\n+def scaleImage(image, width=None, height=None, mode=\'contain\',\n+               quality=88, result=None, direction=None):\n     """Scale the given image data to another size and return the result\n     as a string or optionally write in to the file-like `result` object.\n \n@@ -43,7 +43,7 @@ def scaleImage(image, width=None, height=None, direction=\'down\',\n     a size-tuple.  Optionally a file-like object can be given as the\n     `result` parameter, in which the generated image scale will be stored.\n \n-    The `width`, `height`, `direction` parameters will be passed to\n+    The `width`, `height`, `mode` parameters will be passed to\n     :meth:`scalePILImage`, which performs the actual scaling.\n \n     The generated image is a JPEG image, unless the original is a PNG or GIF\n@@ -64,7 +64,7 @@ def scaleImage(image, width=None, height=None, direction=\'down\',\n         format_ = \'PNG\'\n \n     icc_profile = image.info.get(\'icc_profile\')\n-    image = scalePILImage(image, width, height, direction)\n+    image = scalePILImage(image, width, height, mode, direction=direction)\n \n     # convert to simpler mode if possible\n     colors = image.getcolors(maxcolors=256)\n@@ -129,31 +129,30 @@ def _scale_thumbnail(image, width=None, height=None):\n     return image\n \n \n-def scalePILImage(image, width=None, height=None, direction=\'down\'):\n+def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None):\n     """Scale a PIL image to another size.\n \n     This is all about scaling for the display in a web browser.\n \n     Either width or height - or both - must be given.\n \n-    Three different scaling options are supported via `direction`:\n+    Three different scaling options are supported via `mode` and correspond to\n+    the CSS background-size values\n+    (see https://developer.mozilla.org/en-US/docs/Web/CSS/background-size):\n \n-    `up`\n-        scaling scales the smallest dimension up to the required size\n-        and crops the other dimension if needed.\n-\n-    `down`\n+    `contain` or `scale-crop-to-fit`\n         scaling starts by scaling the largest dimension to the required\n         size and crops the other dimension if needed.\n \n-    `thumbnail`\n-        scales to the requested dimensions without cropping. Theresulting\n+    `cover` or `scale-crop-to-fill`\n+        scaling scales the smallest dimension up to the required size\n+        and crops the other dimension if needed.\n+\n+    `scale`\n+        scales to the requested dimensions without cropping. The resulting\n         image may have a different size than requested. This option\n         requires both width and height to be specified.\n \n-        `keep` is accepted as an alternative spelling for this option,\n-        but its use is deprecated.\n-\n     The `image` parameter must be an instance of the `PIL.Image` class.\n \n     The return value the scaled image in the form of another instance of\n@@ -167,12 +166,34 @@ def scalePILImage(image, width=None, height=None, direction=\'down\'):\n     if width is None and height is None:\n         raise ValueError("Either width or height need to be given")\n \n-    if direction == "keep":\n+    if direction is not None:\n+        warnings.warn(\n+            "the \'direction\' option is deprecated, use \'mode\' instead",\n+            DeprecationWarning)\n+        mode = direction\n+    del direction\n+\n+    if mode == "down":\n+        warnings.warn(\n+            "the \'down\' scaling mode is deprecated, use \'contain\' instead",\n+            DeprecationWarning)\n+        mode = "contain"\n+    if mode == "up":\n+        warnings.warn(\n+            "the \'up\' scaling mode is deprecated, use \'cover\' instead",\n+            DeprecationWarning)\n+        mode = "cover"\n+    if mode == "thumbnail":\n         warnings.warn(\n-            \'direction="keep" is deprecated, use "thumbnail" instead\',\n-            DeprecationWarning\n-        )\n-        direction = "thumbnail"\n+            "the \'thumbnail\' scaling mode is deprecated, use \'scale\' instead",\n+            DeprecationWarning)\n+        mode = "scale"\n+    if mode == "scale-crop-to-fit":\n+        mode = "contain"\n+    if mode == "scale-crop-to-fill":\n+        mode = "cover"\n+    if mode not in (\'contain\', \'cover\', \'scale\'):\n+        raise ValueError("Unknown scale mode \'%s\'" % mode)\n \n     if image.mode == "1":\n         # Convert black&white to grayscale\n@@ -189,11 +210,11 @@ def scalePILImage(image, width=None, height=None, direction=\'down\'):\n         # Convert CMYK to RGB, allowing for web previews of print images\n         image = image.convert("RGB")\n \n-    # for thumbnail we\'re done:\n-    if direction == \'thumbnail\':\n+    # for scale we\'re done:\n+    if mode == \'scale\':\n         return _scale_thumbnail(image, width, height)\n \n-    # now for up and down scaling\n+    # now for cover and contain scaling\n     # Determine scale factor needed to get the right height\n     factor_height = factor_width = None\n     if height is not None:\n@@ -204,15 +225,15 @@ def scalePILImage(image, width=None, height=None, direction=\'down\'):\n     if factor_height == factor_width:\n         # The original already has the right aspect ratio, so we only need\n         # to scale.\n-        if direction == \'down\':\n+        if mode == \'contain\':\n             image.thumbnail((width, height), PIL.Image.ANTIALIAS)\n             return image\n         return image.resize((width, height), PIL.Image.ANTIALIAS)\n \n     # figure out which axis to scale. One of the factors can still be None!\n-    # calculate for \'down\'\n+    # calculate for \'contain\'\n     use_height = none_as_int(factor_width) > none_as_int(factor_height)\n-    if direction == \'up\':  # for \'up\': invert\n+    if mode == \'cover\':  # for \'cover\': invert\n         use_height = not use_height\n \n     new_width = width\ndiff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 58177f7..30ea5b7 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -6,6 +6,8 @@\n import os.path\n import PIL.Image\n import PIL.ImageDraw\n+import warnings\n+\n \n try:\n     from cStringIO import StringIO\n@@ -28,19 +30,19 @@\n class ScalingTests(TestCase):\n \n     def testNewSizeReturned(self):\n-        (imagedata, format, size) = scaleImage(PNG, 42, 51, "down")\n+        (imagedata, format, size) = scaleImage(PNG, 42, 51, "contain")\n         input = StringIO(imagedata)\n         image = PIL.Image.open(input)\n         self.assertEqual(image.size, size)\n \n     def testScaledImageKeepPNG(self):\n-        self.assertEqual(scaleImage(PNG, 84, 103, "down")[1], "PNG")\n+        self.assertEqual(scaleImage(PNG, 84, 103, "contain")[1], "PNG")\n \n     def testScaledImageKeepGIFto(self):\n-        self.assertEqual(scaleImage(GIF, 84, 103, "down")[1], "PNG")\n+        self.assertEqual(scaleImage(GIF, 84, 103, "contain")[1], "PNG")\n \n     def testScaledImageIsJpeg(self):\n-        self.assertEqual(scaleImage(TIFF, 84, 103, "down")[1], "JPEG")\n+        self.assertEqual(scaleImage(TIFF, 84, 103, "contain")[1], "JPEG")\n \n     def testAlphaForcesPNG(self):\n         # first image without alpha\n@@ -50,7 +52,7 @@ def testAlphaForcesPNG(self):\n                 src.putpixel((x, y), (x, y, 0, 255))\n         result = StringIO()\n         src.save(result, "TIFF")\n-        self.assertEqual(scaleImage(result, 84, 103, "down")[1], "JPEG")\n+        self.assertEqual(scaleImage(result, 84, 103, "contain")[1], "JPEG")\n         # now with alpha\n         src = PIL.Image.new("RGBA", (256, 256), (255, 255, 255, 128))\n         result = StringIO()\n@@ -58,25 +60,25 @@ def testAlphaForcesPNG(self):\n             for x in range(0, 256):\n                 src.putpixel((x, y), (x, y, 0, x))\n         src.save(result, "TIFF")\n-        self.assertEqual(scaleImage(result, 84, 103, "down")[1], "PNG")\n+        self.assertEqual(scaleImage(result, 84, 103, "contain")[1], "PNG")\n \n     def testScaledCMYKIsRGB(self):\n-        (imagedata, format, size) = scaleImage(CMYK, 42, 51, "down")\n+        (imagedata, format, size) = scaleImage(CMYK, 42, 51, "contain")\n         input = StringIO(imagedata)\n         image = PIL.Image.open(input)\n         self.assertEqual(image.mode, "RGB")\n \n     def testScaledPngImageIsPng(self):\n-        self.assertEqual(scaleImage(PNG, 84, 103, "down")[1], "PNG")\n+        self.assertEqual(scaleImage(PNG, 84, 103, "contain")[1], "PNG")\n \n     def testScaledPreservesProfile(self):\n-        (imagedata, format, size) = scaleImage(PROFILE, 42, 51, "down")\n+        (imagedata, format, size) = scaleImage(PROFILE, 42, 51, "contain")\n         input = StringIO(imagedata)\n         image = PIL.Image.open(input)\n         self.assertIsNotNone(image.info.get(\'icc_profile\'))\n \n     def testScaleWithFewColorsStaysColored(self):\n-        (imagedata, format, size) = scaleImage(PROFILE, 16, None, "down")\n+        (imagedata, format, size) = scaleImage(PROFILE, 16, None, "contain")\n         image = PIL.Image.open(StringIO(imagedata))\n         self.assertEqual(max(image.size), 16)\n         self.assertEqual(image.mode, \'RGB\')\n@@ -89,7 +91,7 @@ def testAutomaticGreyscale(self):\n             draw.line(((0, i), (256, i)), fill=(i, i, i))\n         result = StringIO()\n         src.save(result, "JPEG")\n-        (imagedata, format, size) = scaleImage(result, 200, None, "down")\n+        (imagedata, format, size) = scaleImage(result, 200, None, "contain")\n         image = PIL.Image.open(StringIO(imagedata))\n         self.assertEqual(max(image.size), 200)\n         self.assertEqual(image.mode, \'L\')\n@@ -110,81 +112,79 @@ def testAutomaticPalette(self):\n         self.assertEqual(png.format, \'PNG\')\n         self.assertIsNone(png.getcolors(maxcolors=256))\n         # scale it to a size where we get less than 256 colors\n-        (imagedata, format, size) = scaleImage(\n-            dst.getvalue(), 24, None, "down"\n-        )\n+        (imagedata, format, size) = scaleImage(dst.getvalue(), 24, None, "contain")\n         image = PIL.Image.open(StringIO(imagedata))\n         # we should now have an image in palette mode\n         self.assertEqual(image.mode, \'P\')\n         self.assertEqual(image.format, \'PNG\')\n \n     def testSameSizeDownScale(self):\n-        self.assertEqual(scaleImage(PNG, 84, 103, "down")[2], (84, 103))\n+        self.assertEqual(scaleImage(PNG, 84, 103, "contain")[2], (84, 103))\n \n     def testHalfSizeDownScale(self):\n-        self.assertEqual(scaleImage(PNG, 42, 51, "down")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, 42, 51, "contain")[2], (42, 51))\n \n     def testScaleWithCropDownScale(self):\n-        self.assertEqual(scaleImage(PNG, 20, 51, "down")[2], (20, 51))\n+        self.assertEqual(scaleImage(PNG, 20, 51, "contain")[2], (20, 51))\n \n     def testNoStretchingDownScale(self):\n-        self.assertEqual(scaleImage(PNG, 200, 103, "down")[2], (200, 103))\n+        self.assertEqual(scaleImage(PNG, 200, 103, "contain")[2], (200, 103))\n \n     def testHugeScale(self):\n         # the image will be cropped, but not scaled\n-        self.assertEqual(scaleImage(PNG, 400, 99999, "down")[2], (2, 103))\n+        self.assertEqual(scaleImage(PNG, 400, 99999, "contain")[2], (2, 103))\n \n     def testCropPreWideScaleUnspecifiedHeight(self):\n-        image = scaleImage(PNG, 400, None, "down")\n+        image = scaleImage(PNG, 400, None, "contain")\n         self.assertEqual(image[2], (400, 490))\n \n     def testCropPreWideScale(self):\n-        image = scaleImage(PNG, 400, 100, "down")\n+        image = scaleImage(PNG, 400, 100, "contain")\n         self.assertEqual(image[2], (400, 100))\n \n     def testCropPreTallScaleUnspecifiedWidth(self):\n-        image = scaleImage(PNG, None, 400, "down")\n+        image = scaleImage(PNG, None, 400, "contain")\n         self.assertEqual(image[2], (326, 400))\n \n     def testCropPreTallScale(self):\n-        image = scaleImage(PNG, 100, 400, "down")\n+        image = scaleImage(PNG, 100, 400, "contain")\n         self.assertEqual(image[2], (100, 400))\n \n     def testRestrictWidthOnlyDownScaleNone(self):\n-        self.assertEqual(scaleImage(PNG, 42, None, "down")[2], (42, 52))\n+        self.assertEqual(scaleImage(PNG, 42, None, "contain")[2], (42, 52))\n \n     def testRestrictWidthOnlyDownScaleZero(self):\n-        self.assertEqual(scaleImage(PNG, 42, 0, "down")[2], (42, 52))\n+        self.assertEqual(scaleImage(PNG, 42, 0, "contain")[2], (42, 52))\n \n     def testRestrictHeightOnlyDownScaleNone(self):\n-        self.assertEqual(scaleImage(PNG, None, 51, "down")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, None, 51, "contain")[2], (42, 51))\n \n     def testRestrictHeightOnlyDownScaleZero(self):\n-        self.assertEqual(scaleImage(PNG, 0, 51, "down")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, 0, 51, "contain")[2], (42, 51))\n \n     def testSameSizeUpScale(self):\n-        self.assertEqual(scaleImage(PNG, 84, 103, "up")[2], (84, 103))\n+        self.assertEqual(scaleImage(PNG, 84, 103, "cover")[2], (84, 103))\n \n     def testDoubleSizeUpScale(self):\n-        self.assertEqual(scaleImage(PNG, 168, 206, "up")[2], (168, 206))\n+        self.assertEqual(scaleImage(PNG, 168, 206, "cover")[2], (168, 206))\n \n     def testHalfSizeUpScale(self):\n-        self.assertEqual(scaleImage(PNG, 42, 51, "up")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, 42, 51, "cover")[2], (42, 51))\n \n     def testNoStretchingUpScale(self):\n-        self.assertEqual(scaleImage(PNG, 200, 103, "up")[2], (84, 103))\n+        self.assertEqual(scaleImage(PNG, 200, 103, "cover")[2], (84, 103))\n \n     def testRestrictWidthOnlyUpScaleNone(self):\n-        self.assertEqual(scaleImage(PNG, 42, None, "up")[2], (42, 52))\n+        self.assertEqual(scaleImage(PNG, 42, None, "cover")[2], (42, 52))\n \n     def testRestrictWidthOnlyUpScaleZero(self):\n-        self.assertEqual(scaleImage(PNG, 42, 0, "up")[2], (42, 52))\n+        self.assertEqual(scaleImage(PNG, 42, 0, "cover")[2], (42, 52))\n \n     def testRestrictHeightOnlyUpScaleNone(self):\n-        self.assertEqual(scaleImage(PNG, None, 51, "up")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, None, 51, "cover")[2], (42, 51))\n \n     def testRestrictHeightOnlyUpScaleZero(self):\n-        self.assertEqual(scaleImage(PNG, 0, 51, "up")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, 0, 51, "cover")[2], (42, 51))\n \n     def testNoRestrictionsNone(self):\n         self.assertRaises(ValueError, scaleImage, PNG, None, None)\n@@ -193,16 +193,13 @@ def testNoRestrictionsZero(self):\n         self.assertRaises(ValueError, scaleImage, PNG, 0, 0)\n \n     def testKeepAspectRatio(self):\n-        self.assertEqual(scaleImage(PNG, 80, 80, "thumbnail")[2], (65, 80))\n-\n-    def testKeepAspectRatioBBB(self):\n-        self.assertEqual(scaleImage(PNG, 80, 80, "keep")[2], (65, 80))\n+        self.assertEqual(scaleImage(PNG, 80, 80, "scale")[2], (65, 80))\n \n     def testThumbnailHeightNone(self):\n-        self.assertEqual(scaleImage(PNG, 42, None, "thumbnail")[2], (42, 51))\n+        self.assertEqual(scaleImage(PNG, 42, None, "scale")[2], (42, 51))\n \n     def testThumbnailWidthNone(self):\n-        self.assertEqual(scaleImage(PNG, None, 51, "thumbnail")[2], (41, 51))\n+        self.assertEqual(scaleImage(PNG, None, 51, "scale")[2], (41, 51))\n \n     def testQuality(self):\n         img1 = scaleImage(CMYK, 84, 103)[0]\n@@ -219,7 +216,48 @@ def testResultBuffer(self):\n         self.assertEqual(result, img2)      # the return value _is_ the buffer\n         self.assertEqual(result.getvalue(), img1)   # but with the same value\n \n+    def testDeprecations(self):\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter("always")\n+            scaleImage(PNG, 16, 16, "down")\n+            self.assertEqual(len(w), 1)\n+            self.assertIs(w[0].category, DeprecationWarning)\n+            self.assertIn(\n+                "the \'down\' scaling mode is deprecated",\n+                str(w[0].message))\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter("always")\n+            scaleImage(PNG, 16, 16, "up")\n+            self.assertEqual(len(w), 1)\n+            self.assertIs(w[0].category, DeprecationWarning)\n+            self.assertIn(\n+                "the \'up\' scaling mode is deprecated",\n+                str(w[0].message))\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter("always")\n+            scaleImage(PNG, 16, 16, "thumbnail")\n+            self.assertEqual(len(w), 1)\n+            self.assertIs(w[0].category, DeprecationWarning)\n+            self.assertIn(\n+                "the \'thumbnail\' scaling mode is deprecated",\n+                str(w[0].message))\n+        with warnings.catch_warnings(record=True) as w:\n+            warnings.simplefilter("always")\n+            scaleImage(PNG, 16, 16, direction="up")\n+            self.assertEqual(len(w), 2)\n+            self.assertIs(w[0].category, DeprecationWarning)\n+            self.assertIn(\n+                "the \'direction\' option is deprecated",\n+                str(w[0].message))\n+            self.assertIs(w[1].category, DeprecationWarning)\n+            self.assertIn(\n+                "the \'up\' scaling mode is deprecated",\n+                str(w[1].message))\n+\n \n def test_suite():\n     from unittest import defaultTestLoader\n+    from warnings import filterwarnings\n+    filterwarnings("error", "the \'direction\' option is deprecated")\n+    filterwarnings("error", "the \'.*\' scaling mode is deprecated")\n     return defaultTestLoader.loadTestsFromName(__name__)\ndiff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex fda5de7..6c8524c 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -256,4 +256,7 @@ def testClear(self):\n \n def test_suite():\n     from unittest import defaultTestLoader\n+    from warnings import filterwarnings\n+    filterwarnings("error", "the \'direction\' option is deprecated")\n+    filterwarnings("error", "the \'.*\' scaling mode is deprecated")\n     return defaultTestLoader.loadTestsFromName(__name__)\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Florian Schulze (fschulze) <florian.schulze@gmx.net>
Commit: https://github.com/plone/plone.scale/commit/59f51f6d3e7fb035004616e26d2e498a4b7c2024

Restore 'keep' scaling mode. Too many plone packages still use it.

Files changed:
M plone/scale/scale.py
M plone/scale/tests/test_scale.py

b'diff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 279cb62..99ec27d 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -188,6 +188,11 @@ def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None\n             "the \'thumbnail\' scaling mode is deprecated, use \'scale\' instead",\n             DeprecationWarning)\n         mode = "scale"\n+    if mode == "keep":\n+        warnings.warn(\n+            "the \'keep\' scaling mode is deprecated, use \'scale\' instead",\n+            DeprecationWarning)\n+        mode = "scale"\n     if mode == "scale-crop-to-fit":\n         mode = "contain"\n     if mode == "scale-crop-to-fill":\ndiff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 30ea5b7..6227bda 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -243,7 +243,7 @@ def testDeprecations(self):\n                 str(w[0].message))\n         with warnings.catch_warnings(record=True) as w:\n             warnings.simplefilter("always")\n-            scaleImage(PNG, 16, 16, direction="up")\n+            scaleImage(PNG, 16, 16, direction="keep")\n             self.assertEqual(len(w), 2)\n             self.assertIs(w[0].category, DeprecationWarning)\n             self.assertIn(\n@@ -251,7 +251,7 @@ def testDeprecations(self):\n                 str(w[0].message))\n             self.assertIs(w[1].category, DeprecationWarning)\n             self.assertIn(\n-                "the \'up\' scaling mode is deprecated",\n+                "the \'keep\' scaling mode is deprecated",\n                 str(w[1].message))\n \n \n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Florian Schulze (fschulze) <florian.schulze@gmx.net>
Commit: https://github.com/plone/plone.scale/commit/4ece9b55c80b87fa9ea1d690ff3b56e0facbfd49

Don't turn warnings into errors, this seems to leak into other Plone tests.

Files changed:
M plone/scale/tests/test_scale.py
M plone/scale/tests/test_storage.py

b'diff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 6227bda..56fc04c 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -257,7 +257,4 @@ def testDeprecations(self):\n \n def test_suite():\n     from unittest import defaultTestLoader\n-    from warnings import filterwarnings\n-    filterwarnings("error", "the \'direction\' option is deprecated")\n-    filterwarnings("error", "the \'.*\' scaling mode is deprecated")\n     return defaultTestLoader.loadTestsFromName(__name__)\ndiff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex 6c8524c..fda5de7 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -256,7 +256,4 @@ def testClear(self):\n \n def test_suite():\n     from unittest import defaultTestLoader\n-    from warnings import filterwarnings\n-    filterwarnings("error", "the \'direction\' option is deprecated")\n-    filterwarnings("error", "the \'.*\' scaling mode is deprecated")\n     return defaultTestLoader.loadTestsFromName(__name__)\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/a3010bbc8cebfb099f2ff3344a01424674b31d21

Do not deprecate old direction/mode names.
Simply support all of them.
This change is only to not introduce unnecessary migration work and
people might be used to the old confusing names.
Anyone who gets confused by the names can just use the new ones from PR #29.

Files changed:
M CHANGES.rst
M plone/scale/scale.py
M plone/scale/tests/test_scale.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex fef5e71..fb709a8 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -19,8 +19,6 @@ Bug fixes:\n 3.0.2 (2018-09-28)\n ------------------\n \n-Changes:\n-\n Bug fixes:\n \n - Fix cleanup of image scales in py3\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 99ec27d..f0f0ec5 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -140,15 +140,18 @@ def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None\n     the CSS background-size values\n     (see https://developer.mozilla.org/en-US/docs/Web/CSS/background-size):\n \n-    `contain` or `scale-crop-to-fit`\n+    `contain`\n+        Alternative spellings: `scale-crop-to-fit`, `down`.\n         scaling starts by scaling the largest dimension to the required\n         size and crops the other dimension if needed.\n \n-    `cover` or `scale-crop-to-fill`\n+    `cover`\n+        Alternative spellings: `scale-crop-to-fill`, `up`.\n         scaling scales the smallest dimension up to the required size\n         and crops the other dimension if needed.\n \n     `scale`\n+        Alternative spellings: `keep`, `thumbnail`.\n         scales to the requested dimensions without cropping. The resulting\n         image may have a different size than requested. This option\n         requires both width and height to be specified.\n@@ -173,30 +176,13 @@ def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None\n         mode = direction\n     del direction\n \n-    if mode == "down":\n-        warnings.warn(\n-            "the \'down\' scaling mode is deprecated, use \'contain\' instead",\n-            DeprecationWarning)\n+    if mode in ("scale-crop-to-fit", "down"):\n         mode = "contain"\n-    if mode == "up":\n-        warnings.warn(\n-            "the \'up\' scaling mode is deprecated, use \'cover\' instead",\n-            DeprecationWarning)\n+    elif mode in ("scale-crop-to-fill", "up"):\n         mode = "cover"\n-    if mode == "thumbnail":\n-        warnings.warn(\n-            "the \'thumbnail\' scaling mode is deprecated, use \'scale\' instead",\n-            DeprecationWarning)\n+    elif mode in ("keep", "thumbnail"):\n         mode = "scale"\n-    if mode == "keep":\n-        warnings.warn(\n-            "the \'keep\' scaling mode is deprecated, use \'scale\' instead",\n-            DeprecationWarning)\n-        mode = "scale"\n-    if mode == "scale-crop-to-fit":\n-        mode = "contain"\n-    if mode == "scale-crop-to-fill":\n-        mode = "cover"\n+\n     if mode not in (\'contain\', \'cover\', \'scale\'):\n         raise ValueError("Unknown scale mode \'%s\'" % mode)\n \ndiff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 56fc04c..c50cd1b 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n from plone.scale.scale import scaleImage\n+from plone.scale.scale import scalePILImage\n from plone.scale.tests import TEST_DATA_LOCATION\n from unittest import TestCase\n \n@@ -216,43 +217,57 @@ def testResultBuffer(self):\n         self.assertEqual(result, img2)      # the return value _is_ the buffer\n         self.assertEqual(result.getvalue(), img1)   # but with the same value\n \n+    def testAlternativeSpellings(self):\n+        """Test alternative and deprecated mode spellings and the old\n+        ``direction`` arguments instead of ``mode``.\n+        """\n+\n+        # scale-crop-to-fit\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 5, direction=\'scale-crop-to-fit\')\n+        self.assertEqual(img_scaled.size, (10, 5))\n+        # down\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 5, direction=\'down\')\n+        self.assertEqual(img_scaled.size, (10, 5))\n+\n+        # Test mode cover\n+        # scale-crop-to-fill\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 40, 30, direction=\'scale-crop-to-fill\')\n+        self.assertEqual(img_scaled.size, (30, 30))\n+        # up\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 40, 30, direction=\'up\')\n+        self.assertEqual(img_scaled.size, (30, 30))\n+\n+        # Test mode scale\n+        # keep A\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 20, 10, direction=\'keep\')\n+        self.assertEqual(img_scaled.size, (10, 10))\n+        # keep B\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 40, 80, direction=\'keep\')\n+        self.assertEqual(img_scaled.size, (20, 20))\n+        # thumbnail A\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 20, 10, direction=\'thumbnail\')\n+        self.assertEqual(img_scaled.size, (10, 10))\n+        # thumbnail B\n+        img = PIL.Image.new(\'RGB\', (20, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 40, 80, direction=\'thumbnail\')\n+        self.assertEqual(img_scaled.size, (20, 20))\n+\n     def testDeprecations(self):\n-        with warnings.catch_warnings(record=True) as w:\n-            warnings.simplefilter("always")\n-            scaleImage(PNG, 16, 16, "down")\n-            self.assertEqual(len(w), 1)\n-            self.assertIs(w[0].category, DeprecationWarning)\n-            self.assertIn(\n-                "the \'down\' scaling mode is deprecated",\n-                str(w[0].message))\n-        with warnings.catch_warnings(record=True) as w:\n-            warnings.simplefilter("always")\n-            scaleImage(PNG, 16, 16, "up")\n-            self.assertEqual(len(w), 1)\n-            self.assertIs(w[0].category, DeprecationWarning)\n-            self.assertIn(\n-                "the \'up\' scaling mode is deprecated",\n-                str(w[0].message))\n-        with warnings.catch_warnings(record=True) as w:\n-            warnings.simplefilter("always")\n-            scaleImage(PNG, 16, 16, "thumbnail")\n-            self.assertEqual(len(w), 1)\n-            self.assertIs(w[0].category, DeprecationWarning)\n-            self.assertIn(\n-                "the \'thumbnail\' scaling mode is deprecated",\n-                str(w[0].message))\n         with warnings.catch_warnings(record=True) as w:\n             warnings.simplefilter("always")\n             scaleImage(PNG, 16, 16, direction="keep")\n-            self.assertEqual(len(w), 2)\n+            self.assertEqual(len(w), 1)\n             self.assertIs(w[0].category, DeprecationWarning)\n             self.assertIn(\n                 "the \'direction\' option is deprecated",\n                 str(w[0].message))\n-            self.assertIs(w[1].category, DeprecationWarning)\n-            self.assertIn(\n-                "the \'keep\' scaling mode is deprecated",\n-                str(w[1].message))\n \n \n def test_suite():\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Florian Schulze (fschulze) <mail@florian-schulze.net>
Commit: https://github.com/plone/plone.scale/commit/8d6ccb13cda1d199f2c9c197616ba7e533af8d12

Fix deprecation tests by reseting the warnings registry.

Files changed:
M plone/scale/tests/test_scale.py

b'diff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex c50cd1b..98361c5 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -260,6 +260,9 @@ def testAlternativeSpellings(self):\n         self.assertEqual(img_scaled.size, (20, 20))\n \n     def testDeprecations(self):\n+        import plone.scale.scale\n+        # clear warnings registry, so the test actually sees the warning\n+        plone.scale.scale.__warningregistry__.clear()\n         with warnings.catch_warnings(record=True) as w:\n             warnings.simplefilter("always")\n             scaleImage(PNG, 16, 16, direction="keep")\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Florian Schulze (fschulze) <mail@florian-schulze.net>
Commit: https://github.com/plone/plone.scale/commit/542c7d8fc086617f863f56a880e53bba58ba7f7e

Added ``calculate_scaled_dimensions`` function to calculate sizes from bare values without actually scaling an image.

Files changed:
A news/37.feature
M plone/scale/scale.py

b'diff --git a/news/37.feature b/news/37.feature\nnew file mode 100644\nindex 0000000..564cf77\n--- /dev/null\n+++ b/news/37.feature\n@@ -0,0 +1,5 @@\n+Added ``calculate_scaled_dimensions`` function to calculate sizes from bare values without actually scaling an image.\n+[fschulze]\n+\n+Added ``MAX_PIXELS`` constant set to ``8192*8192`` to prevent memory overflow while scaling.\n+[fschulze]\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex f0f0ec5..6ca668e 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -27,6 +27,8 @@ def none_as_int(the_int):\n # details.\n PIL.ImageFile.MAXBLOCK = 1000000\n \n+MAX_PIXELS = 8192 * 8192\n+\n \n def scaleImage(image, width=None, height=None, mode=\'contain\',\n                quality=88, result=None, direction=None):\n@@ -116,17 +118,203 @@ def _scale_thumbnail(image, width=None, height=None):\n     If target aspect ratio is different, either width or height is smaller\n     than the given target width or height. No cropping!\n     """\n+    dimensions = _calculate_all_dimensions(\n+        image.size[0], image.size[1],\n+        width, height, \'scale\')\n+\n+    if (dimensions.target_width * dimensions.target_height) > MAX_PIXELS:\n+        # The new image would be excessively large and eat up all memory while\n+        # scaling, so return the potentially pre cropped image\n+        return image\n+\n+    image.draft(\n+        image.mode,\n+        (dimensions.target_width, dimensions.target_height))\n+    image = image.resize(\n+        (dimensions.target_width, dimensions.target_height),\n+        PIL.Image.ANTIALIAS)\n+    return image\n+\n+\n+def get_scale_mode(mode, direction):\n+    if direction is not None:\n+        warnings.warn(\n+            "the \'direction\' option is deprecated, use \'mode\' instead",\n+            DeprecationWarning)\n+        mode = direction\n+\n+    if mode in ("scale-crop-to-fit", "down"):\n+        mode = "contain"\n+    elif mode in ("scale-crop-to-fill", "up"):\n+        mode = "cover"\n+    elif mode in ("keep", "thumbnail"):\n+        mode = "scale"\n+\n+    return mode\n+\n+\n+class ScaledDimensions(object):\n+    pass\n+\n+\n+def _calculate_all_dimensions(original_width, original_height, width, height, mode=\'contain\'):\n+    """ Calculate all dimensions we need for scaling.\n+\n+    final_width and final_height are the dimensions of the resulting image and\n+    are always present.\n+\n+    The other values are required for cropping and scaling."""\n+\n     if width is None and height is None:\n         raise ValueError("Either width or height need to be given.")\n-    if width is None:\n-        # calculate a width based on a scale:\n-        size = image.size\n-        width = float(size[0]) / float(size[1]) * height\n-    elif height is None:\n-        size = image.size\n-        height = float(size[1]) / float(size[0]) * width\n-    image.thumbnail((width, height), PIL.Image.ANTIALIAS)\n-    return image\n+\n+    if mode not in (\'contain\', \'cover\', \'scale\'):\n+        raise ValueError("Unknown scale mode \'%s\'" % mode)\n+\n+    dimensions = ScaledDimensions()\n+\n+    if mode == \'scale\':\n+        # first store original size, as it is possible that we won\'t scale at all\n+        dimensions.final_width = original_width\n+        dimensions.final_height = original_height\n+\n+        # calculate missing sizes\n+        if width is None:\n+            width = float(original_width) / float(original_height) * height\n+        elif height is None:\n+            height = float(original_height) / float(original_width) * width\n+\n+        # keep aspect ratio of original\n+        target_width = original_width\n+        target_height = original_height\n+        if target_width > width:\n+            target_height = int(max(target_height * width / target_width, 1))\n+            target_width = int(width)\n+        if target_height > height:\n+            target_width = int(max(target_width * height / target_height, 1))\n+            target_height = int(height)\n+\n+        dimensions.target_width = target_width\n+        dimensions.target_height = target_height\n+\n+        if (target_width * target_height) > MAX_PIXELS:\n+            # The new image would be excessively large and eat up all memory while\n+            # scaling, so return the dimensions of the potentially cropped image\n+            return dimensions\n+\n+        dimensions.final_width = dimensions.target_width\n+        dimensions.final_height = dimensions.target_height\n+        return dimensions\n+\n+    # now for \'cover\' and \'contain\' scaling\n+\n+    # Determine scale factors needed\n+    factor_height = factor_width = None\n+    if height is not None:\n+        factor_height = (float(height) / float(original_height))\n+    if width is not None:\n+        factor_width = (float(width) / float(original_width))\n+\n+    dimensions.factor_width = factor_width\n+    dimensions.factor_height = factor_height\n+    dimensions.final_width = width\n+    dimensions.final_height = height\n+\n+    if factor_height == factor_width:\n+        # The original already has the right aspect ratio\n+        return dimensions\n+\n+    # figure out which axis to scale. One of the factors can still be None!\n+    use_height = none_as_int(factor_width) > none_as_int(factor_height)\n+    if mode == \'cover\':  # for \'cover\': invert\n+        use_height = not use_height\n+\n+    # keep aspect ratio\n+    if (height is None or (use_height and width is not None)):\n+        target_width = width\n+        target_height = int(round(original_height * factor_width))\n+\n+    if (width is None or (height is not None and not use_height)):\n+        target_width = int(round(original_width * factor_height))\n+        target_height = height\n+\n+    # determine whether we need to crop before scaling\n+    pre_scale_crop = (\n+        (width is not None and target_width > width) or\n+        (height is not None and target_height > height))\n+    dimensions.pre_scale_crop = pre_scale_crop\n+\n+    if pre_scale_crop:\n+        # crop image before scaling to avoid excessive memory use\n+        if use_height:\n+            left = 0\n+            right = original_width\n+            top = int(math.floor(\n+                ((target_height - height) / 2.0) / factor_width))\n+            bottom = int(math.ceil(\n+                (((target_height - height) / 2.0) + height) / factor_width))\n+            pre_scale_crop_height = bottom - top\n+            # set new height in case we abort\n+            dimensions.final_height = pre_scale_crop_height\n+            # calculate new scale target_height from cropped height\n+            target_height = int(round(pre_scale_crop_height * factor_width))\n+        else:\n+            left = int(math.floor(\n+                ((target_width - width) / 2.0) / factor_height))\n+            right = int(math.ceil(\n+                (((target_width - width) / 2.0) + width) / factor_height))\n+            top = 0\n+            bottom = original_height\n+            pre_scale_crop_width = right - left\n+            # set new width in case we abort\n+            dimensions.final_width = pre_scale_crop_width\n+            # calculate new scale target_width from cropped width\n+            target_width = int(round(pre_scale_crop_width * factor_height))\n+        dimensions.pre_scale_crop = (left, top, right, bottom)\n+\n+    dimensions.target_width = target_width\n+    dimensions.target_height = target_height\n+\n+    if (target_width * target_height) > MAX_PIXELS:\n+        # The new image would be excessively large and eat up all memory while\n+        # scaling, so return the dimensions of the potentially cropped image\n+        return dimensions\n+\n+    dimensions.final_width = target_width\n+    dimensions.final_height = target_height\n+\n+    # determine whether we have to crop after scaling due to rounding\n+    post_scale_crop = (\n+        (width is not None and target_width > width) or\n+        (height is not None and target_height > height))\n+    dimensions.post_scale_crop = post_scale_crop\n+\n+    if post_scale_crop:\n+        if use_height:\n+            left = 0\n+            right = target_width\n+            top = int((target_height - height) / 2.0)\n+            bottom = top + height\n+            dimensions.final_height = bottom - top\n+        else:\n+            left = int((target_width - width) / 2.0)\n+            right = left + width\n+            top = 0\n+            bottom = target_height\n+            dimensions.final_width = right - left\n+        dimensions.post_scale_crop = (left, top, right, bottom)\n+\n+    return dimensions\n+\n+\n+def calculate_scaled_dimensions(original_width, original_height, width, height, mode=\'contain\'):\n+    """ Calculate the scaled image dimensions from the originals using the\n+    same logic as scalePILImage """\n+    dimensions = _calculate_all_dimensions(\n+        original_width, original_height,\n+        width, height, mode)\n+\n+    return (dimensions.final_width, dimensions.final_height)\n \n \n def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None):\n@@ -169,22 +357,7 @@ def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None\n     if width is None and height is None:\n         raise ValueError("Either width or height need to be given")\n \n-    if direction is not None:\n-        warnings.warn(\n-            "the \'direction\' option is deprecated, use \'mode\' instead",\n-            DeprecationWarning)\n-        mode = direction\n-    del direction\n-\n-    if mode in ("scale-crop-to-fit", "down"):\n-        mode = "contain"\n-    elif mode in ("scale-crop-to-fill", "up"):\n-        mode = "cover"\n-    elif mode in ("keep", "thumbnail"):\n-        mode = "scale"\n-\n-    if mode not in (\'contain\', \'cover\', \'scale\'):\n-        raise ValueError("Unknown scale mode \'%s\'" % mode)\n+    mode = get_scale_mode(mode, direction)\n \n     if image.mode == "1":\n         # Convert black&white to grayscale\n@@ -205,82 +378,41 @@ def scalePILImage(image, width=None, height=None, mode=\'contain\', direction=None\n     if mode == \'scale\':\n         return _scale_thumbnail(image, width, height)\n \n-    # now for cover and contain scaling\n-    # Determine scale factor needed to get the right height\n-    factor_height = factor_width = None\n-    if height is not None:\n-        factor_height = (float(height) / float(image.size[1]))\n-    if width is not None:\n-        factor_width = (float(width) / float(image.size[0]))\n+    dimensions = _calculate_all_dimensions(\n+        image.size[0], image.size[1],\n+        width, height, mode)\n \n-    if factor_height == factor_width:\n+    if dimensions.factor_height == dimensions.factor_width:\n         # The original already has the right aspect ratio, so we only need\n         # to scale.\n         if mode == \'contain\':\n-            image.thumbnail((width, height), PIL.Image.ANTIALIAS)\n+            image.thumbnail(\n+                (dimensions.final_width, dimensions.final_height),\n+                PIL.Image.ANTIALIAS)\n             return image\n-        return image.resize((width, height), PIL.Image.ANTIALIAS)\n-\n-    # figure out which axis to scale. One of the factors can still be None!\n-    # calculate for \'contain\'\n-    use_height = none_as_int(factor_width) > none_as_int(factor_height)\n-    if mode == \'cover\':  # for \'cover\': invert\n-        use_height = not use_height\n-\n-    new_width = width\n-    new_height = height\n-\n-    # keep aspect ratio, crop later\n-    if (height is None or (use_height and width is not None)):\n-        new_height = int(round(image.size[1] * factor_width))\n-\n-    if (width is None or (height is not None and not use_height)):\n-        new_width = int(round(image.size[0] * factor_height))\n-\n-    crop = (\n-        (width is not None and new_width > width) or\n-        (height is not None and new_height > height))\n+        return image.resize(\n+            (dimensions.final_width, dimensions.final_height),\n+            PIL.Image.ANTIALIAS)\n \n-    if crop:\n+    if dimensions.pre_scale_crop:\n         # crop image before scaling to avoid excessive memory use\n-        if use_height:\n-            image = image.crop((\n-                0,\n-                int(math.floor(((new_height - height) / 2.0) / factor_width)),\n-                image.size[0],\n-                int(math.ceil((((new_height - height) / 2.0) + height) / factor_width))))\n-            new_height = int(round(image.size[1] * factor_width))\n-        else:\n-            image = image.crop((\n-                int(math.floor(((new_width - width) / 2.0) / factor_height)),\n-                0,\n-                int(math.ceil((((new_width - width) / 2.0) + width) / factor_height)),\n-                image.size[1]))\n-            new_width = int(round(image.size[0] * factor_height))\n-\n-    if (new_width * new_height) > (8192 * 8192):\n+        # in case the intermediate result would be very tall or wide\n+        image = image.crop(dimensions.pre_scale_crop)\n+\n+    if (dimensions.target_width * dimensions.target_height) > MAX_PIXELS:\n         # The new image would be excessively large and eat up all memory while\n         # scaling, so return the potentially pre cropped image\n         return image\n \n-    image.draft(image.mode, (new_width, new_height))\n-    image = image.resize((new_width, new_height), PIL.Image.ANTIALIAS)\n+    image.draft(\n+        image.mode,\n+        (dimensions.target_width, dimensions.target_height))\n+    image = image.resize(\n+        (dimensions.target_width, dimensions.target_height),\n+        PIL.Image.ANTIALIAS)\n \n-    crop = (\n-        (width is not None and new_width > width) or\n-        (height is not None and new_height > height))\n-\n-    if crop:\n-        if use_height:\n-            left = 0\n-            right = new_width\n-            top = int((new_height - height) / 2.0)\n-            bottom = top + height\n-        else:\n-            left = int((new_width - width) / 2.0)\n-            right = left + width\n-            top = 0\n-            bottom = new_height\n-        image = image.crop((left, top, right, bottom))\n+    if dimensions.post_scale_crop:\n+        # crop off remains due to rounding before scaling\n+        image = image.crop(dimensions.post_scale_crop)\n \n     return image\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/7cae9ad071ea366062384fc9dc5daf4465175f28

Add failing test to prove @mauritsvanrees comment https://github.com/plone/plone.scale/pull/36/files#r377915411 right

Files changed:
M plone/scale/tests/test_scale.py

b'diff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 98361c5..a831e16 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -259,6 +259,69 @@ def testAlternativeSpellings(self):\n         img_scaled = scalePILImage(img, 40, 80, direction=\'thumbnail\')\n         self.assertEqual(img_scaled.size, (20, 20))\n \n+    def testModes(self):\n+        """Test modes to actually behavie like documented.\n+        """\n+        # Mode contain\n+        # v\n+        # A\n+        img = PIL.Image.new(\'RGB\', (10, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 5, 5, mode=\'contain\')\n+        self.assertEqual(img_scaled.size, (2, 5))\n+        # B\n+        img = PIL.Image.new(\'RGB\', (20, 10), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 5, 5, mode=\'contain\')\n+        self.assertEqual(img_scaled.size, (5, 2))\n+        # ^\n+        # A\n+        img = PIL.Image.new(\'RGB\', (10, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 30, 30, mode=\'contain\')\n+        self.assertEqual(img_scaled.size, (15, 30))\n+        # B\n+        img = PIL.Image.new(\'RGB\', (20, 10), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 30, 30, mode=\'contain\')\n+        self.assertEqual(img_scaled.size, (30, 15))\n+\n+        # Mode cover\n+        # v\n+        # A\n+        img = PIL.Image.new(\'RGB\', (10, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 5, 5, mode=\'cover\')\n+        self.assertEqual(img_scaled.size, (5, 5))\n+        # B\n+        img = PIL.Image.new(\'RGB\', (20, 10), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 5, 5, mode=\'cover\')\n+        self.assertEqual(img_scaled.size, (5, 5))\n+        # ^\n+        # A\n+        img = PIL.Image.new(\'RGB\', (10, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 30, 30, mode=\'cover\')\n+        self.assertEqual(img_scaled.size, (30, 30))\n+        # B\n+        img = PIL.Image.new(\'RGB\', (20, 10), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 30, 30, mode=\'cover\')\n+        self.assertEqual(img_scaled.size, (30, 30))\n+\n+        # Mode scale\n+        # v\n+        # A\n+        img = PIL.Image.new(\'RGB\', (10, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 5, 5, mode=\'scale\')\n+        self.assertEqual(img_scaled.size, (2, 5))\n+        # B\n+        img = PIL.Image.new(\'RGB\', (20, 10), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 5, 5, mode=\'scale\')\n+        self.assertEqual(img_scaled.size, (5, 2))\n+        # ^\n+        # A\n+        img = PIL.Image.new(\'RGB\', (10, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 30, 30, mode=\'scale\')\n+        self.assertEqual(img_scaled.size, (15, 30))\n+        # B\n+        img = PIL.Image.new(\'RGB\', (20, 10), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 30, 30, mode=\'scale\')\n+        self.assertEqual(img_scaled.size, (30, 15))\n+\n     def testDeprecations(self):\n         import plone.scale.scale\n         # clear warnings registry, so the test actually sees the warning\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/0326149525ec8a39b8f74506c67b15c5aa6801c1

Fix documentation of scaling modes to match it's behavior.

Files changed:
A news/39.hotfix
M plone/scale/scale.py
M plone/scale/tests/test_scale.py

b"diff --git a/news/39.hotfix b/news/39.hotfix\nnew file mode 100644\nindex 0000000..047b099\n--- /dev/null\n+++ b/news/39.hotfix\n@@ -0,0 +1,2 @@\n+Fix documentation of scaling modes to match it's behavior.\n+[thet]\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 6ca668e..16cb745 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -330,19 +330,20 @@ def scalePILImage(image, width=None, height=None, mode='contain', direction=None\n \n     `contain`\n         Alternative spellings: `scale-crop-to-fit`, `down`.\n-        scaling starts by scaling the largest dimension to the required\n+        Starts by scaling the smallest dimension to the required\n         size and crops the other dimension if needed.\n \n     `cover`\n         Alternative spellings: `scale-crop-to-fill`, `up`.\n-        scaling scales the smallest dimension up to the required size\n+        Starts by scaling the largest dimension up to the required size\n         and crops the other dimension if needed.\n \n     `scale`\n         Alternative spellings: `keep`, `thumbnail`.\n-        scales to the requested dimensions without cropping. The resulting\n+        Scales to the requested dimensions without cropping. The resulting\n         image may have a different size than requested. This option\n         requires both width and height to be specified.\n+        Does not scale up.\n \n     The `image` parameter must be an instance of the `PIL.Image` class.\n \ndiff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex a831e16..08af006 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -267,40 +267,40 @@ def testModes(self):\n         # A\n         img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n         img_scaled = scalePILImage(img, 5, 5, mode='contain')\n-        self.assertEqual(img_scaled.size, (2, 5))\n+        self.assertEqual(img_scaled.size, (5, 5))\n         # B\n         img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n         img_scaled = scalePILImage(img, 5, 5, mode='contain')\n-        self.assertEqual(img_scaled.size, (5, 2))\n+        self.assertEqual(img_scaled.size, (5, 5))\n         # ^\n         # A\n         img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n         img_scaled = scalePILImage(img, 30, 30, mode='contain')\n-        self.assertEqual(img_scaled.size, (15, 30))\n+        self.assertEqual(img_scaled.size, (30, 30))\n         # B\n         img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n         img_scaled = scalePILImage(img, 30, 30, mode='contain')\n-        self.assertEqual(img_scaled.size, (30, 15))\n+        self.assertEqual(img_scaled.size, (30, 30))\n \n         # Mode cover\n         # v\n         # A\n         img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n         img_scaled = scalePILImage(img, 5, 5, mode='cover')\n-        self.assertEqual(img_scaled.size, (5, 5))\n+        self.assertEqual(img_scaled.size, (2, 5))\n         # B\n         img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n         img_scaled = scalePILImage(img, 5, 5, mode='cover')\n-        self.assertEqual(img_scaled.size, (5, 5))\n+        self.assertEqual(img_scaled.size, (5, 2))\n         # ^\n         # A\n         img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n         img_scaled = scalePILImage(img, 30, 30, mode='cover')\n-        self.assertEqual(img_scaled.size, (30, 30))\n+        self.assertEqual(img_scaled.size, (15, 30))\n         # B\n         img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n         img_scaled = scalePILImage(img, 30, 30, mode='cover')\n-        self.assertEqual(img_scaled.size, (30, 30))\n+        self.assertEqual(img_scaled.size, (30, 15))\n \n         # Mode scale\n         # v\n@@ -316,11 +316,11 @@ def testModes(self):\n         # A\n         img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n         img_scaled = scalePILImage(img, 30, 30, mode='scale')\n-        self.assertEqual(img_scaled.size, (15, 30))\n+        self.assertEqual(img_scaled.size, (10, 20))\n         # B\n         img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n         img_scaled = scalePILImage(img, 30, 30, mode='scale')\n-        self.assertEqual(img_scaled.size, (30, 15))\n+        self.assertEqual(img_scaled.size, (20, 10))\n \n     def testDeprecations(self):\n         import plone.scale.scale\n"

Repository: plone.scale


Branch: refs/heads/master
Date: 2020-02-17T17:59:24+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/b442814a8cd9b2c4c16057459d09813d861b9e77

Double test image scales to in testModes to prevent rounding differences btw. Py3/Py2

Files changed:
M plone/scale/tests/test_scale.py

b"diff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 08af006..0c1d57c 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -265,62 +265,62 @@ def testModes(self):\n         # Mode contain\n         # v\n         # A\n-        img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 5, 5, mode='contain')\n-        self.assertEqual(img_scaled.size, (5, 5))\n+        img = PIL.Image.new('RGB', (20, 40), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 10, mode='contain')\n+        self.assertEqual(img_scaled.size, (10, 10))\n         # B\n-        img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 5, 5, mode='contain')\n-        self.assertEqual(img_scaled.size, (5, 5))\n+        img = PIL.Image.new('RGB', (40, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 10, mode='contain')\n+        self.assertEqual(img_scaled.size, (10, 10))\n         # ^\n         # A\n-        img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 30, 30, mode='contain')\n-        self.assertEqual(img_scaled.size, (30, 30))\n+        img = PIL.Image.new('RGB', (20, 40), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 60, 60, mode='contain')\n+        self.assertEqual(img_scaled.size, (60, 60))\n         # B\n-        img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 30, 30, mode='contain')\n-        self.assertEqual(img_scaled.size, (30, 30))\n+        img = PIL.Image.new('RGB', (40, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 60, 60, mode='contain')\n+        self.assertEqual(img_scaled.size, (60, 60))\n \n         # Mode cover\n         # v\n         # A\n-        img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 5, 5, mode='cover')\n-        self.assertEqual(img_scaled.size, (2, 5))\n+        img = PIL.Image.new('RGB', (20, 40), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 10, mode='cover')\n+        self.assertEqual(img_scaled.size, (5, 10))\n         # B\n-        img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 5, 5, mode='cover')\n-        self.assertEqual(img_scaled.size, (5, 2))\n+        img = PIL.Image.new('RGB', (40, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 10, mode='cover')\n+        self.assertEqual(img_scaled.size, (10, 5))\n         # ^\n         # A\n-        img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 30, 30, mode='cover')\n-        self.assertEqual(img_scaled.size, (15, 30))\n+        img = PIL.Image.new('RGB', (20, 40), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 60, 60, mode='cover')\n+        self.assertEqual(img_scaled.size, (30, 60))\n         # B\n-        img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 30, 30, mode='cover')\n-        self.assertEqual(img_scaled.size, (30, 15))\n+        img = PIL.Image.new('RGB', (40, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 60, 60, mode='cover')\n+        self.assertEqual(img_scaled.size, (60, 30))\n \n         # Mode scale\n         # v\n         # A\n-        img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 5, 5, mode='scale')\n-        self.assertEqual(img_scaled.size, (2, 5))\n+        img = PIL.Image.new('RGB', (20, 40), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 10, mode='scale')\n+        self.assertEqual(img_scaled.size, (5, 10))\n         # B\n-        img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 5, 5, mode='scale')\n-        self.assertEqual(img_scaled.size, (5, 2))\n+        img = PIL.Image.new('RGB', (40, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 10, 10, mode='scale')\n+        self.assertEqual(img_scaled.size, (10, 5))\n         # ^\n         # A\n-        img = PIL.Image.new('RGB', (10, 20), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 30, 30, mode='scale')\n-        self.assertEqual(img_scaled.size, (10, 20))\n+        img = PIL.Image.new('RGB', (20, 40), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 60, 60, mode='scale')\n+        self.assertEqual(img_scaled.size, (20, 40))\n         # B\n-        img = PIL.Image.new('RGB', (20, 10), (0, 0, 0))\n-        img_scaled = scalePILImage(img, 30, 30, mode='scale')\n-        self.assertEqual(img_scaled.size, (20, 10))\n+        img = PIL.Image.new('RGB', (40, 20), (0, 0, 0))\n+        img_scaled = scalePILImage(img, 60, 60, mode='scale')\n+        self.assertEqual(img_scaled.size, (40, 20))\n \n     def testDeprecations(self):\n         import plone.scale.scale\n"

