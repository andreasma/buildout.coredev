Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2018-10-06T15:19:34+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/485f2ed7dd9872b7d3f9f80d081e6ea404061dad

Added utils.check_id function.

This current simply calls the `check_id.py` skin script.
In Plone 5.2 the function will replace the script.

See https://github.com/plone/Products.CMFPlone/issues/2582.

Files changed:
M CHANGES.rst
M Products/CMFPlone/tests/testCheckId.py
M Products/CMFPlone/utils.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 316c03102..8b338ea94 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,6 +14,12 @@ Breaking changes:\n \n New features:\n \n+- Added ``utils.check_id`` function.\n+  This current simply calls the ``check_id.py`` skin script.\n+  In Plone 5.2 the function will replace the script.\n+  See `issue 2582 <https://github.com/plone/Products.CMFPlone/issues/2582>`_.\n+  [maurits]\n+\n - Added utils.human_readable_size.\n   https://github.com/plone/Products.CMFPlone/issues/1801\n   [reinhardt]\ndiff --git a/Products/CMFPlone/tests/testCheckId.py b/Products/CMFPlone/tests/testCheckId.py\nindex 75a2d2d1f..65c1e3de1 100644\n--- a/Products/CMFPlone/tests/testCheckId.py\n+++ b/Products/CMFPlone/tests/testCheckId.py\n@@ -3,6 +3,7 @@\n from plone.app.testing.bbb import PloneTestCase\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.tests import dummy\n+from Products.CMFPlone.utils import check_id\n from ZODB.POSException import ConflictError\n \n \n@@ -48,28 +49,32 @@ def testValidPortalTypeNameButNotAutoGeneratedId(self):\n class TestCheckId(PloneTestCase):\n \n     def testGoodId(self):\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testEmptyId(self):\n-        r = self.folder.check_id(\'\')\n+        r = check_id(self.folder, \'\')\n         self.assertEqual(r, None)   # success\n \n     def testRequiredId(self):\n-        r = self.folder.check_id(\'\', required=1)\n+        r = check_id(self.folder, \'\', required=1)\n         self.assertEqual(r, u\'Please enter a name.\')\n \n     def testAlternativeId(self):\n-        r = self.folder.check_id(\'\', alternative_id=\'foo\')\n+        r = check_id(self.folder, \'\', alternative_id=\'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testBadId(self):\n-        r = self.folder.check_id(\'=\')\n+        # Note that is fine in Zope 4.\n+        # See https://github.com/zopefoundation/Zope/pull/181\n+        r = check_id(self.folder, \'=\')\n         self.assertEqual(r, u\'= is not a legal name. The following characters \'\n                             u\'are invalid: =\')\n \n     def testDecodeId(self):\n-        r = self.folder.check_id(\'\\xc3\\xa4\')\n+        # Note that is fine in Zope 4.\n+        # See https://github.com/zopefoundation/Zope/pull/181\n+        r = check_id(self.folder, \'\\xc3\\xa4\')\n         self.assertEqual(r, u\'\\xe4 is not a legal name. The following \'\n                             u\'characters are invalid: \\xe4\')\n \n@@ -81,7 +86,7 @@ def testCatalogIndex(self):\n                                         self.portal.portal_catalog),\n                         \'Expected permission "Search ZCatalog"\')\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         self.assertEqual(r, u\'created is reserved.\')\n \n     def testCatalogMetadata(self):\n@@ -89,80 +94,80 @@ def testCatalogMetadata(self):\n         portal_catalog.addColumn(\'new_metadata\')\n         self.assertTrue(\'new_metadata\' in portal_catalog.schema())\n         self.assertFalse(\'new_metadata\' in portal_catalog.indexes())\n-        r = self.folder.check_id(\'new_metadata\')\n+        r = check_id(self.folder, \'new_metadata\')\n         self.assertEqual(r, u\'new_metadata is reserved.\')\n \n     def testCollision(self):\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n         self.folder.invokeFactory(\'Document\', id=\'bar\')\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, u\'There is already an item named bar in this \'\n                             u\'folder.\')\n \n     def testTempObjectCollision(self):\n         foo = self.folder.restrictedTraverse(\'portal_factory/Document/foo\')\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = foo.check_id(\'bar\')\n+        r = check_id(foo, \'bar\')\n         self.assertEqual(r, u\'bar is reserved.\')\n \n     def testReservedId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testHiddenObjectId(self):\n         # If a parallel object is not in content-space, should get \'reserved\'\n         # instead of \'taken\'\n-        r = self.folder.check_id(\'portal_skins\')\n+        r = check_id(self.folder, \'portal_skins\')\n         self.assertEqual(r, u\'portal_skins is reserved.\')\n \n     def testCanOverrideParentNames(self):\n         self.folder.invokeFactory(\'Document\', id=\'item1\')\n         self.folder.invokeFactory(\'Folder\', id=\'folder1\')\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n-        r = self.folder.folder1.foo.check_id(\'item1\')\n+        r = check_id(self.folder.folder1.foo, \'item1\')\n         self.assertEqual(r, None)\n \n     def testInvalidId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, u\'_foo is reserved.\')\n \n     def testContainerHook(self):\n         # Container may have a checkValidId method; make sure it is called\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(dummy.Error))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'whatever\')\n+        r = check_id(self.folder.foo, \'whatever\')\n         self.assertEqual(r, u\'whatever is reserved.\')\n \n     def testContainerHookRaisesUnauthorized(self):\n         # check_id should not swallow Unauthorized errors raised by hook\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(Unauthorized))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        self.assertRaises(Unauthorized, self.folder.foo.check_id, \'whatever\')\n+        self.assertRaises(Unauthorized, check_id(self.folder.foo), \'whatever\')\n \n     def testContainerHookRaisesConflictError(self):\n         # check_id should not swallow ConflictErrors raised by hook\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(ConflictError))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        self.assertRaises(ConflictError, self.folder.foo.check_id, \'whatever\')\n+        self.assertRaises(ConflictError, check_id(self.folder.foo), \'whatever\')\n \n     def testMissingUtils(self):\n         # check_id should not bomb out if the plone_utils tool is missing\n         self.portal._delObject(\'plone_utils\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingCatalog(self):\n         # check_id should not bomb out if the portal_catalog tool is missing\n         self.portal._delObject(\'portal_catalog\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingFactory(self):\n         # check_id should not bomb out if the portal_factory tool is missing\n         self.portal._delObject(\'portal_factory\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testCatalogIndexSkipped(self):\n@@ -171,7 +176,7 @@ def testCatalogIndexSkipped(self):\n         self.portal.manage_permission(\'Search ZCatalog\', [\'Manager\'],\n                                       acquire=0)\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         # But now the final hasattr check picks this up\n         self.assertEqual(r, u\'created is reserved.\')\n \n@@ -183,7 +188,7 @@ def testCollisionSkipped(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, None)   # success\n \n     def testReservedIdSkipped(self):\n@@ -193,7 +198,7 @@ def testReservedIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testInvalidIdSkipped(self):\n@@ -202,7 +207,7 @@ def testInvalidIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, None)   # success\n \n     def testParentMethodAliasDisallowed(self):\n@@ -213,7 +218,7 @@ def testParentMethodAliasDisallowed(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         for alias in self.folder.getTypeInfo().getMethodAliases().keys():\n-            r = self.folder.foo.check_id(alias)\n+            r = check_id(self.folder.foo, alias)\n             self.assertEqual(r, u\'%s is reserved.\' % alias)\n \n     def testCheckingMethodAliasesOnPortalRoot(self):\n@@ -225,8 +230,8 @@ def testCheckingMethodAliasesOnPortalRoot(self):\n         # Should not raise: Before we were using obj.getTypeInfo(), which is\n         # not defined on the portal root.\n         try:\n-            self.portal.check_id(\'foo\')\n-        except AttributeError, e:\n+            check_id(self.portal, \'foo\')\n+        except AttributeError as e:\n             self.fail(e)\n \n     def testProxyRoles(self):\ndiff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 2a95af37a..fdb1fc4ea 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -826,3 +826,23 @@ def human_readable_size(size):\n                 break\n         return \'%.1f %s\' % (float(size / float(SIZE_CONST[c])), c)\n     return size\n+\n+\n+def check_id(\n+        context, id=None, required=0, alternative_id=None, contained_by=None,\n+        **kwargs):\n+    """Test an id to make sure it is valid.\n+\n+    In Plone 5.2, this function will replace\n+    Products/CMFPlone/skins/plone_scripts/check_id.py.\n+    But here in Plone 5.1, the function calls that same script,\n+    so that there should be no subtle differences with permissions.\n+    See https://github.com/plone/Products.CMFPlone/issues/2582\n+\n+    Returns an error message if the id is bad or None if the id is good.\n+    For more info, see that script.\n+    """\n+    return context.check_id(\n+        id=id, required=required, alternative_id=alternative_id,\n+        contained_by=contained_by,\n+        **kwargs)\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2018-10-06T16:34:24+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/406d94e22f76978b220fb71c2301c9e4ceea5f94

context.check_id may be None in tests.

Files changed:
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex fdb1fc4ea..865f481cb 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -842,7 +842,11 @@ def check_id(\n     Returns an error message if the id is bad or None if the id is good.\n     For more info, see that script.\n     """\n-    return context.check_id(\n+    script = getattr(context, \'check_id\', None)\n+    if script is None:\n+        # May happen during tests.\n+        return None\n+    return script(\n         id=id, required=required, alternative_id=alternative_id,\n         contained_by=contained_by,\n         **kwargs)\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2018-10-08T21:13:25+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/7921e72190362e05b6f1700369565a2238162a19

Add decent fallback for check_id.

Mostly needed in tests.

Files changed:
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 865f481cb..040134744 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -32,6 +32,7 @@\n from types import ClassType\n from urlparse import urlparse\n from webdav.interfaces import IWriteLock\n+from zExceptions import BadRequest\n from zope import schema\n from zope.component import getMultiAdapter\n from zope.component import getUtility\n@@ -833,20 +834,63 @@ def check_id(\n         **kwargs):\n     """Test an id to make sure it is valid.\n \n+    Returns an error message if the id is bad or None if the id is good.\n+\n     In Plone 5.2, this function will replace\n     Products/CMFPlone/skins/plone_scripts/check_id.py.\n     But here in Plone 5.1, the function calls that same script,\n     so that there should be no subtle differences with permissions.\n     See https://github.com/plone/Products.CMFPlone/issues/2582\n \n-    Returns an error message if the id is bad or None if the id is good.\n-    For more info, see that script.\n+    For more info on the keyword arguments, see that script.\n+\n+    We need to fall back to a basic check though, otherwise\n+    several tests that rely on this fallback will fail,\n+    for example simple content added in a way where the script is\n+    not available.  Several packages have their own fallback code\n+    for the case that \'check_id\' does not exist:\n+\n+    - Products.Archetypes and Products.ATContentTypes both simply check if\n+      id is in parent.objectIds().\n+    - plone.app.content tries parent._checkId(newid) from OFS.ObjectManager\n+      and catches a possible BadRequest exception to return True instead.\n+      This method checks for stuff like not allowing \'..\' as name,\n+      or names starting with an underscore.  This includes a check for\n+      an existing item when called with allow_dup=False.\n+    - Products.validation has an IdValidator which disallows a space in the id,\n+      checks if the id is given to a different object already,\n+      and calls ObjectManager.checkValidId, which is the same as _checkId.\n+\n+    Note that Products.validation is the only one that needs to\n+    do special stuff for checking if the conflicting item is the same as\n+    the current item being edited.  All others are about adding a new one.\n+\n+    We do a fallback that should cover all these cases.\n     """\n     script = getattr(context, \'check_id\', None)\n-    if script is None:\n-        # May happen during tests.\n-        return None\n-    return script(\n-        id=id, required=required, alternative_id=alternative_id,\n-        contained_by=contained_by,\n-        **kwargs)\n+    if script is not None:\n+        # We have found Products/CMFPlone/skins/plone_scripts/check_id.py\n+        # or an override.  This is the expected standard case.\n+        return script(\n+            id=id, required=required, alternative_id=alternative_id,\n+            contained_by=contained_by,\n+            **kwargs)\n+    if contained_by is None:\n+        contained_by = aq_parent(aq_inner(context))\n+    if contained_by is None:\n+        return\n+    # Check for existence.\n+    if (id in contained_by.objectIds() and\n+            getattr(aq_base(contained_by), id) is not aq_base(context)):\n+        return _(u\'There is already an item named ${name} in this folder.\',\n+                  mapping={u\'name\': safe_unicode(id)})\n+    # The container may have the _checkId method from OFS or plone.folder.\n+    # We use this only to check for invalid characters, not for duplicates,\n+    # because we did that already.\n+    script = getattr(contained_by, \'_checkId\', None)\n+    if script is not None:\n+        try:\n+            return contained_by._checkId(id, allow_dup=True)\n+        except BadRequest as exc:\n+            return str(exc)\n+        return\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.1.x
Date: 2018-10-22T21:22:00+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/a6b87803680408c629fd245d4bbce84bed3a84d1

Merge pull request #2584 from plone/add-checkid-function-51

Added utils.check_id function. [5.1]

Files changed:
M CHANGES.rst
M Products/CMFPlone/tests/testCheckId.py
M Products/CMFPlone/utils.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex ef4f62ab3..ee9dcc60f 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -36,6 +36,12 @@ Bug fixes:\n \n New features:\n \n+- Added ``utils.check_id`` function.\n+  This current simply calls the ``check_id.py`` skin script.\n+  In Plone 5.2 the function will replace the script.\n+  See `issue 2582 <https://github.com/plone/Products.CMFPlone/issues/2582>`_.\n+  [maurits]\n+\n - Added utils.human_readable_size.\n   https://github.com/plone/Products.CMFPlone/issues/1801\n   [reinhardt]\ndiff --git a/Products/CMFPlone/tests/testCheckId.py b/Products/CMFPlone/tests/testCheckId.py\nindex 75a2d2d1f..65c1e3de1 100644\n--- a/Products/CMFPlone/tests/testCheckId.py\n+++ b/Products/CMFPlone/tests/testCheckId.py\n@@ -3,6 +3,7 @@\n from plone.app.testing.bbb import PloneTestCase\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.tests import dummy\n+from Products.CMFPlone.utils import check_id\n from ZODB.POSException import ConflictError\n \n \n@@ -48,28 +49,32 @@ def testValidPortalTypeNameButNotAutoGeneratedId(self):\n class TestCheckId(PloneTestCase):\n \n     def testGoodId(self):\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testEmptyId(self):\n-        r = self.folder.check_id(\'\')\n+        r = check_id(self.folder, \'\')\n         self.assertEqual(r, None)   # success\n \n     def testRequiredId(self):\n-        r = self.folder.check_id(\'\', required=1)\n+        r = check_id(self.folder, \'\', required=1)\n         self.assertEqual(r, u\'Please enter a name.\')\n \n     def testAlternativeId(self):\n-        r = self.folder.check_id(\'\', alternative_id=\'foo\')\n+        r = check_id(self.folder, \'\', alternative_id=\'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testBadId(self):\n-        r = self.folder.check_id(\'=\')\n+        # Note that is fine in Zope 4.\n+        # See https://github.com/zopefoundation/Zope/pull/181\n+        r = check_id(self.folder, \'=\')\n         self.assertEqual(r, u\'= is not a legal name. The following characters \'\n                             u\'are invalid: =\')\n \n     def testDecodeId(self):\n-        r = self.folder.check_id(\'\\xc3\\xa4\')\n+        # Note that is fine in Zope 4.\n+        # See https://github.com/zopefoundation/Zope/pull/181\n+        r = check_id(self.folder, \'\\xc3\\xa4\')\n         self.assertEqual(r, u\'\\xe4 is not a legal name. The following \'\n                             u\'characters are invalid: \\xe4\')\n \n@@ -81,7 +86,7 @@ def testCatalogIndex(self):\n                                         self.portal.portal_catalog),\n                         \'Expected permission "Search ZCatalog"\')\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         self.assertEqual(r, u\'created is reserved.\')\n \n     def testCatalogMetadata(self):\n@@ -89,80 +94,80 @@ def testCatalogMetadata(self):\n         portal_catalog.addColumn(\'new_metadata\')\n         self.assertTrue(\'new_metadata\' in portal_catalog.schema())\n         self.assertFalse(\'new_metadata\' in portal_catalog.indexes())\n-        r = self.folder.check_id(\'new_metadata\')\n+        r = check_id(self.folder, \'new_metadata\')\n         self.assertEqual(r, u\'new_metadata is reserved.\')\n \n     def testCollision(self):\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n         self.folder.invokeFactory(\'Document\', id=\'bar\')\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, u\'There is already an item named bar in this \'\n                             u\'folder.\')\n \n     def testTempObjectCollision(self):\n         foo = self.folder.restrictedTraverse(\'portal_factory/Document/foo\')\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = foo.check_id(\'bar\')\n+        r = check_id(foo, \'bar\')\n         self.assertEqual(r, u\'bar is reserved.\')\n \n     def testReservedId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testHiddenObjectId(self):\n         # If a parallel object is not in content-space, should get \'reserved\'\n         # instead of \'taken\'\n-        r = self.folder.check_id(\'portal_skins\')\n+        r = check_id(self.folder, \'portal_skins\')\n         self.assertEqual(r, u\'portal_skins is reserved.\')\n \n     def testCanOverrideParentNames(self):\n         self.folder.invokeFactory(\'Document\', id=\'item1\')\n         self.folder.invokeFactory(\'Folder\', id=\'folder1\')\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n-        r = self.folder.folder1.foo.check_id(\'item1\')\n+        r = check_id(self.folder.folder1.foo, \'item1\')\n         self.assertEqual(r, None)\n \n     def testInvalidId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, u\'_foo is reserved.\')\n \n     def testContainerHook(self):\n         # Container may have a checkValidId method; make sure it is called\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(dummy.Error))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'whatever\')\n+        r = check_id(self.folder.foo, \'whatever\')\n         self.assertEqual(r, u\'whatever is reserved.\')\n \n     def testContainerHookRaisesUnauthorized(self):\n         # check_id should not swallow Unauthorized errors raised by hook\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(Unauthorized))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        self.assertRaises(Unauthorized, self.folder.foo.check_id, \'whatever\')\n+        self.assertRaises(Unauthorized, check_id(self.folder.foo), \'whatever\')\n \n     def testContainerHookRaisesConflictError(self):\n         # check_id should not swallow ConflictErrors raised by hook\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(ConflictError))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        self.assertRaises(ConflictError, self.folder.foo.check_id, \'whatever\')\n+        self.assertRaises(ConflictError, check_id(self.folder.foo), \'whatever\')\n \n     def testMissingUtils(self):\n         # check_id should not bomb out if the plone_utils tool is missing\n         self.portal._delObject(\'plone_utils\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingCatalog(self):\n         # check_id should not bomb out if the portal_catalog tool is missing\n         self.portal._delObject(\'portal_catalog\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingFactory(self):\n         # check_id should not bomb out if the portal_factory tool is missing\n         self.portal._delObject(\'portal_factory\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testCatalogIndexSkipped(self):\n@@ -171,7 +176,7 @@ def testCatalogIndexSkipped(self):\n         self.portal.manage_permission(\'Search ZCatalog\', [\'Manager\'],\n                                       acquire=0)\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         # But now the final hasattr check picks this up\n         self.assertEqual(r, u\'created is reserved.\')\n \n@@ -183,7 +188,7 @@ def testCollisionSkipped(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, None)   # success\n \n     def testReservedIdSkipped(self):\n@@ -193,7 +198,7 @@ def testReservedIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testInvalidIdSkipped(self):\n@@ -202,7 +207,7 @@ def testInvalidIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, None)   # success\n \n     def testParentMethodAliasDisallowed(self):\n@@ -213,7 +218,7 @@ def testParentMethodAliasDisallowed(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         for alias in self.folder.getTypeInfo().getMethodAliases().keys():\n-            r = self.folder.foo.check_id(alias)\n+            r = check_id(self.folder.foo, alias)\n             self.assertEqual(r, u\'%s is reserved.\' % alias)\n \n     def testCheckingMethodAliasesOnPortalRoot(self):\n@@ -225,8 +230,8 @@ def testCheckingMethodAliasesOnPortalRoot(self):\n         # Should not raise: Before we were using obj.getTypeInfo(), which is\n         # not defined on the portal root.\n         try:\n-            self.portal.check_id(\'foo\')\n-        except AttributeError, e:\n+            check_id(self.portal, \'foo\')\n+        except AttributeError as e:\n             self.fail(e)\n \n     def testProxyRoles(self):\ndiff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 2a95af37a..040134744 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -32,6 +32,7 @@\n from types import ClassType\n from urlparse import urlparse\n from webdav.interfaces import IWriteLock\n+from zExceptions import BadRequest\n from zope import schema\n from zope.component import getMultiAdapter\n from zope.component import getUtility\n@@ -826,3 +827,70 @@ def human_readable_size(size):\n                 break\n         return \'%.1f %s\' % (float(size / float(SIZE_CONST[c])), c)\n     return size\n+\n+\n+def check_id(\n+        context, id=None, required=0, alternative_id=None, contained_by=None,\n+        **kwargs):\n+    """Test an id to make sure it is valid.\n+\n+    Returns an error message if the id is bad or None if the id is good.\n+\n+    In Plone 5.2, this function will replace\n+    Products/CMFPlone/skins/plone_scripts/check_id.py.\n+    But here in Plone 5.1, the function calls that same script,\n+    so that there should be no subtle differences with permissions.\n+    See https://github.com/plone/Products.CMFPlone/issues/2582\n+\n+    For more info on the keyword arguments, see that script.\n+\n+    We need to fall back to a basic check though, otherwise\n+    several tests that rely on this fallback will fail,\n+    for example simple content added in a way where the script is\n+    not available.  Several packages have their own fallback code\n+    for the case that \'check_id\' does not exist:\n+\n+    - Products.Archetypes and Products.ATContentTypes both simply check if\n+      id is in parent.objectIds().\n+    - plone.app.content tries parent._checkId(newid) from OFS.ObjectManager\n+      and catches a possible BadRequest exception to return True instead.\n+      This method checks for stuff like not allowing \'..\' as name,\n+      or names starting with an underscore.  This includes a check for\n+      an existing item when called with allow_dup=False.\n+    - Products.validation has an IdValidator which disallows a space in the id,\n+      checks if the id is given to a different object already,\n+      and calls ObjectManager.checkValidId, which is the same as _checkId.\n+\n+    Note that Products.validation is the only one that needs to\n+    do special stuff for checking if the conflicting item is the same as\n+    the current item being edited.  All others are about adding a new one.\n+\n+    We do a fallback that should cover all these cases.\n+    """\n+    script = getattr(context, \'check_id\', None)\n+    if script is not None:\n+        # We have found Products/CMFPlone/skins/plone_scripts/check_id.py\n+        # or an override.  This is the expected standard case.\n+        return script(\n+            id=id, required=required, alternative_id=alternative_id,\n+            contained_by=contained_by,\n+            **kwargs)\n+    if contained_by is None:\n+        contained_by = aq_parent(aq_inner(context))\n+    if contained_by is None:\n+        return\n+    # Check for existence.\n+    if (id in contained_by.objectIds() and\n+            getattr(aq_base(contained_by), id) is not aq_base(context)):\n+        return _(u\'There is already an item named ${name} in this folder.\',\n+                  mapping={u\'name\': safe_unicode(id)})\n+    # The container may have the _checkId method from OFS or plone.folder.\n+    # We use this only to check for invalid characters, not for duplicates,\n+    # because we did that already.\n+    script = getattr(contained_by, \'_checkId\', None)\n+    if script is not None:\n+        try:\n+            return contained_by._checkId(id, allow_dup=True)\n+        except BadRequest as exc:\n+            return str(exc)\n+        return\n'

