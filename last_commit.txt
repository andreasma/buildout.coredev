Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T00:26:23+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/f0d502164a9ba666bf5f300002e298dae1df8c8a

Ran black.

Black sees a SyntaxError in changelog.py, so that one is not changed.

Files changed:
M bootstrap.py
M plone/__init__.py
M plone/releaser/__init__.py
M plone/releaser/buildout.py
M plone/releaser/db.py
M plone/releaser/manage.py
M plone/releaser/package.py
M plone/releaser/pypi.py
M plone/releaser/release.py
M setup.py

b'diff --git a/bootstrap.py b/bootstrap.py\nindex a629566..bdda4e8 100644\n--- a/bootstrap.py\n+++ b/bootstrap.py\n@@ -27,7 +27,7 @@\n \n tmpeggs = tempfile.mkdtemp()\n \n-usage = \'\'\'\\\n+usage = """\\\n [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n \n Bootstraps a buildout-based project.\n@@ -37,30 +37,41 @@\n \n Note that by using --find-links to point to local resources, you can keep\n this script from going over the network.\n-\'\'\'\n+"""\n \n parser = OptionParser(usage=usage)\n parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n \n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-parser.add_option("--setuptools-version",\n-                  help="use a specific setuptools version")\n+parser.add_option(\n+    "-t",\n+    "--accept-buildout-test-releases",\n+    dest="accept_buildout_test_releases",\n+    action="store_true",\n+    default=False,\n+    help=(\n+        "Normally, if you do not specify a --version, the "\n+        "bootstrap script and buildout gets the newest "\n+        "*final* versions of zc.buildout and its recipes and "\n+        "extensions for you.  If you use this flag, "\n+        "bootstrap and buildout will get the newest releases "\n+        "even if they are alphas or betas."\n+    ),\n+)\n+parser.add_option(\n+    "-c",\n+    "--config-file",\n+    help=("Specify the path to the buildout configuration " "file to be used."),\n+)\n+parser.add_option(\n+    "-f", "--find-links", help=("Specify a URL to search for buildout releases")\n+)\n+parser.add_option(\n+    "--allow-site-packages",\n+    action="store_true",\n+    default=False,\n+    help=("Let bootstrap.py use existing site packages"),\n+)\n+parser.add_option("--setuptools-version", help="use a specific setuptools version")\n \n \n options, args = parser.parse_args()\n@@ -77,25 +88,26 @@\n     from urllib2 import urlopen\n \n ez = {}\n-exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n+exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n \n if not options.allow_site_packages:\n     # ez_setup imports site, which adds site packages\n     # this will remove them from the path to ensure that incompatible versions\n     # of setuptools are not in the path\n     import site\n+\n     # inside a virtualenv, there is no \'getsitepackages\'.\n     # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n+    if hasattr(site, "getsitepackages"):\n         for sitepackage_path in site.getsitepackages():\n             sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n \n setup_args = dict(to_dir=tmpeggs, download_delay=0)\n \n if options.setuptools_version is not None:\n-    setup_args[\'version\'] = options.setuptools_version\n+    setup_args["version"] = options.setuptools_version\n \n-ez[\'use_setuptools\'](**setup_args)\n+ez["use_setuptools"](**setup_args)\n import setuptools\n import pkg_resources\n \n@@ -110,28 +122,35 @@\n \n ws = pkg_resources.working_set\n \n-cmd = [sys.executable, \'-c\',\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n+cmd = [\n+    sys.executable,\n+    "-c",\n+    "from setuptools.command.easy_install import main; main()",\n+    "-mZqNxd",\n+    tmpeggs,\n+]\n \n find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n+    "bootstrap-testing-find-links",\n+    options.find_links\n+    or (\n+        "http://downloads.buildout.org/"\n+        if options.accept_buildout_test_releases\n+        else None\n+    ),\n+)\n if find_links:\n-    cmd.extend([\'-f\', find_links])\n+    cmd.extend(["-f", find_links])\n \n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n+setuptools_path = ws.find(pkg_resources.Requirement.parse("setuptools")).location\n \n-requirement = \'zc.buildout\'\n+requirement = "zc.buildout"\n version = options.version\n if version is None and not options.accept_buildout_test_releases:\n     # Figure out the most recent final version of zc.buildout.\n     import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n+\n+    _final_parts = "*final-", "*final"\n \n     def _final_version(parsed_version):\n         try:\n@@ -139,12 +158,11 @@ def _final_version(parsed_version):\n         except AttributeError:\n             # Older setuptools\n             for part in parsed_version:\n-                if (part[:1] == \'*\') and (part not in _final_parts):\n+                if (part[:1] == "*") and (part not in _final_parts):\n                     return False\n             return True\n \n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n+    index = setuptools.package_index.PackageIndex(search_path=[setuptools_path])\n     if find_links:\n         index.add_find_links((find_links,))\n     req = pkg_resources.Requirement.parse(requirement)\n@@ -163,13 +181,13 @@ def _final_version(parsed_version):\n             best.sort()\n             version = best[-1].version\n if version:\n-    requirement = \'==\'.join((requirement, version))\n+    requirement = "==".join((requirement, version))\n cmd.append(requirement)\n \n import subprocess\n+\n if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n+    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n \n ######################################################################\n # Import and run buildout\n@@ -178,12 +196,12 @@ def _final_version(parsed_version):\n ws.require(requirement)\n import zc.buildout.buildout\n \n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n+if not [a for a in args if "=" not in a]:\n+    args.append("bootstrap")\n \n # if -c was provided, we push it back into args for buildout\' main function\n if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n+    args[0:0] = ["-c", options.config_file]\n \n zc.buildout.buildout.main(args)\n shutil.rmtree(tmpeggs)\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/releaser/__init__.py b/plone/releaser/__init__.py\nindex c39911e..bbebcd7 100644\n--- a/plone/releaser/__init__.py\n+++ b/plone/releaser/__init__.py\n@@ -1,44 +1,38 @@\n # -*- coding: utf-8 -*-\n THIRD_PARTY_PACKAGES = (\n-    \'Zope2\',\n-    \'ZODB3\',\n-    \'txtfilter\',\n-    \'Products.CMFActionIcons\',\n-    \'Products.CMFCalendar\',\n-    \'Products.CMFCore\',\n-    \'Products.CMFDefault\',\n-    \'Products.CMFTopic\',\n-    \'Products.CMFUid\',\n-    \'Products.DCWorkflow\',\n-    \'Products.GenericSetup\',\n-    \'Products.GroupUserFolder\',\n-    \'Products.PluggableAuthService\',\n-    \'Products.PluginRegistry\',\n-    \'Products.ZCatalog\',\n+    "Zope2",\n+    "ZODB3",\n+    "txtfilter",\n+    "Products.CMFActionIcons",\n+    "Products.CMFCalendar",\n+    "Products.CMFCore",\n+    "Products.CMFDefault",\n+    "Products.CMFTopic",\n+    "Products.CMFUid",\n+    "Products.DCWorkflow",\n+    "Products.GenericSetup",\n+    "Products.GroupUserFolder",\n+    "Products.PluggableAuthService",\n+    "Products.PluginRegistry",\n+    "Products.ZCatalog",\n )\n \n-IGNORED_PACKAGES = (\n-    \'plone.releaser\',\n-)\n+IGNORED_PACKAGES = ("plone.releaser",)\n \n ALWAYS_CHECKED_OUT = (\n-    \'Plone\',\n-    \'Products.CMFPlone\',\n-    \'plone.app.upgrade\',\n-    \'plone.app.locales\',\n+    "Plone",\n+    "Products.CMFPlone",\n+    "plone.app.upgrade",\n+    "plone.app.locales",\n )\n \n # Upon checking a package...\n # ... ask every time if an action should be performed\n-ACTION_INTERACTIVE = \'interactive\'\n+ACTION_INTERACTIVE = "interactive"\n # ... don\'t ask anything and perform all actions\n-ACTION_BATCH = \'batch\'\n+ACTION_BATCH = "batch"\n # ... don\'t ask anything *AND* don\'t make any action, just show the status\n # of the package\n-ACTION_REPORT = \'report\'\n+ACTION_REPORT = "report"\n \n-PACKAGE_ACTIONS = (\n-    ACTION_BATCH,\n-    ACTION_INTERACTIVE,\n-    ACTION_REPORT,\n-)\n+PACKAGE_ACTIONS = (ACTION_BATCH, ACTION_INTERACTIVE, ACTION_REPORT)\ndiff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 13476fe..5ae4e6e 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -12,12 +12,11 @@\n     from UserDict import UserDict\n \n PATH_RE = re.compile(\n-    \'(\\w+://)(.+@)*([\\w\\d\\.]+)(:[\\d]+){0,1}/(?P<path>.+(?=\\.git))(\\.git)\'\n+    "(\\w+://)(.+@)*([\\w\\d\\.]+)(:[\\d]+){0,1}/(?P<path>.+(?=\\.git))(\\.git)"\n )\n \n \n class Source(object):\n-\n     def __init__(self, protocol=None, url=None, push_url=None, branch=None):\n         self.protocol = protocol\n         self.url = url\n@@ -26,19 +25,20 @@ def __init__(self, protocol=None, url=None, push_url=None, branch=None):\n \n     def create_from_string(self, source_string):\n         protocol, url, extra_1, extra_2, extra_3 = (\n-            lambda a, b, c=None, d=None, e=None: (a, b, c, d, e))(*source_string.split())\n+            lambda a, b, c=None, d=None, e=None: (a, b, c, d, e)\n+        )(*source_string.split())\n         for param in [extra_1, extra_2, extra_3]:\n             if param is not None:\n-                key, value = param.split(\'=\')\n+                key, value = param.split("=")\n                 setattr(self, key, value)\n         self.protocol = protocol\n         self.url = url\n         if self.push_url is not None:\n-            self.push_url = self.push_url.split(\'=\')[-1]\n+            self.push_url = self.push_url.split("=")[-1]\n         if self.branch is None:\n-            self.branch = \'master\'\n+            self.branch = "master"\n         else:\n-            self.branch = self.branch.split(\'=\')[-1]\n+            self.branch = self.branch.split("=")[-1]\n         return self\n \n     @property\n@@ -46,12 +46,11 @@ def path(self):\n         if self.url:\n             match = PATH_RE.match(self.url)\n             if match:\n-                return match.groupdict()[\'path\']\n+                return match.groupdict()["path"]\n         return None\n \n \n class VersionsFile(object):\n-\n     def __init__(self, file_location):\n         self.file_location = file_location\n \n@@ -62,13 +61,10 @@ def versions(self):\n         We use strict=False to avoid a DuplicateOptionError.\n         This happens in coredev 4.3 because we pin \'babel\' and \'Babel\'.\n         """\n-        config = ConfigParser(\n-            interpolation=ExtendedInterpolation(),\n-            strict=False,\n-            )\n+        config = ConfigParser(interpolation=ExtendedInterpolation(), strict=False)\n         with open(self.file_location) as f:\n             config.read_file(f)\n-        return config[\'versions\']\n+        return config["versions"]\n \n     def __contains__(self, package_name):\n         return package_name.lower() in self.versions.keys()\n@@ -81,7 +77,7 @@ def __getitem__(self, package_name):\n \n     def __setitem__(self, package_name, new_version):\n         path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path, \'r\') as f:\n+        with open(path, "r") as f:\n             versionstxt = f.read()\n \n         if package_name not in self:\n@@ -90,10 +86,10 @@ def __setitem__(self, package_name, new_version):\n \n         reg = re.compile(\n             "(^{0}[\\s\\=]+)[0-9\\.abrc]+(.post\\d+)?(.dev\\d+)?".format(package_name),\n-            re.MULTILINE\n+            re.MULTILINE,\n         )\n         newVersionsTxt = reg.sub(r"\\g<1>{0}".format(new_version), versionstxt)\n-        with open(path, \'w\') as f:\n+        with open(path, "w") as f:\n             f.write(newVersionsTxt)\n \n     def get(self, package_name):\n@@ -104,7 +100,6 @@ def set(self, package_name, new_version):\n \n \n class SourcesFile(UserDict):\n-\n     def __init__(self, file_location):\n         self.file_location = file_location\n \n@@ -115,7 +110,7 @@ def data(self):\n         with open(self.file_location) as f:\n             config.read_file(f)\n         sources_dict = OrderedDict()\n-        for name, value in config[\'sources\'].items():\n+        for name, value in config["sources"].items():\n             source = Source().create_from_string(value)\n             sources_dict[name] = source\n         return sources_dict\n@@ -128,7 +123,6 @@ def __iter__(self):\n \n \n class CheckoutsFile(UserDict):\n-\n     def __init__(self, file_location):\n         self.file_location = file_location\n \n@@ -137,8 +131,8 @@ def data(self):\n         config = ConfigParser(interpolation=ExtendedInterpolation())\n         with open(self.file_location) as f:\n             config.read_file(f)\n-        checkouts = config.get(\'buildout\', \'auto-checkout\')\n-        checkout_list = checkouts.split(\'\\n\')\n+        checkouts = config.get("buildout", "auto-checkout")\n+        checkout_list = checkouts.split("\\n")\n         return checkout_list\n \n     def __contains__(self, package_name):\n@@ -146,25 +140,18 @@ def __contains__(self, package_name):\n \n     def __setitem__(self, package_name, enabled=True):\n         path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path, \'r\') as f:\n+        with open(path, "r") as f:\n             checkoutstxt = f.read()\n-        with open(path, \'w\') as f:\n+        with open(path, "w") as f:\n             if enabled:\n                 fixes_text = "# test-only fixes:"\n-                reg = re.compile(\n-                    "^[\\s]*{0}\\n".format(fixes_text),\n-                    re.MULTILINE\n-                )\n+                reg = re.compile("^[\\s]*{0}\\n".format(fixes_text), re.MULTILINE)\n                 newCheckoutsTxt = reg.sub(\n-                    \'    {0}\\n{1}\\n\'.format(package_name, fixes_text),\n-                    checkoutstxt\n+                    "    {0}\\n{1}\\n".format(package_name, fixes_text), checkoutstxt\n                 )\n             else:\n-                reg = re.compile(\n-                    "^[\\s]*{0}\\n".format(package_name),\n-                    re.MULTILINE\n-                )\n-                newCheckoutsTxt = reg.sub(\'\', checkoutstxt)\n+                reg = re.compile("^[\\s]*{0}\\n".format(package_name), re.MULTILINE)\n+                newCheckoutsTxt = reg.sub("", checkoutstxt)\n             f.write(newCheckoutsTxt)\n \n     def __delitem__(self, package_name):\n@@ -189,11 +176,12 @@ def remove(self, package_name):\n \n \n class Buildout(object):\n-\n-    def __init__(self,\n-                 sources_file=\'sources.cfg\',\n-                 checkouts_file=\'checkouts.cfg\',\n-                 versions_file=\'versions.cfg\'):\n+    def __init__(\n+        self,\n+        sources_file="sources.cfg",\n+        checkouts_file="checkouts.cfg",\n+        versions_file="versions.cfg",\n+    ):\n         self.sources = SourcesFile(sources_file)\n         self.versions = VersionsFile(versions_file)\n         self.checkouts = CheckoutsFile(checkouts_file)\ndiff --git a/plone/releaser/db.py b/plone/releaser/db.py\nindex 5d53d15..5982865 100644\n--- a/plone/releaser/db.py\n+++ b/plone/releaser/db.py\n@@ -4,21 +4,20 @@\n \n \n class IgnoresDB(object):\n-\n     def __init__(self):\n-        self._filename = \'.package_ignores\'\n+        self._filename = ".package_ignores"\n         if not os.path.isfile(self._filename):\n-            open(self._filename, \'w\').close()\n+            open(self._filename, "w").close()\n \n-        with open(self._filename, \'r\') as f:\n+        with open(self._filename, "r") as f:\n             content = f.read()\n-            if content != \'\':\n+            if content != "":\n                 self._db = json.loads(content)\n             else:\n                 self._db = {}\n \n     def save(self):\n-        with open(self._filename, \'w+\') as f:\n+        with open(self._filename, "w+") as f:\n             f.write(json.dumps(self._db))\n \n     def get(self, package_name):\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 77c06d5..29575ef 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -30,13 +30,14 @@ def checkPypi(user):\n             pass\n         else:\n             if not pypi.can_user_release_package_to_pypi(user, package):\n-                print("{0}: {1}".format(\n-                    package,\n-                    \', \'.join(pypi.get_users_with_release_rights(package))\n-                ))\n+                print(\n+                    "{0}: {1}".format(\n+                        package, ", ".join(pypi.get_users_with_release_rights(package))\n+                    )\n+                )\n \n \n-@named(\'jenkins\')\n+@named("jenkins")\n def jenkins_report():\n     """Read-only version of checkAllPackagesForUpdates."""\n     sources = buildout.sources\n@@ -45,72 +46,70 @@ def jenkins_report():\n         pkg(action=ACTION_REPORT)\n \n \n-@arg(\'--interactive\', default=False)\n+@arg("--interactive", default=False)\n def checkPackageForUpdates(package_name, **kwargs):\n     pkg = Package(buildout, package_name)\n-    if kwargs[\'interactive\']:\n+    if kwargs["interactive"]:\n         pkg(action=ACTION_INTERACTIVE)\n     else:\n         pkg(action=ACTION_BATCH)\n \n \n-@named(\'report\')\n-@arg(\'--interactive\', default=False)\n+@named("report")\n+@arg("--interactive", default=False)\n def checkAllPackagesForUpdates(**kwargs):\n     sources = buildout.sources\n-    for package_name, source in Bar(\'Scanning\').iter(sources.iteritems()):\n+    for package_name, source in Bar("Scanning").iter(sources.iteritems()):\n         pkg = Package(buildout, package_name)\n-        if kwargs[\'interactive\']:\n+        if kwargs["interactive"]:\n             pkg(action=ACTION_INTERACTIVE)\n         else:\n             pkg(action=ACTION_REPORT)\n \n \n def pulls():\n-    client_id = \'b9f6639835b8c9cf462a\'\n-    client_secret = keyring.get_password(\'plone.releaser\', client_id)\n+    client_id = "b9f6639835b8c9cf462a"\n+    client_secret = keyring.get_password("plone.releaser", client_id)\n \n     g = Github(client_id=client_id, client_secret=client_secret)\n \n     for package_name, source in buildout.sources.iteritems():\n         if source.path:\n             repo = g.get_repo(source.path)\n-            pulls = [a for a in repo.get_pulls(\n-                \'open\') if a.head.ref == source.branch]\n+            pulls = [a for a in repo.get_pulls("open") if a.head.ref == source.branch]\n             if pulls:\n                 print(package_name)\n                 for pull in pulls:\n-                    print("    {0}: {1} ({2})".format(\n-                        pull.user.login,\n-                        pull.title,\n-                        pull.url\n-                    ))\n+                    print(\n+                        "    {0}: {1} ({2})".format(\n+                            pull.user.login, pull.title, pull.url\n+                        )\n+                    )\n \n \n-@named(\'changelog\')\n-@arg(\'--start\')\n-@arg(\'--end\', default=\'here\')\n+@named("changelog")\n+@arg("--start")\n+@arg("--end", default="here")\n def changelog(**kwargs):\n     from plone.releaser.changelog import build_unified_changelog\n-    build_unified_changelog(kwargs[\'start\'], kwargs[\'end\'])\n \n+    build_unified_changelog(kwargs["start"], kwargs["end"])\n \n-@named(\'launchpad\')\n+\n+@named("launchpad")\n def create_launchpad_release(version):\n-    launchpad = Launchpad.login_with(\'plone.releaser\', \'production\')\n-    plone = launchpad.projects[\'plone\']\n+    launchpad = Launchpad.login_with("plone.releaser", "production")\n+    plone = launchpad.projects["plone"]\n     parsed_version = StrictVersion(version)\n     # Blech. This feels flimsy\n-    series_name = \'.\'.join([str(a) for a in parsed_version.version[0:2]])\n+    series_name = ".".join([str(a) for a in parsed_version.version[0:2]])\n     series = plone.getSeries(name=series_name)\n     if series is None:\n         return "No series named {0}.".format(series_name)\n     now = datetime.datetime.now().isoformat()\n-    milestone = series.newMilestone(name=version,\n-                                    date_targeted=now)\n+    milestone = series.newMilestone(name=version, date_targeted=now)\n     # TODO: Get release notes\n-    release = milestone.createProductRelease(date_released=now,\n-                                             release_notes=\'\')\n+    release = milestone.createProductRelease(date_released=now, release_notes="")\n \n     release_url = release.web_link\n \n@@ -119,16 +118,17 @@ def create_launchpad_release(version):\n \n def check_checkout(package_name, path):\n     if package_name not in CheckoutsFile(path):\n-        msg = \'Your package {0} is not on auto-checkout section\'\n+        msg = "Your package {0} is not on auto-checkout section"\n         raise KeyError(msg.format(package_name))\n \n \n def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     from zest.releaser.vcs import BaseVersionControl\n     from zest.releaser.utils import cleanup_version\n+\n     vcs = BaseVersionControl()\n     old_version = cleanup_version(vcs.version)\n-    new_version = \'{0}.{1}\'.format(old_version, jenkins_build_number)\n+    new_version = "{0}.{1}".format(old_version, jenkins_build_number)\n     vcs.version = new_version\n     return new_version\n \n@@ -139,20 +139,22 @@ def set_package_version(version_file_path, package_name, new_version):\n \n \n class Manage(object):\n-\n     def __call__(self, **kwargs):\n         parser = ArghParser()\n         parser.add_commands(\n-            [checkPypi,\n-             checkPackageForUpdates,\n-             checkAllPackagesForUpdates,\n-             pulls,\n-             changelog,\n-             create_launchpad_release,\n-             check_checkout,\n-             append_jenkins_build_number_to_package_version,\n-             set_package_version,\n-             jenkins_report])\n+            [\n+                checkPypi,\n+                checkPackageForUpdates,\n+                checkAllPackagesForUpdates,\n+                pulls,\n+                changelog,\n+                create_launchpad_release,\n+                check_checkout,\n+                append_jenkins_build_number_to_package_version,\n+                set_package_version,\n+                jenkins_report,\n+            ]\n+        )\n         parser.dispatch()\n \n \ndiff --git a/plone/releaser/package.py b/plone/releaser/package.py\nindex 92ebfed..f4f3b46 100644\n--- a/plone/releaser/package.py\n+++ b/plone/releaser/package.py\n@@ -28,12 +28,7 @@ def git_repo(source):\n     http://preshing.com/20110920/the-python-with-statement-by-example/\n     """\n     tmp_dir = mkdtemp()\n-    repo = git.Repo.clone_from(\n-        source.url,\n-        tmp_dir,\n-        branch=source.branch,\n-        depth=100\n-    )\n+    repo = git.Repo.clone_from(source.url, tmp_dir, branch=source.branch, depth=100)\n \n     # give the control back\n     yield repo\n@@ -88,7 +83,7 @@ def __init__(self, buildout, package):\n \n     def __call__(self, action=ACTION_INTERACTIVE):\n         if action not in PACKAGE_ACTIONS:\n-            print(\'This package action does not exist: {0}\'.format(action))\n+            print("This package action does not exist: {0}".format(action))\n             return\n         self.set_interaction_and_report(action)\n \n@@ -96,9 +91,11 @@ def __call__(self, action=ACTION_INTERACTIVE):\n         # - is on the ignored list\n         # - there is no version available\n         # - is not hosted on a git VCS\n-        if self.name in IGNORED_PACKAGES or \\\n-                self.version is None or \\\n-                not self.is_git_hosted():\n+        if (\n+            self.name in IGNORED_PACKAGES\n+            or self.version is None\n+            or not self.is_git_hosted()\n+        ):\n             return\n \n         # clone the package and gather data about it\n@@ -118,43 +115,44 @@ def __call__(self, action=ACTION_INTERACTIVE):\n             if latest_ignored_commit is not None:\n                 try:\n                     commits_since_ignore = self._commits_between(\n-                        repo,\n-                        latest_ignored_commit,\n-                        self.source.branch\n+                        repo, latest_ignored_commit, self.source.branch\n                     )\n                 except git.exc.GitCommandError:\n-                    print(\'\\nCould not read commits for package {0}\'.format(self.name))\n+                    print("\\nCould not read commits for package {0}".format(self.name))\n                     return\n \n             # if there are no changes since the last release (i.e. last tag)\n-            if not commits_since_release \\\n-                    or \'Back to development\' in commits_since_release[0].message \\\n-                    or commits_since_release[0].message.startswith(\'vb\'):\n+            if (\n+                not commits_since_release\n+                or "Back to development" in commits_since_release[0].message\n+                or commits_since_release[0].message.startswith("vb")\n+            ):\n \n                 self.remove()\n \n             elif commits_since_ignore is None:\n                 # Check for checkout\n                 if self.name not in self.buildout.checkouts:\n-                    msg = \'\\nWARNING: No auto-checkout exists for {0}\\n Changes in {0}:\'  # noqa\n+                    msg = (\n+                        "\\nWARNING: No auto-checkout exists for {0}\\n Changes in {0}:"\n+                    )  # noqa\n                     self.print_commits(\n-                        commits_since_release,\n-                        message=msg.format(self.name)\n+                        commits_since_release, message=msg.format(self.name)\n                     )\n \n                     if self.name in THIRD_PARTY_PACKAGES:\n-                        msg = \'NOTE: {0} is a third-party package.\'\n+                        msg = "NOTE: {0} is a third-party package."\n                         print(msg.format(self.name))\n \n                     self.add(commits_since_release)\n \n                 else:\n                     if not self.interactive:\n-                        msg = \'\\nChanges in {0}:\'.format(self.name)\n+                        msg = "\\nChanges in {0}:".format(self.name)\n                         self.print_commits(commits_since_release, message=msg)\n \n                         if self.name in THIRD_PARTY_PACKAGES:\n-                            msg = \'NOTE: {0} is a third-party package.\'\n+                            msg = "NOTE: {0} is a third-party package."\n                             print(msg.format(self.name))\n \n     def set_interaction_and_report(self, action):\n@@ -169,9 +167,9 @@ def set_interaction_and_report(self, action):\n             self.report_only = False\n \n     def is_git_hosted(self):\n-        if self.source.protocol != \'git\':\n+        if self.source.protocol != "git":\n             if self.report_only:\n-                msg = \'Skipped check of {0} as it\\\'s not a git repo.\'\n+                msg = "Skipped check of {0} as it\'s not a git repo."\n                 print(msg.format(self.name))\n             return False\n         return True\n@@ -182,17 +180,17 @@ def get_version(self):\n             version = self.buildout.get_version(self.name)\n         except (NoOptionError, KeyError):\n             if self.report_only:\n-                print(\'No version available for {0}\'.format(self.name))\n+                print("No version available for {0}".format(self.name))\n \n         return version\n \n     def latest_tag(self, repo):\n         tag = None\n         try:\n-            tag = repo.git.describe(\'--abbrev=0\', \'--tags\')\n+            tag = repo.git.describe("--abbrev=0", "--tags")\n         except git.exc.GitCommandError:\n             if self.report_only:\n-                print(\'Unable to check tags for {0}\'.format(self.name))\n+                print("Unable to check tags for {0}".format(self.name))\n \n         return tag\n \n@@ -200,63 +198,53 @@ def latest_commits(self, repo):\n         commits = None\n \n         try:\n-            commits = self._commits_between(\n-                repo,\n-                self.version,\n-                self.source.branch\n-            )\n+            commits = self._commits_between(repo, self.version, self.source.branch)\n         except git.exc.GitCommandError:\n-            print(\'\\nCould not read commits for package {0}\'.format(self.name))\n+            print("\\nCould not read commits for package {0}".format(self.name))\n \n         return commits\n \n     @staticmethod\n     def _commits_between(repo, start, end):\n-        return list(\n-            repo.iter_commits(\n-                \'{0}..{1}\'.format(start, end)\n-            )\n-        )\n+        return list(repo.iter_commits("{0}..{1}".format(start, end)))\n \n     def remove(self):\n-        if self.name in self.buildout.checkouts and \\\n-                self.name not in ALWAYS_CHECKED_OUT:\n-            msg = \'\\nNo new changes in {0}, but it is listed for auto-checkout.\'  # noqa\n+        if self.name in self.buildout.checkouts and self.name not in ALWAYS_CHECKED_OUT:\n+            msg = "\\nNo new changes in {0}, but it is listed for auto-checkout."  # noqa\n             print(msg.format(self.name))\n \n             if self.report_only:\n                 return\n \n-            msg = \'Remove {0} from checkouts.cfg\'.format(self.name)\n+            msg = "Remove {0} from checkouts.cfg".format(self.name)\n             if confirm(msg, default=True, skip=not self.interactive):\n                 self.buildout.remove_from_checkouts(self.name)\n \n                 with buildout_coredev() as core_repo:\n-                    checkouts_path = os.path.join(os.getcwd(), \'checkouts.cfg\')\n+                    checkouts_path = os.path.join(os.getcwd(), "checkouts.cfg")\n                     core_repo.git.add(checkouts_path)\n-                    msg = \'No new changes in {0}\'.format(self.name)\n+                    msg = "No new changes in {0}".format(self.name)\n                     core_repo.git.commit(message=msg)\n \n     def add(self, commits_since_release):\n         if self.report_only:\n             return\n \n-        msg = \'Add {0} to checkouts.cfg\'.format(self.name)\n+        msg = "Add {0} to checkouts.cfg".format(self.name)\n         if confirm(msg, default=True, skip=not self.interactive):\n             self.buildout.add_to_checkouts(self.name)\n \n             with buildout_coredev() as core_repo:\n-                checkouts_path = os.path.join(os.getcwd(), \'checkouts.cfg\')\n+                checkouts_path = os.path.join(os.getcwd(), "checkouts.cfg")\n                 core_repo.index.add([checkouts_path])\n-                core_repo.index.commit(\'{0} has changes.\'.format(self.name))\n-\n-        elif confirm(\'Ignore changes in  {0}\'.format(self.name),\n-                     default=False,\n-                     skip=not self.interactive):\n-            self.commit_ignores.set(\n-                self.name,\n-                commits_since_release[0].hexsha\n-            )\n+                core_repo.index.commit("{0} has changes.".format(self.name))\n+\n+        elif confirm(\n+            "Ignore changes in  {0}".format(self.name),\n+            default=False,\n+            skip=not self.interactive,\n+        ):\n+            self.commit_ignores.set(self.name, commits_since_release[0].hexsha)\n \n     @staticmethod\n     def print_commits(commits_list, message=None):\n@@ -264,28 +252,28 @@ def print_commits(commits_list, message=None):\n             print(message)\n \n         for commit in commits_list:\n-            print(\'    {0}: {1}\'.format(\n-                commit.author.name.encode(\'ascii\', \'replace\'),\n-                commit.summary.encode(\'ascii\', \'replace\')\n-            ))\n+            print(\n+                "    {0}: {1}".format(\n+                    commit.author.name.encode("ascii", "replace"),\n+                    commit.summary.encode("ascii", "replace"),\n+                )\n+            )\n \n     def update_version(self, tag):\n         if tag <= self.version:\n             return\n \n-        msg = \'\\nNewer version {0} is available for {1} (Currently {2})\'\n+        msg = "\\nNewer version {0} is available for {1} (Currently {2})"\n         print(msg.format(tag, self.name, self.version))\n \n         if self.report_only:\n             return\n \n-        if confirm(\'Update versions.cfg\',\n-                   default=True,\n-                   skip=not self.interactive):\n+        if confirm("Update versions.cfg", default=True, skip=not self.interactive):\n             self.buildout.set_version(self.name, tag)\n \n             with buildout_coredev() as core_repo:\n-                versions_path = os.path.join(os.getcwd(), \'versions.cfg\')\n+                versions_path = os.path.join(os.getcwd(), "versions.cfg")\n                 core_repo.git.add(versions_path)\n-                core_repo.git.commit(message=\'{0}={1}\'.format(self.name, tag))\n+                core_repo.git.commit(message="{0}={1}".format(self.name, tag))\n                 core_repo.git.push()\ndiff --git a/plone/releaser/pypi.py b/plone/releaser/pypi.py\nindex eb7600c..91db3dd 100644\n--- a/plone/releaser/pypi.py\n+++ b/plone/releaser/pypi.py\n@@ -7,9 +7,8 @@\n \n \n def get_users_with_release_rights(package_name):\n-    client = ServerProxy(\'https://pypi.org/pypi\')\n-    existing_admins = set([\n-        user for role, user in client.package_roles(package_name)])\n+    client = ServerProxy("https://pypi.org/pypi")\n+    existing_admins = set([user for role, user in client.package_roles(package_name)])\n     return existing_admins\n \n \ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex 1e0dd35..e793e17 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -15,72 +15,73 @@\n import textwrap\n \n # Define texts to check for during prereleaser or add during postrelease.\n-NOTHING_CHANGED_YET = \'*add item here*\'\n+NOTHING_CHANGED_YET = "*add item here*"\n BREAKING_TEXT = """\n Breaking changes:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n FEATURE_TEXT = """\n New features:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n BUGFIXES_TEXT = """\n Bug fixes:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n-HEADERS = [\n-    BREAKING_TEXT,\n-    FEATURE_TEXT,\n-    BUGFIXES_TEXT,\n-]\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n+HEADERS = [BREAKING_TEXT, FEATURE_TEXT, BUGFIXES_TEXT]\n # Used by changelog.py:\n-HEADINGS = [\n-    \'Breaking changes:\',\n-    \'New features:\',\n-    \'Bug fixes:\',\n-]\n+HEADINGS = ["Breaking changes:", "New features:", "Bug fixes:"]\n # For compatibility with previous names of the headers.\n INCOMPATIBILITIES_TEXT = """\n Incompatibilities:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n NEW_TEXT = """\n New:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n FIXES_TEXT = """\n Fixes:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n-OLD_HEADERS = [\n-    INCOMPATIBILITIES_TEXT,\n-    NEW_TEXT,\n-    FIXES_TEXT,\n-]\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n+OLD_HEADERS = [INCOMPATIBILITIES_TEXT, NEW_TEXT, FIXES_TEXT]\n ALL_HEADERS = copy(HEADERS)\n ALL_HEADERS.extend(OLD_HEADERS)\n OLD_HEADING_MAPPING = {\n-    \'Incompatibilities:\': \'Breaking changes:\',\n-    \'New:\': \'New features:\',\n-    \'Fixes:\': \'Bug fixes:\',\n+    "Incompatibilities:": "Breaking changes:",\n+    "New:": "New features:",\n+    "Fixes:": "Bug fixes:",\n }\n KNOWN_HEADINGS = copy(HEADINGS)\n KNOWN_HEADINGS.extend(OLD_HEADING_MAPPING.keys())\n \n \n ALWAYS_CHECKED_OUT_PACKAGES = (\n-    \'Plone\',\n-    \'Products.CMFPlone\',\n-    \'plone.app.upgrade\',\n-    \'plone.app.locales\',\n+    "Plone",\n+    "Products.CMFPlone",\n+    "plone.app.upgrade",\n+    "plone.app.locales",\n )\n \n+\n def set_nothing_changed_yet(data):\n     """Set line that we look for in prerelease.\n \n@@ -90,7 +91,7 @@ def set_nothing_changed_yet(data):\n     Note that currently this must be a single line, because\n     zest.releaser looks for this text in each line.\n     """\n-    data[\'nothing_changed_yet\'] = NOTHING_CHANGED_YET\n+    data["nothing_changed_yet"] = NOTHING_CHANGED_YET\n \n \n def set_required_changelog(data):\n@@ -98,7 +99,7 @@ def set_required_changelog(data):\n \n     This is during the prerelease phase.\n     """\n-    data[\'required_changelog_text\'] = KNOWN_HEADINGS\n+    data["required_changelog_text"] = KNOWN_HEADINGS\n \n \n def set_new_changelog(data):\n@@ -107,8 +108,8 @@ def set_new_changelog(data):\n     Yes, this overrides what we have set in the prerelease, and that is\n     fine.\n     """\n-    text = \'\'.join(HEADERS)\n-    data[\'nothing_changed_yet\'] = textwrap.dedent(text).strip()\n+    text = "".join(HEADERS)\n+    data["nothing_changed_yet"] = textwrap.dedent(text).strip()\n \n \n def cleanup_changelog(data):\n@@ -129,42 +130,40 @@ def cleanup_changelog(data):\n     # The history_file is probably not set yet, as we are called too early.\n     # That might change subtly in future zest.releaser versions, so let\'s check\n     # it anyway.\n-    history_file = data.get(\'history_file\')\n+    history_file = data.get("history_file")\n     if history_file:\n-        contents = \'\\n\'.join(data[\'history_lines\'])\n-        encoding = data[\'history_encoding\']\n+        contents = "\\n".join(data["history_lines"])\n+        encoding = data["history_encoding"]\n     else:\n         # We do not want to copy the logic from zest.releaser that tries to\n         # find the history file, but we can check the most obvious spot.\n-        history_file = \'CHANGES.rst\'\n+        history_file = "CHANGES.rst"\n         if not os.path.exists(history_file):\n-            print(\'Cannot cleanup history, will try again later.\')\n+            print("Cannot cleanup history, will try again later.")\n             return\n         contents, encoding = read_text_file(history_file)\n     orig_contents = contents\n     changed = False\n     for header in ALL_HEADERS:\n         if header in contents:\n-            contents = contents.replace(header, \'\')\n+            contents = contents.replace(header, "")\n             changed = True\n     if not changed:\n         return\n-    write_text_file(\n-        history_file, contents, encoding=encoding)\n+    write_text_file(history_file, contents, encoding=encoding)\n     print("Cleaned up empty headers from history file {}".format(history_file))\n     # Update the data, otherwise our work may get overwritten.\n-    data[\'history_lines\'] = contents.split(\'\\n\')\n-    if not os.path.isdir(\'.git\'):\n-        print(\'Not a git checkout, cannot commit.\')\n+    data["history_lines"] = contents.split("\\n")\n+    if not os.path.isdir(".git"):\n+        print("Not a git checkout, cannot commit.")\n         return\n-    g = git.Git(\'.\')\n+    g = git.Git(".")\n     message = "Cleaned up empty headers from changelog.\\n\\n[ci skip]"\n     print(g.diff(history_file))\n     msg = "Commit changes?"\n     if not ask(msg, default=True):\n         # Restore original contents.\n-        write_text_file(\n-            history_file, orig_contents, encoding=encoding)\n+        write_text_file(history_file, orig_contents, encoding=encoding)\n         sys.exit()\n     print("Committing changes.")\n     print(g.add(history_file))\n@@ -172,10 +171,10 @@ def cleanup_changelog(data):\n \n \n def check_pypi_access(data):\n-    pypi_user = pypi.PypiConfig().config.get(\'pypi\', \'username\')\n-    if not can_user_release_package_to_pypi(pypi_user, data[\'name\']):\n+    pypi_user = pypi.PypiConfig().config.get("pypi", "username")\n+    if not can_user_release_package_to_pypi(pypi_user, data["name"]):\n         msg = "User {0} does not have pypi release rights to {1}. Continue?"\n-        if not ask(msg.format(pypi_user, data[\'name\']), default=False):\n+        if not ask(msg.format(pypi_user, data["name"]), default=False):\n             sys.exit()\n \n \n@@ -184,18 +183,18 @@ def update_core(data, branch=None):\n     if branch:\n         msg = "Ok to update coredev {0} versions.cfg/checkouts.cfg?".format(branch)\n     if ask(msg, default=True):\n-        root_path = os.path.join(os.getcwd(), \'../../\')\n+        root_path = os.path.join(os.getcwd(), "../../")\n         g = git.Git(root_path)\n         g.pull()  # make sure buildout.coredev is up-to-date\n-        package_name = data[\'name\']\n-        new_version = data[\'version\']\n+        package_name = data["name"]\n+        new_version = data["version"]\n         update_versions(package_name, new_version)\n         if package_name not in ALWAYS_CHECKED_OUT_PACKAGES:\n             remove_from_checkouts(package_name)\n         # git commit\n         message = "{0} {1}".format(package_name, new_version)\n-        g.add(\'versions.cfg\')\n-        g.add(\'checkouts.cfg\')\n+        g.add("versions.cfg")\n+        g.add("checkouts.cfg")\n         print("Committing changes.")\n         g.commit(message=message)\n         msg = "Ok to push coredev?"\n@@ -207,21 +206,21 @@ def update_core(data, branch=None):\n \n \n def update_other_core_branches(data):\n-    CORE_BRANCHES = [\'4.3\', \'5.1\', \'5.2\', ]\n-    package_name = data[\'name\']\n-    root_path = os.path.join(os.getcwd(), \'../../\')\n+    CORE_BRANCHES = ["4.3", "5.1", "5.2"]\n+    package_name = data["name"]\n+    root_path = os.path.join(os.getcwd(), "../../")\n \n     def _get_current_core_branch():\n         g = git.Repo(root_path)\n         return g.head.reference.name\n \n     def _get_package_branch(package_name):\n-        path = os.path.join(root_path, \'sources.cfg\')\n+        path = os.path.join(root_path, "sources.cfg")\n         sources = SourcesFile(path)\n         try:\n             return sources[package_name].branch\n         except KeyError:  # package is not on sources.cfg of the current core branch\n-            return \'\'\n+            return ""\n \n     current_core_branch = _get_current_core_branch()\n     CORE_BRANCHES.remove(current_core_branch)\n@@ -238,9 +237,8 @@ def _get_package_branch(package_name):\n                 update_core(data, branch=branch_name)\n             except Exception:\n                 print(\n-                    \'There was an error trying to update {0} on {1}\'.format(\n-                        package_name,\n-                        branch_name,\n+                    "There was an error trying to update {0} on {1}".format(\n+                        package_name, branch_name\n                     )\n                 )\n \n@@ -250,13 +248,13 @@ def _get_package_branch(package_name):\n def update_versions(package_name, new_version):\n     # Update version\n     print("Updating versions.cfg")\n-    path = os.path.join(os.getcwd(), \'../../versions.cfg\')\n+    path = os.path.join(os.getcwd(), "../../versions.cfg")\n     versions = VersionsFile(path)\n     versions.set(package_name, new_version)\n \n \n def remove_from_checkouts(package_name):\n     print("Removing package from checkouts.cfg")\n-    path = os.path.join(os.getcwd(), \'../../checkouts.cfg\')\n+    path = os.path.join(os.getcwd(), "../../checkouts.cfg")\n     checkouts = CheckoutsFile(path)\n     checkouts.remove(package_name)\ndiff --git a/setup.py b/setup.py\nindex 56b046f..49baf7e 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,74 +3,72 @@\n from setuptools import setup\n \n \n-version = \'1.7.3.dev0\'\n+version = "1.7.3.dev0"\n \n-long_description = \'{0}\\n{1}\'.format(\n-    open(\'README.rst\').read(),\n-    open(\'CHANGES.rst\').read()\n+long_description = "{0}\\n{1}".format(\n+    open("README.rst").read(), open("CHANGES.rst").read()\n )\n \n setup(\n-    name=\'plone.releaser\',\n+    name="plone.releaser",\n     version=version,\n-    description=\'Plone release management utilities\',\n+    description="Plone release management utilities",\n     long_description=long_description,\n     # Get more strings from\n     # https://pypi.python.org/pypi?:action=list_classifiers\n     classifiers=[\n-      \'Framework :: Plone\',\n-      "License :: OSI Approved :: GNU General Public License (GPL)",\n-      \'Programming Language :: Python\',\n-      \'Programming Language :: Python :: 2.7\',\n+        "Framework :: Plone",\n+        "License :: OSI Approved :: GNU General Public License (GPL)",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n     ],\n-    keywords=\'plone release\',\n-    author=\'Eric Steele\',\n-    author_email=\'eric@esteele.net\',\n-    url=\'https://github.com/plone/plone.releaser\',\n-    license=\'GPL\',\n+    keywords="plone release",\n+    author="Eric Steele",\n+    author_email="eric@esteele.net",\n+    url="https://github.com/plone/plone.releaser",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'argh\',\n-        \'gitpython>=0.3\',\n-        \'configparser\',\n-        \'argcomplete\',\n-        \'progress\',\n-        \'PyGithub\',\n-        \'keyring\',\n-        \'zest.releaser>=6.6.0\',\n-        \'zestreleaser.towncrier>=1.0.0b3\',\n-        \'docutils\',\n-        \'launchpadlib\',\n+        "setuptools",\n+        "argh",\n+        "gitpython>=0.3",\n+        "configparser",\n+        "argcomplete",\n+        "progress",\n+        "PyGithub",\n+        "keyring",\n+        "zest.releaser>=6.6.0",\n+        "zestreleaser.towncrier>=1.0.0b3",\n+        "docutils",\n+        "launchpadlib",\n     ],\n     entry_points={\n-        \'console_scripts\': [\n-            \'manage = plone.releaser.manage:manage\',\n+        "console_scripts": ["manage = plone.releaser.manage:manage"],\n+        "zest.releaser.prereleaser.before": [\n+            (\n+                "set_nothing_changed_yet="\n+                "plone.releaser.release:set_nothing_changed_yet"\n+            ),\n+            ("set_required_changelog=" "plone.releaser.release:set_required_changelog"),\n+            ("cleanup_changelog=" "plone.releaser.release:cleanup_changelog"),\n         ],\n-        \'zest.releaser.prereleaser.before\': [\n-            (\'set_nothing_changed_yet=\'\n-             \'plone.releaser.release:set_nothing_changed_yet\'),\n-            (\'set_required_changelog=\'\n-             \'plone.releaser.release:set_required_changelog\'),\n-            (\'cleanup_changelog=\'\n-             \'plone.releaser.release:cleanup_changelog\'),\n-        ],\n-        \'zest.releaser.prereleaser.middle\': [\n+        "zest.releaser.prereleaser.middle": [\n             # Note: we explicitly call cleanup_changelog twice.\n-            (\'cleanup_changelog=\'\n-             \'plone.releaser.release:cleanup_changelog\'),\n-            \'check_pypi=plone.releaser.release:check_pypi_access\',\n+            ("cleanup_changelog=" "plone.releaser.release:cleanup_changelog"),\n+            "check_pypi=plone.releaser.release:check_pypi_access",\n         ],\n-        \'zest.releaser.releaser.after\': [\n-            \'update_core=plone.releaser.release:update_core\',\n-            (\'update_other_core_branches=\'\n-             \'plone.releaser.release:update_other_core_branches\'),\n+        "zest.releaser.releaser.after": [\n+            "update_core=plone.releaser.release:update_core",\n+            (\n+                "update_other_core_branches="\n+                "plone.releaser.release:update_other_core_branches"\n+            ),\n         ],\n-        \'zest.releaser.postreleaser.before\': [\n-            \'set_new_changelog=plone.releaser.release:set_new_changelog\',\n+        "zest.releaser.postreleaser.before": [\n+            "set_new_changelog=plone.releaser.release:set_new_changelog"\n         ],\n     },\n )\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T00:28:27+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/10513b22c48bb8504565803d0bb5bdf7ebda3abd

Fixed old-style exceptions in changelog.py

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex 1c46961..2c19f0e 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -180,7 +180,7 @@ def build_unified_changelog(start_version, end_version):\n     try:\n         prior_versions = pull_versions(start_version)\n         current_versions = pull_versions(end_version)\n-    except ValueError, e:\n+    except ValueError as e:\n         print(e)\n         return\n \n@@ -208,7 +208,7 @@ def build_unified_changelog(start_version, end_version):\n                         changelog = Changelog(content=logtext)\n                         try:\n                             changes = changelog.get_changes(prior_version, version)\n-                        except ValueError, e:\n+                        except ValueError as e:\n                             print(e)\n                         else:\n                             bullet = "- "\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T00:28:36+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/27f43e2ae78ef8f28599d65ee3352e198b9a40fa

Ran black on changelog.py.

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex 2c19f0e..85bea6e 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -18,8 +18,8 @@\n \n def pull_versions(version_number):\n     package_versions = OrderedDict()\n-    if version_number == \'here\':\n-        url = \'versions.cfg\'\n+    if version_number == "here":\n+        url = "versions.cfg"\n         versions_file = open(url)\n     else:\n         url = DIST_URL.format(version_number)\n@@ -28,7 +28,7 @@ def pull_versions(version_number):\n             raise ValueError("Version %s not found." % version_number)\n     for line in versions_file:\n         line = line.strip().replace(" ", "")\n-        if line and not (line.startswith(\'#\') or line.startswith(\'[\')):\n+        if line and not (line.startswith("#") or line.startswith("[")):\n             try:\n                 package, version = line.split("=")\n                 version = LooseVersion(version)\n@@ -48,9 +48,9 @@ def get_source_location(package_name):\n         # to this:\n         # https://raw.githubusercontent.com/plone/plone.batching\n         url = source.url\n-        url = url.replace(\'git:\', \'https:\')\n-        url = url.replace(\'.git\', \'\')\n-        url = url.replace(\'github.com\', \'raw.githubusercontent.com\')\n+        url = url.replace("git:", "https:")\n+        url = url.replace(".git", "")\n+        url = url.replace("github.com", "raw.githubusercontent.com")\n         return url, source.branch\n     return "", ""\n \n@@ -58,18 +58,15 @@ def get_source_location(package_name):\n def get_changelog(package_name):\n     source_url, branch = get_source_location(package_name)\n     if not source_url:\n-        return \'\'\n-    file_names = [\'CHANGES\', \'HISTORY\']\n-    file_extensions = [\'.rst\', \'.txt\']\n-    if \'github\' in source_url:\n-        paths = [\n-            \'{0}/\'.format(branch),\n-            \'{0}/docs/\'.format(branch),\n-        ]\n+        return ""\n+    file_names = ["CHANGES", "HISTORY"]\n+    file_extensions = [".rst", ".txt"]\n+    if "github" in source_url:\n+        paths = ["{0}/".format(branch), "{0}/docs/".format(branch)]\n     else:\n-        paths = [\'/\', \'/docs/\', \'/\'.join(package_name.split(\'.\')) + \'/\']\n+        paths = ["/", "/docs/", "/".join(package_name.split(".")) + "/"]\n     for pathable in product(paths, file_names, file_extensions):\n-        structure = \'\'.join(pathable)\n+        structure = "".join(pathable)\n         url = "{0}/{1}".format(source_url, structure)\n         try:\n             response = urllib.urlopen(url)\n@@ -78,17 +75,16 @@ def get_changelog(package_name):\n         else:\n             if response.code == 200:\n                 return response.read()\n-    return \'\'\n+    return ""\n \n \n class Changelog(object):\n-\n     def __init__(self, file_location=None, content=None):\n         self.data = OrderedDict()\n         if content is not None:\n             self._parse(content)\n         elif file_location is not None:\n-            with open(file_location, \'r\') as f:\n+            with open(file_location, "r") as f:\n                 self._parse(f.read())\n \n     def __iter__(self):\n@@ -120,9 +116,9 @@ def get_changes(self, start_version, end_version=None):\n             for key, entries in self.data[release].items():\n                 changes[key].extend(entries)\n         result = []\n-        for key in HEADINGS + [\'other\']:\n+        for key in HEADINGS + ["other"]:\n             if key in changes:\n-                if key != \'other\':\n+                if key != "other":\n                     result.append(key)\n                 result.extend(changes.pop(key))\n         return result\n@@ -138,7 +134,7 @@ def _parse(self, content):\n         def is_valid_version_section(x):\n             if x.tagname == "section":\n                 try:\n-                    LooseVersion(x[\'names\'][0].split()[0])\n+                    LooseVersion(x["names"][0].split()[0])\n                 except (ValueError, IndexError):\n                     pass\n                 else:\n@@ -146,26 +142,26 @@ def is_valid_version_section(x):\n             return False\n \n         def heading(x):\n-            if x.tagname != \'paragraph\':\n-                return \'\'\n+            if x.tagname != "paragraph":\n+                return ""\n             if x.rawsource in HEADINGS:\n                 return x.rawsource\n             # Might be an old heading or unknown.\n-            return OLD_HEADING_MAPPING.get(x.rawsource, \'\')\n+            return OLD_HEADING_MAPPING.get(x.rawsource, "")\n \n         def is_list_item(x):\n-            return x.tagname == \'list_item\'\n+            return x.tagname == "list_item"\n \n         found_sections = tree.traverse(condition=is_valid_version_section)\n         for section in found_sections:\n-            version = section[\'names\'][0].split()[0]\n+            version = section["names"][0].split()[0]\n             # Look for paragraph headings.\n             # When two are found, we have a section with:\n             # paragraph 1, bullet_list 1, paragraph 2, bullet_list 2.\n             # But a single bullet_list is handled fine too.\n             # Put items in dictionary, with the headings as possible keys.\n             entries = defaultdict(list)\n-            current = \'other\'\n+            current = "other"\n             for child in section.children:\n                 child_heading = heading(child)\n                 if child_heading:\n@@ -193,13 +189,15 @@ def build_unified_changelog(start_version, end_version):\n                     if version > prior_version:\n                         print("{0} has a newer version".format(package))\n                         packageChange = u"{0}: {1} {2} {3}".format(\n-                            package,\n-                            prior_version,\n-                            u"\\u2192",\n-                            version\n+                            package, prior_version, u"\\u2192", version\n+                        )\n+                        output_str += (\n+                            u"\\n"\n+                            + packageChange\n+                            + u"\\n"\n+                            + u"-" * len(packageChange)\n+                            + "\\n"\n                         )\n-                        output_str += u"\\n" + packageChange + \\\n-                            u"\\n" + u"-" * len(packageChange) + "\\n"\n \n                         logtext = get_changelog(package)\n                         if not logtext:\n@@ -217,7 +215,8 @@ def build_unified_changelog(start_version, end_version):\n                                     output_str += change + u"\\n\\n"\n                                 else:\n                                     change = change.replace(\n-                                        "\\n", "\\n" + " " * len(bullet))\n+                                        "\\n", "\\n" + " " * len(bullet)\n+                                    )\n                                     output_str += bullet + change + u"\\n\\n"\n                 except AttributeError as e:\n                     # Bad version line, skip\n@@ -225,4 +224,4 @@ def build_unified_changelog(start_version, end_version):\n     except KeyboardInterrupt:\n         pass\n \n-    print(output_str.encode(\'utf-8\'))\n+    print(output_str.encode("utf-8"))\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T00:37:50+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/34004c2b28dea05193668f91b42eb2e9c3367270

Call sources.items instead of iteritems.

iteritems does not exist in Python 3.

Files changed:
M plone/releaser/manage.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 29575ef..e53e8df 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -59,7 +59,7 @@ def checkPackageForUpdates(package_name, **kwargs):\n @arg("--interactive", default=False)\n def checkAllPackagesForUpdates(**kwargs):\n     sources = buildout.sources\n-    for package_name, source in Bar("Scanning").iter(sources.iteritems()):\n+    for package_name, source in Bar("Scanning").iter(sources.items()):\n         pkg = Package(buildout, package_name)\n         if kwargs["interactive"]:\n             pkg(action=ACTION_INTERACTIVE)\n@@ -73,7 +73,7 @@ def pulls():\n \n     g = Github(client_id=client_id, client_secret=client_secret)\n \n-    for package_name, source in buildout.sources.iteritems():\n+    for package_name, source in buildout.sources.items():\n         if source.path:\n             repo = g.get_repo(source.path)\n             pulls = [a for a in repo.get_pulls("open") if a.head.ref == source.branch]\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T00:38:08+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/7179ec301b357aef398629538143b44341a835de

Use a urlopen that works in Python 2 and 3.

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex 85bea6e..c71c69c 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -8,7 +8,12 @@\n from plone.releaser.release import HEADINGS\n from plone.releaser.release import OLD_HEADING_MAPPING\n \n-import urllib\n+try:\n+    # Python 3\n+    from urllib.request import urlopen\n+except ImportError:\n+    # Python 2\n+    from urllib2 import urlopen\n \n \n DIST_URL = "http://dist.plone.org/release/{0}/versions.cfg"\n@@ -23,7 +28,7 @@ def pull_versions(version_number):\n         versions_file = open(url)\n     else:\n         url = DIST_URL.format(version_number)\n-        versions_file = urllib.urlopen(url)\n+        versions_file = urlopen(url)\n         if versions_file.code == 404:\n             raise ValueError("Version %s not found." % version_number)\n     for line in versions_file:\n@@ -69,7 +74,7 @@ def get_changelog(package_name):\n         structure = "".join(pathable)\n         url = "{0}/{1}".format(source_url, structure)\n         try:\n-            response = urllib.urlopen(url)\n+            response = urlopen(url)\n         except IOError:\n             print("Unable to reach {0}".format(url))\n         else:\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T00:40:33+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/2b62ded034b554fd05668d0f1ec5411a0a6735a5

changelog DIST_URL: use https.

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex c71c69c..93902f8 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -16,7 +16,7 @@\n     from urllib2 import urlopen\n \n \n-DIST_URL = "http://dist.plone.org/release/{0}/versions.cfg"\n+DIST_URL = "https://dist.plone.org/release/{0}/versions.cfg"\n \n buildout = Buildout()\n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-17T01:02:18+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/8c90f40818c51f81570895db15d800c916bb5922

Ran python-modernize.

https://docs.plone.org/manage/upgrading/version_specific_migration/upgrade_to_python3.html#automated-fixing-with-modernize

Some manual edits, because I got 'print((...))' and python 2 imports in a try/except ImportError were replaced with six.

Files changed:
M plone/releaser/buildout.py
M plone/releaser/changelog.py
M plone/releaser/manage.py
M plone/releaser/package.py
M plone/releaser/pypi.py
M plone/releaser/release.py
M setup.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 5ae4e6e..4bc5189 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -67,7 +67,7 @@ def versions(self):\n         return config["versions"]\n \n     def __contains__(self, package_name):\n-        return package_name.lower() in self.versions.keys()\n+        return package_name.lower() in list(self.versions.keys())\n \n     def __getitem__(self, package_name):\n         if self.__contains__(package_name):\ndiff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex 93902f8..ff8b54c 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from collections import OrderedDict\n from collections import defaultdict\n from distutils.version import LooseVersion\n@@ -7,13 +8,8 @@\n from plone.releaser.buildout import Buildout\n from plone.releaser.release import HEADINGS\n from plone.releaser.release import OLD_HEADING_MAPPING\n-\n-try:\n-    # Python 3\n-    from urllib.request import urlopen\n-except ImportError:\n-    # Python 2\n-    from urllib2 import urlopen\n+from six.moves.urllib.request import urlopen\n+import six\n \n \n DIST_URL = "https://dist.plone.org/release/{0}/versions.cfg"\n@@ -96,13 +92,13 @@ def __iter__(self):\n         return self.data.__iter__()\n \n     def iteritems(self):\n-        return self.data.iteritems()\n+        return six.iteritems(self.data)\n \n     def get(self, version):\n         return self.data.get(version)\n \n     def get_changes(self, start_version, end_version=None):\n-        versions = self.data.keys()\n+        versions = list(self.data.keys())\n \n         end_version_index = 0\n         if end_version is not None:\n@@ -129,8 +125,8 @@ def get_changes(self, start_version, end_version=None):\n         return result\n \n     def latest(self):\n-        if self.data.items():\n-            return self.data.items()[0]\n+        if list(self.data.items()):\n+            return list(self.data.items())[0]\n         return None\n \n     def _parse(self, content):\n@@ -187,7 +183,7 @@ def build_unified_changelog(start_version, end_version):\n \n     output_str = ""\n     try:\n-        for package, version in current_versions.iteritems():\n+        for package, version in six.iteritems(current_versions):\n             if package in prior_versions:\n                 prior_version = prior_versions[package]\n                 try:\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex e53e8df..57ba08e 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from argh import ArghParser\n from argh import arg\n from argh.decorators import named\n@@ -18,6 +19,7 @@\n \n import datetime\n import keyring\n+import six\n \n \n # TODO\n@@ -41,7 +43,7 @@ def checkPypi(user):\n def jenkins_report():\n     """Read-only version of checkAllPackagesForUpdates."""\n     sources = buildout.sources\n-    for package_name, source in iter(sources.iteritems()):\n+    for package_name, source in iter(six.iteritems(sources)):\n         pkg = Package(buildout, package_name)\n         pkg(action=ACTION_REPORT)\n \n@@ -59,7 +61,7 @@ def checkPackageForUpdates(package_name, **kwargs):\n @arg("--interactive", default=False)\n def checkAllPackagesForUpdates(**kwargs):\n     sources = buildout.sources\n-    for package_name, source in Bar("Scanning").iter(sources.items()):\n+    for package_name, source in Bar("Scanning").iter(list(sources.items())):\n         pkg = Package(buildout, package_name)\n         if kwargs["interactive"]:\n             pkg(action=ACTION_INTERACTIVE)\ndiff --git a/plone/releaser/package.py b/plone/releaser/package.py\nindex f4f3b46..e7f9955 100644\n--- a/plone/releaser/package.py\n+++ b/plone/releaser/package.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from argh.interaction import confirm\n from configparser import NoOptionError\n from contextlib import contextmanager\ndiff --git a/plone/releaser/pypi.py b/plone/releaser/pypi.py\nindex 91db3dd..7b8f5e2 100644\n--- a/plone/releaser/pypi.py\n+++ b/plone/releaser/pypi.py\n@@ -1,9 +1,5 @@\n # -*- coding: utf-8 -*-\n-\n-try:\n-    from xmlrpclib import ServerProxy\n-except ImportError:\n-    from xmlrpc.client import ServerProxy\n+from six.moves.xmlrpc_client import ServerProxy\n \n \n def get_users_with_release_rights(package_name):\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex e793e17..126e037 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from copy import copy\n from plone.releaser.buildout import CheckoutsFile\n from plone.releaser.buildout import VersionsFile\n@@ -71,7 +72,7 @@\n     "Fixes:": "Bug fixes:",\n }\n KNOWN_HEADINGS = copy(HEADINGS)\n-KNOWN_HEADINGS.extend(OLD_HEADING_MAPPING.keys())\n+KNOWN_HEADINGS.extend(list(OLD_HEADING_MAPPING.keys()))\n \n \n ALWAYS_CHECKED_OUT_PACKAGES = (\ndiff --git a/setup.py b/setup.py\nindex 49baf7e..943ba56 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -40,6 +40,7 @@\n         "progress",\n         "PyGithub",\n         "keyring",\n+        "six",\n         "zest.releaser>=6.6.0",\n         "zestreleaser.towncrier>=1.0.0b3",\n         "docutils",\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-21T22:50:26+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/1e047b7e6f3e4b22032a9ef30d2b962df40ad2ed

Fixed bytes/unicode error in 'manage changelog'.

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex ff8b54c..34b67e9 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -28,10 +28,12 @@ def pull_versions(version_number):\n         if versions_file.code == 404:\n             raise ValueError("Version %s not found." % version_number)\n     for line in versions_file:\n-        line = line.strip().replace(" ", "")\n-        if line and not (line.startswith("#") or line.startswith("[")):\n+        if not isinstance(line, type(u"")):\n+            line = line.decode("utf-8")\n+        line = line.strip().replace(u" ", u"")\n+        if line and not (line.startswith(u"#") or line.startswith(u"[")):\n             try:\n-                package, version = line.split("=")\n+                package, version = line.split(u"=")\n                 version = LooseVersion(version)\n             except ValueError:\n                 pass\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-21T22:54:21+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/72e662030e0402a6a495271088a3834ef9bcad21

changelog: output string does not need to be encoded.

Otherwise you get an ugly one-liner with b'' on Python 3.

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex 34b67e9..acddb57 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -183,7 +183,7 @@ def build_unified_changelog(start_version, end_version):\n         print(e)\n         return\n \n-    output_str = ""\n+    output_str = u""\n     try:\n         for package, version in six.iteritems(current_versions):\n             if package in prior_versions:\n@@ -212,7 +212,7 @@ def build_unified_changelog(start_version, end_version):\n                         except ValueError as e:\n                             print(e)\n                         else:\n-                            bullet = "- "\n+                            bullet = u"- "\n                             for change in changes:\n                                 if change in HEADINGS:\n                                     output_str += change + u"\\n\\n"\n@@ -226,5 +226,4 @@ def build_unified_changelog(start_version, end_version):\n                     pass\n     except KeyboardInterrupt:\n         pass\n-\n-    print(output_str.encode("utf-8"))\n+    print(output_str)\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-21T23:13:02+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/c6142c3e589c6104e881802a92777463cdc6bde3

changelog: ignore packages without version.

This happens for lines with an '=' like this:

[versionannotations:python27]
towncrier =
    18.6.0 does not work on Python 2, see https://github.com/hawkowl/towncrier/issues/121

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex acddb57..e5d6d60 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -34,11 +34,13 @@ def pull_versions(version_number):\n         if line and not (line.startswith(u"#") or line.startswith(u"[")):\n             try:\n                 package, version = line.split(u"=")\n-                version = LooseVersion(version)\n             except ValueError:\n-                pass\n-            else:\n-                package_versions[package] = version\n+                continue\n+            if not version:\n+                # May be a line from versionannotation\n+                continue\n+            version = LooseVersion(version)\n+            package_versions[package] = version\n     print("Parsed {0}".format(url))\n     return package_versions\n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-21T23:22:12+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/885cc5451870fea2dc2e73f4f38713a8b3d88211

Fixed TypeError in manage changelog.

Not all versions can be compared.
We might need to switch from distutils.LooseVersion to something from setuptools.

Files changed:
M plone/releaser/changelog.py

b'diff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex e5d6d60..4f88c78 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -226,6 +226,14 @@ def build_unified_changelog(start_version, end_version):\n                 except AttributeError as e:\n                     # Bad version line, skip\n                     pass\n+                except TypeError:\n+                    # (Pdb) version > prior_version\n+                    # *** TypeError: \'<\' not supported between instances of \'int\' and \'str\'\n+                    # (Pdb) version, prior_version\n+                    # (LooseVersion (\'5.2.0\'), LooseVersion (\'5.2a1\'))\n+                    print("ERROR {0}: cannot compare prior version {1} with new version {2}".format(\n+                        package, prior_version, version)\n+                    )\n     except KeyboardInterrupt:\n         pass\n     print(output_str)\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-22T17:45:01+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/9182d3facd81d89ebd34be0aba6dc5faaa653afb

Fixed ugly bytes representation in commit report.

Files changed:
M plone/releaser/package.py

b'diff --git a/plone/releaser/package.py b/plone/releaser/package.py\nindex e7f9955..b7d06fd 100644\n--- a/plone/releaser/package.py\n+++ b/plone/releaser/package.py\n@@ -254,9 +254,9 @@ def print_commits(commits_list, message=None):\n \n         for commit in commits_list:\n             print(\n-                "    {0}: {1}".format(\n-                    commit.author.name.encode("ascii", "replace"),\n-                    commit.summary.encode("ascii", "replace"),\n+                u"    {0}: {1}".format(\n+                    commit.author.name,\n+                    commit.summary,\n                 )\n             )\n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-22T17:50:41+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/de4f8299a704cd5830d4fd5d872f3a4e785e4df2

Added news snippet for issue 25.

Files changed:
A news/25.bugfix

b'diff --git a/news/25.bugfix b/news/25.bugfix\nnew file mode 100644\nindex 0000000..f27f168\n--- /dev/null\n+++ b/news/25.bugfix\n@@ -0,0 +1 @@\n+Fixed Python 3 compatibility.  [maurits]\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2019-08-29T20:21:01+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/plone.releaser/commit/fa57959656436e9590b3bd6f13d7e83e421298b8

Merge pull request #26 from plone/maurits-issue-25-python3

[WIP] Fix Python 3 compatibility

Files changed:
A news/25.bugfix
M bootstrap.py
M plone/__init__.py
M plone/releaser/__init__.py
M plone/releaser/buildout.py
M plone/releaser/changelog.py
M plone/releaser/db.py
M plone/releaser/manage.py
M plone/releaser/package.py
M plone/releaser/pypi.py
M plone/releaser/release.py
M setup.py

b'diff --git a/bootstrap.py b/bootstrap.py\nindex a629566..bdda4e8 100644\n--- a/bootstrap.py\n+++ b/bootstrap.py\n@@ -27,7 +27,7 @@\n \n tmpeggs = tempfile.mkdtemp()\n \n-usage = \'\'\'\\\n+usage = """\\\n [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n \n Bootstraps a buildout-based project.\n@@ -37,30 +37,41 @@\n \n Note that by using --find-links to point to local resources, you can keep\n this script from going over the network.\n-\'\'\'\n+"""\n \n parser = OptionParser(usage=usage)\n parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n \n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-parser.add_option("--setuptools-version",\n-                  help="use a specific setuptools version")\n+parser.add_option(\n+    "-t",\n+    "--accept-buildout-test-releases",\n+    dest="accept_buildout_test_releases",\n+    action="store_true",\n+    default=False,\n+    help=(\n+        "Normally, if you do not specify a --version, the "\n+        "bootstrap script and buildout gets the newest "\n+        "*final* versions of zc.buildout and its recipes and "\n+        "extensions for you.  If you use this flag, "\n+        "bootstrap and buildout will get the newest releases "\n+        "even if they are alphas or betas."\n+    ),\n+)\n+parser.add_option(\n+    "-c",\n+    "--config-file",\n+    help=("Specify the path to the buildout configuration " "file to be used."),\n+)\n+parser.add_option(\n+    "-f", "--find-links", help=("Specify a URL to search for buildout releases")\n+)\n+parser.add_option(\n+    "--allow-site-packages",\n+    action="store_true",\n+    default=False,\n+    help=("Let bootstrap.py use existing site packages"),\n+)\n+parser.add_option("--setuptools-version", help="use a specific setuptools version")\n \n \n options, args = parser.parse_args()\n@@ -77,25 +88,26 @@\n     from urllib2 import urlopen\n \n ez = {}\n-exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n+exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n \n if not options.allow_site_packages:\n     # ez_setup imports site, which adds site packages\n     # this will remove them from the path to ensure that incompatible versions\n     # of setuptools are not in the path\n     import site\n+\n     # inside a virtualenv, there is no \'getsitepackages\'.\n     # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n+    if hasattr(site, "getsitepackages"):\n         for sitepackage_path in site.getsitepackages():\n             sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n \n setup_args = dict(to_dir=tmpeggs, download_delay=0)\n \n if options.setuptools_version is not None:\n-    setup_args[\'version\'] = options.setuptools_version\n+    setup_args["version"] = options.setuptools_version\n \n-ez[\'use_setuptools\'](**setup_args)\n+ez["use_setuptools"](**setup_args)\n import setuptools\n import pkg_resources\n \n@@ -110,28 +122,35 @@\n \n ws = pkg_resources.working_set\n \n-cmd = [sys.executable, \'-c\',\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n+cmd = [\n+    sys.executable,\n+    "-c",\n+    "from setuptools.command.easy_install import main; main()",\n+    "-mZqNxd",\n+    tmpeggs,\n+]\n \n find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n+    "bootstrap-testing-find-links",\n+    options.find_links\n+    or (\n+        "http://downloads.buildout.org/"\n+        if options.accept_buildout_test_releases\n+        else None\n+    ),\n+)\n if find_links:\n-    cmd.extend([\'-f\', find_links])\n+    cmd.extend(["-f", find_links])\n \n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n+setuptools_path = ws.find(pkg_resources.Requirement.parse("setuptools")).location\n \n-requirement = \'zc.buildout\'\n+requirement = "zc.buildout"\n version = options.version\n if version is None and not options.accept_buildout_test_releases:\n     # Figure out the most recent final version of zc.buildout.\n     import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n+\n+    _final_parts = "*final-", "*final"\n \n     def _final_version(parsed_version):\n         try:\n@@ -139,12 +158,11 @@ def _final_version(parsed_version):\n         except AttributeError:\n             # Older setuptools\n             for part in parsed_version:\n-                if (part[:1] == \'*\') and (part not in _final_parts):\n+                if (part[:1] == "*") and (part not in _final_parts):\n                     return False\n             return True\n \n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n+    index = setuptools.package_index.PackageIndex(search_path=[setuptools_path])\n     if find_links:\n         index.add_find_links((find_links,))\n     req = pkg_resources.Requirement.parse(requirement)\n@@ -163,13 +181,13 @@ def _final_version(parsed_version):\n             best.sort()\n             version = best[-1].version\n if version:\n-    requirement = \'==\'.join((requirement, version))\n+    requirement = "==".join((requirement, version))\n cmd.append(requirement)\n \n import subprocess\n+\n if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n+    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n \n ######################################################################\n # Import and run buildout\n@@ -178,12 +196,12 @@ def _final_version(parsed_version):\n ws.require(requirement)\n import zc.buildout.buildout\n \n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n+if not [a for a in args if "=" not in a]:\n+    args.append("bootstrap")\n \n # if -c was provided, we push it back into args for buildout\' main function\n if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n+    args[0:0] = ["-c", options.config_file]\n \n zc.buildout.buildout.main(args)\n shutil.rmtree(tmpeggs)\ndiff --git a/news/25.bugfix b/news/25.bugfix\nnew file mode 100644\nindex 0000000..f27f168\n--- /dev/null\n+++ b/news/25.bugfix\n@@ -0,0 +1 @@\n+Fixed Python 3 compatibility.  [maurits]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/releaser/__init__.py b/plone/releaser/__init__.py\nindex c39911e..bbebcd7 100644\n--- a/plone/releaser/__init__.py\n+++ b/plone/releaser/__init__.py\n@@ -1,44 +1,38 @@\n # -*- coding: utf-8 -*-\n THIRD_PARTY_PACKAGES = (\n-    \'Zope2\',\n-    \'ZODB3\',\n-    \'txtfilter\',\n-    \'Products.CMFActionIcons\',\n-    \'Products.CMFCalendar\',\n-    \'Products.CMFCore\',\n-    \'Products.CMFDefault\',\n-    \'Products.CMFTopic\',\n-    \'Products.CMFUid\',\n-    \'Products.DCWorkflow\',\n-    \'Products.GenericSetup\',\n-    \'Products.GroupUserFolder\',\n-    \'Products.PluggableAuthService\',\n-    \'Products.PluginRegistry\',\n-    \'Products.ZCatalog\',\n+    "Zope2",\n+    "ZODB3",\n+    "txtfilter",\n+    "Products.CMFActionIcons",\n+    "Products.CMFCalendar",\n+    "Products.CMFCore",\n+    "Products.CMFDefault",\n+    "Products.CMFTopic",\n+    "Products.CMFUid",\n+    "Products.DCWorkflow",\n+    "Products.GenericSetup",\n+    "Products.GroupUserFolder",\n+    "Products.PluggableAuthService",\n+    "Products.PluginRegistry",\n+    "Products.ZCatalog",\n )\n \n-IGNORED_PACKAGES = (\n-    \'plone.releaser\',\n-)\n+IGNORED_PACKAGES = ("plone.releaser",)\n \n ALWAYS_CHECKED_OUT = (\n-    \'Plone\',\n-    \'Products.CMFPlone\',\n-    \'plone.app.upgrade\',\n-    \'plone.app.locales\',\n+    "Plone",\n+    "Products.CMFPlone",\n+    "plone.app.upgrade",\n+    "plone.app.locales",\n )\n \n # Upon checking a package...\n # ... ask every time if an action should be performed\n-ACTION_INTERACTIVE = \'interactive\'\n+ACTION_INTERACTIVE = "interactive"\n # ... don\'t ask anything and perform all actions\n-ACTION_BATCH = \'batch\'\n+ACTION_BATCH = "batch"\n # ... don\'t ask anything *AND* don\'t make any action, just show the status\n # of the package\n-ACTION_REPORT = \'report\'\n+ACTION_REPORT = "report"\n \n-PACKAGE_ACTIONS = (\n-    ACTION_BATCH,\n-    ACTION_INTERACTIVE,\n-    ACTION_REPORT,\n-)\n+PACKAGE_ACTIONS = (ACTION_BATCH, ACTION_INTERACTIVE, ACTION_REPORT)\ndiff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 13476fe..4bc5189 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -12,12 +12,11 @@\n     from UserDict import UserDict\n \n PATH_RE = re.compile(\n-    \'(\\w+://)(.+@)*([\\w\\d\\.]+)(:[\\d]+){0,1}/(?P<path>.+(?=\\.git))(\\.git)\'\n+    "(\\w+://)(.+@)*([\\w\\d\\.]+)(:[\\d]+){0,1}/(?P<path>.+(?=\\.git))(\\.git)"\n )\n \n \n class Source(object):\n-\n     def __init__(self, protocol=None, url=None, push_url=None, branch=None):\n         self.protocol = protocol\n         self.url = url\n@@ -26,19 +25,20 @@ def __init__(self, protocol=None, url=None, push_url=None, branch=None):\n \n     def create_from_string(self, source_string):\n         protocol, url, extra_1, extra_2, extra_3 = (\n-            lambda a, b, c=None, d=None, e=None: (a, b, c, d, e))(*source_string.split())\n+            lambda a, b, c=None, d=None, e=None: (a, b, c, d, e)\n+        )(*source_string.split())\n         for param in [extra_1, extra_2, extra_3]:\n             if param is not None:\n-                key, value = param.split(\'=\')\n+                key, value = param.split("=")\n                 setattr(self, key, value)\n         self.protocol = protocol\n         self.url = url\n         if self.push_url is not None:\n-            self.push_url = self.push_url.split(\'=\')[-1]\n+            self.push_url = self.push_url.split("=")[-1]\n         if self.branch is None:\n-            self.branch = \'master\'\n+            self.branch = "master"\n         else:\n-            self.branch = self.branch.split(\'=\')[-1]\n+            self.branch = self.branch.split("=")[-1]\n         return self\n \n     @property\n@@ -46,12 +46,11 @@ def path(self):\n         if self.url:\n             match = PATH_RE.match(self.url)\n             if match:\n-                return match.groupdict()[\'path\']\n+                return match.groupdict()["path"]\n         return None\n \n \n class VersionsFile(object):\n-\n     def __init__(self, file_location):\n         self.file_location = file_location\n \n@@ -62,16 +61,13 @@ def versions(self):\n         We use strict=False to avoid a DuplicateOptionError.\n         This happens in coredev 4.3 because we pin \'babel\' and \'Babel\'.\n         """\n-        config = ConfigParser(\n-            interpolation=ExtendedInterpolation(),\n-            strict=False,\n-            )\n+        config = ConfigParser(interpolation=ExtendedInterpolation(), strict=False)\n         with open(self.file_location) as f:\n             config.read_file(f)\n-        return config[\'versions\']\n+        return config["versions"]\n \n     def __contains__(self, package_name):\n-        return package_name.lower() in self.versions.keys()\n+        return package_name.lower() in list(self.versions.keys())\n \n     def __getitem__(self, package_name):\n         if self.__contains__(package_name):\n@@ -81,7 +77,7 @@ def __getitem__(self, package_name):\n \n     def __setitem__(self, package_name, new_version):\n         path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path, \'r\') as f:\n+        with open(path, "r") as f:\n             versionstxt = f.read()\n \n         if package_name not in self:\n@@ -90,10 +86,10 @@ def __setitem__(self, package_name, new_version):\n \n         reg = re.compile(\n             "(^{0}[\\s\\=]+)[0-9\\.abrc]+(.post\\d+)?(.dev\\d+)?".format(package_name),\n-            re.MULTILINE\n+            re.MULTILINE,\n         )\n         newVersionsTxt = reg.sub(r"\\g<1>{0}".format(new_version), versionstxt)\n-        with open(path, \'w\') as f:\n+        with open(path, "w") as f:\n             f.write(newVersionsTxt)\n \n     def get(self, package_name):\n@@ -104,7 +100,6 @@ def set(self, package_name, new_version):\n \n \n class SourcesFile(UserDict):\n-\n     def __init__(self, file_location):\n         self.file_location = file_location\n \n@@ -115,7 +110,7 @@ def data(self):\n         with open(self.file_location) as f:\n             config.read_file(f)\n         sources_dict = OrderedDict()\n-        for name, value in config[\'sources\'].items():\n+        for name, value in config["sources"].items():\n             source = Source().create_from_string(value)\n             sources_dict[name] = source\n         return sources_dict\n@@ -128,7 +123,6 @@ def __iter__(self):\n \n \n class CheckoutsFile(UserDict):\n-\n     def __init__(self, file_location):\n         self.file_location = file_location\n \n@@ -137,8 +131,8 @@ def data(self):\n         config = ConfigParser(interpolation=ExtendedInterpolation())\n         with open(self.file_location) as f:\n             config.read_file(f)\n-        checkouts = config.get(\'buildout\', \'auto-checkout\')\n-        checkout_list = checkouts.split(\'\\n\')\n+        checkouts = config.get("buildout", "auto-checkout")\n+        checkout_list = checkouts.split("\\n")\n         return checkout_list\n \n     def __contains__(self, package_name):\n@@ -146,25 +140,18 @@ def __contains__(self, package_name):\n \n     def __setitem__(self, package_name, enabled=True):\n         path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path, \'r\') as f:\n+        with open(path, "r") as f:\n             checkoutstxt = f.read()\n-        with open(path, \'w\') as f:\n+        with open(path, "w") as f:\n             if enabled:\n                 fixes_text = "# test-only fixes:"\n-                reg = re.compile(\n-                    "^[\\s]*{0}\\n".format(fixes_text),\n-                    re.MULTILINE\n-                )\n+                reg = re.compile("^[\\s]*{0}\\n".format(fixes_text), re.MULTILINE)\n                 newCheckoutsTxt = reg.sub(\n-                    \'    {0}\\n{1}\\n\'.format(package_name, fixes_text),\n-                    checkoutstxt\n+                    "    {0}\\n{1}\\n".format(package_name, fixes_text), checkoutstxt\n                 )\n             else:\n-                reg = re.compile(\n-                    "^[\\s]*{0}\\n".format(package_name),\n-                    re.MULTILINE\n-                )\n-                newCheckoutsTxt = reg.sub(\'\', checkoutstxt)\n+                reg = re.compile("^[\\s]*{0}\\n".format(package_name), re.MULTILINE)\n+                newCheckoutsTxt = reg.sub("", checkoutstxt)\n             f.write(newCheckoutsTxt)\n \n     def __delitem__(self, package_name):\n@@ -189,11 +176,12 @@ def remove(self, package_name):\n \n \n class Buildout(object):\n-\n-    def __init__(self,\n-                 sources_file=\'sources.cfg\',\n-                 checkouts_file=\'checkouts.cfg\',\n-                 versions_file=\'versions.cfg\'):\n+    def __init__(\n+        self,\n+        sources_file="sources.cfg",\n+        checkouts_file="checkouts.cfg",\n+        versions_file="versions.cfg",\n+    ):\n         self.sources = SourcesFile(sources_file)\n         self.versions = VersionsFile(versions_file)\n         self.checkouts = CheckoutsFile(checkouts_file)\ndiff --git a/plone/releaser/changelog.py b/plone/releaser/changelog.py\nindex 1c46961..4f88c78 100644\n--- a/plone/releaser/changelog.py\n+++ b/plone/releaser/changelog.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from collections import OrderedDict\n from collections import defaultdict\n from distutils.version import LooseVersion\n@@ -7,35 +8,39 @@\n from plone.releaser.buildout import Buildout\n from plone.releaser.release import HEADINGS\n from plone.releaser.release import OLD_HEADING_MAPPING\n+from six.moves.urllib.request import urlopen\n+import six\n \n-import urllib\n \n-\n-DIST_URL = "http://dist.plone.org/release/{0}/versions.cfg"\n+DIST_URL = "https://dist.plone.org/release/{0}/versions.cfg"\n \n buildout = Buildout()\n \n \n def pull_versions(version_number):\n     package_versions = OrderedDict()\n-    if version_number == \'here\':\n-        url = \'versions.cfg\'\n+    if version_number == "here":\n+        url = "versions.cfg"\n         versions_file = open(url)\n     else:\n         url = DIST_URL.format(version_number)\n-        versions_file = urllib.urlopen(url)\n+        versions_file = urlopen(url)\n         if versions_file.code == 404:\n             raise ValueError("Version %s not found." % version_number)\n     for line in versions_file:\n-        line = line.strip().replace(" ", "")\n-        if line and not (line.startswith(\'#\') or line.startswith(\'[\')):\n+        if not isinstance(line, type(u"")):\n+            line = line.decode("utf-8")\n+        line = line.strip().replace(u" ", u"")\n+        if line and not (line.startswith(u"#") or line.startswith(u"[")):\n             try:\n-                package, version = line.split("=")\n-                version = LooseVersion(version)\n+                package, version = line.split(u"=")\n             except ValueError:\n-                pass\n-            else:\n-                package_versions[package] = version\n+                continue\n+            if not version:\n+                # May be a line from versionannotation\n+                continue\n+            version = LooseVersion(version)\n+            package_versions[package] = version\n     print("Parsed {0}".format(url))\n     return package_versions\n \n@@ -48,9 +53,9 @@ def get_source_location(package_name):\n         # to this:\n         # https://raw.githubusercontent.com/plone/plone.batching\n         url = source.url\n-        url = url.replace(\'git:\', \'https:\')\n-        url = url.replace(\'.git\', \'\')\n-        url = url.replace(\'github.com\', \'raw.githubusercontent.com\')\n+        url = url.replace("git:", "https:")\n+        url = url.replace(".git", "")\n+        url = url.replace("github.com", "raw.githubusercontent.com")\n         return url, source.branch\n     return "", ""\n \n@@ -58,50 +63,46 @@ def get_source_location(package_name):\n def get_changelog(package_name):\n     source_url, branch = get_source_location(package_name)\n     if not source_url:\n-        return \'\'\n-    file_names = [\'CHANGES\', \'HISTORY\']\n-    file_extensions = [\'.rst\', \'.txt\']\n-    if \'github\' in source_url:\n-        paths = [\n-            \'{0}/\'.format(branch),\n-            \'{0}/docs/\'.format(branch),\n-        ]\n+        return ""\n+    file_names = ["CHANGES", "HISTORY"]\n+    file_extensions = [".rst", ".txt"]\n+    if "github" in source_url:\n+        paths = ["{0}/".format(branch), "{0}/docs/".format(branch)]\n     else:\n-        paths = [\'/\', \'/docs/\', \'/\'.join(package_name.split(\'.\')) + \'/\']\n+        paths = ["/", "/docs/", "/".join(package_name.split(".")) + "/"]\n     for pathable in product(paths, file_names, file_extensions):\n-        structure = \'\'.join(pathable)\n+        structure = "".join(pathable)\n         url = "{0}/{1}".format(source_url, structure)\n         try:\n-            response = urllib.urlopen(url)\n+            response = urlopen(url)\n         except IOError:\n             print("Unable to reach {0}".format(url))\n         else:\n             if response.code == 200:\n                 return response.read()\n-    return \'\'\n+    return ""\n \n \n class Changelog(object):\n-\n     def __init__(self, file_location=None, content=None):\n         self.data = OrderedDict()\n         if content is not None:\n             self._parse(content)\n         elif file_location is not None:\n-            with open(file_location, \'r\') as f:\n+            with open(file_location, "r") as f:\n                 self._parse(f.read())\n \n     def __iter__(self):\n         return self.data.__iter__()\n \n     def iteritems(self):\n-        return self.data.iteritems()\n+        return six.iteritems(self.data)\n \n     def get(self, version):\n         return self.data.get(version)\n \n     def get_changes(self, start_version, end_version=None):\n-        versions = self.data.keys()\n+        versions = list(self.data.keys())\n \n         end_version_index = 0\n         if end_version is not None:\n@@ -120,16 +121,16 @@ def get_changes(self, start_version, end_version=None):\n             for key, entries in self.data[release].items():\n                 changes[key].extend(entries)\n         result = []\n-        for key in HEADINGS + [\'other\']:\n+        for key in HEADINGS + ["other"]:\n             if key in changes:\n-                if key != \'other\':\n+                if key != "other":\n                     result.append(key)\n                 result.extend(changes.pop(key))\n         return result\n \n     def latest(self):\n-        if self.data.items():\n-            return self.data.items()[0]\n+        if list(self.data.items()):\n+            return list(self.data.items())[0]\n         return None\n \n     def _parse(self, content):\n@@ -138,7 +139,7 @@ def _parse(self, content):\n         def is_valid_version_section(x):\n             if x.tagname == "section":\n                 try:\n-                    LooseVersion(x[\'names\'][0].split()[0])\n+                    LooseVersion(x["names"][0].split()[0])\n                 except (ValueError, IndexError):\n                     pass\n                 else:\n@@ -146,26 +147,26 @@ def is_valid_version_section(x):\n             return False\n \n         def heading(x):\n-            if x.tagname != \'paragraph\':\n-                return \'\'\n+            if x.tagname != "paragraph":\n+                return ""\n             if x.rawsource in HEADINGS:\n                 return x.rawsource\n             # Might be an old heading or unknown.\n-            return OLD_HEADING_MAPPING.get(x.rawsource, \'\')\n+            return OLD_HEADING_MAPPING.get(x.rawsource, "")\n \n         def is_list_item(x):\n-            return x.tagname == \'list_item\'\n+            return x.tagname == "list_item"\n \n         found_sections = tree.traverse(condition=is_valid_version_section)\n         for section in found_sections:\n-            version = section[\'names\'][0].split()[0]\n+            version = section["names"][0].split()[0]\n             # Look for paragraph headings.\n             # When two are found, we have a section with:\n             # paragraph 1, bullet_list 1, paragraph 2, bullet_list 2.\n             # But a single bullet_list is handled fine too.\n             # Put items in dictionary, with the headings as possible keys.\n             entries = defaultdict(list)\n-            current = \'other\'\n+            current = "other"\n             for child in section.children:\n                 child_heading = heading(child)\n                 if child_heading:\n@@ -180,26 +181,28 @@ def build_unified_changelog(start_version, end_version):\n     try:\n         prior_versions = pull_versions(start_version)\n         current_versions = pull_versions(end_version)\n-    except ValueError, e:\n+    except ValueError as e:\n         print(e)\n         return\n \n-    output_str = ""\n+    output_str = u""\n     try:\n-        for package, version in current_versions.iteritems():\n+        for package, version in six.iteritems(current_versions):\n             if package in prior_versions:\n                 prior_version = prior_versions[package]\n                 try:\n                     if version > prior_version:\n                         print("{0} has a newer version".format(package))\n                         packageChange = u"{0}: {1} {2} {3}".format(\n-                            package,\n-                            prior_version,\n-                            u"\\u2192",\n-                            version\n+                            package, prior_version, u"\\u2192", version\n+                        )\n+                        output_str += (\n+                            u"\\n"\n+                            + packageChange\n+                            + u"\\n"\n+                            + u"-" * len(packageChange)\n+                            + "\\n"\n                         )\n-                        output_str += u"\\n" + packageChange + \\\n-                            u"\\n" + u"-" * len(packageChange) + "\\n"\n \n                         logtext = get_changelog(package)\n                         if not logtext:\n@@ -208,21 +211,29 @@ def build_unified_changelog(start_version, end_version):\n                         changelog = Changelog(content=logtext)\n                         try:\n                             changes = changelog.get_changes(prior_version, version)\n-                        except ValueError, e:\n+                        except ValueError as e:\n                             print(e)\n                         else:\n-                            bullet = "- "\n+                            bullet = u"- "\n                             for change in changes:\n                                 if change in HEADINGS:\n                                     output_str += change + u"\\n\\n"\n                                 else:\n                                     change = change.replace(\n-                                        "\\n", "\\n" + " " * len(bullet))\n+                                        "\\n", "\\n" + " " * len(bullet)\n+                                    )\n                                     output_str += bullet + change + u"\\n\\n"\n                 except AttributeError as e:\n                     # Bad version line, skip\n                     pass\n+                except TypeError:\n+                    # (Pdb) version > prior_version\n+                    # *** TypeError: \'<\' not supported between instances of \'int\' and \'str\'\n+                    # (Pdb) version, prior_version\n+                    # (LooseVersion (\'5.2.0\'), LooseVersion (\'5.2a1\'))\n+                    print("ERROR {0}: cannot compare prior version {1} with new version {2}".format(\n+                        package, prior_version, version)\n+                    )\n     except KeyboardInterrupt:\n         pass\n-\n-    print(output_str.encode(\'utf-8\'))\n+    print(output_str)\ndiff --git a/plone/releaser/db.py b/plone/releaser/db.py\nindex 5d53d15..5982865 100644\n--- a/plone/releaser/db.py\n+++ b/plone/releaser/db.py\n@@ -4,21 +4,20 @@\n \n \n class IgnoresDB(object):\n-\n     def __init__(self):\n-        self._filename = \'.package_ignores\'\n+        self._filename = ".package_ignores"\n         if not os.path.isfile(self._filename):\n-            open(self._filename, \'w\').close()\n+            open(self._filename, "w").close()\n \n-        with open(self._filename, \'r\') as f:\n+        with open(self._filename, "r") as f:\n             content = f.read()\n-            if content != \'\':\n+            if content != "":\n                 self._db = json.loads(content)\n             else:\n                 self._db = {}\n \n     def save(self):\n-        with open(self._filename, \'w+\') as f:\n+        with open(self._filename, "w+") as f:\n             f.write(json.dumps(self._db))\n \n     def get(self, package_name):\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 77c06d5..57ba08e 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from argh import ArghParser\n from argh import arg\n from argh.decorators import named\n@@ -18,6 +19,7 @@\n \n import datetime\n import keyring\n+import six\n \n \n # TODO\n@@ -30,87 +32,86 @@ def checkPypi(user):\n             pass\n         else:\n             if not pypi.can_user_release_package_to_pypi(user, package):\n-                print("{0}: {1}".format(\n-                    package,\n-                    \', \'.join(pypi.get_users_with_release_rights(package))\n-                ))\n+                print(\n+                    "{0}: {1}".format(\n+                        package, ", ".join(pypi.get_users_with_release_rights(package))\n+                    )\n+                )\n \n \n-@named(\'jenkins\')\n+@named("jenkins")\n def jenkins_report():\n     """Read-only version of checkAllPackagesForUpdates."""\n     sources = buildout.sources\n-    for package_name, source in iter(sources.iteritems()):\n+    for package_name, source in iter(six.iteritems(sources)):\n         pkg = Package(buildout, package_name)\n         pkg(action=ACTION_REPORT)\n \n \n-@arg(\'--interactive\', default=False)\n+@arg("--interactive", default=False)\n def checkPackageForUpdates(package_name, **kwargs):\n     pkg = Package(buildout, package_name)\n-    if kwargs[\'interactive\']:\n+    if kwargs["interactive"]:\n         pkg(action=ACTION_INTERACTIVE)\n     else:\n         pkg(action=ACTION_BATCH)\n \n \n-@named(\'report\')\n-@arg(\'--interactive\', default=False)\n+@named("report")\n+@arg("--interactive", default=False)\n def checkAllPackagesForUpdates(**kwargs):\n     sources = buildout.sources\n-    for package_name, source in Bar(\'Scanning\').iter(sources.iteritems()):\n+    for package_name, source in Bar("Scanning").iter(list(sources.items())):\n         pkg = Package(buildout, package_name)\n-        if kwargs[\'interactive\']:\n+        if kwargs["interactive"]:\n             pkg(action=ACTION_INTERACTIVE)\n         else:\n             pkg(action=ACTION_REPORT)\n \n \n def pulls():\n-    client_id = \'b9f6639835b8c9cf462a\'\n-    client_secret = keyring.get_password(\'plone.releaser\', client_id)\n+    client_id = "b9f6639835b8c9cf462a"\n+    client_secret = keyring.get_password("plone.releaser", client_id)\n \n     g = Github(client_id=client_id, client_secret=client_secret)\n \n-    for package_name, source in buildout.sources.iteritems():\n+    for package_name, source in buildout.sources.items():\n         if source.path:\n             repo = g.get_repo(source.path)\n-            pulls = [a for a in repo.get_pulls(\n-                \'open\') if a.head.ref == source.branch]\n+            pulls = [a for a in repo.get_pulls("open") if a.head.ref == source.branch]\n             if pulls:\n                 print(package_name)\n                 for pull in pulls:\n-                    print("    {0}: {1} ({2})".format(\n-                        pull.user.login,\n-                        pull.title,\n-                        pull.url\n-                    ))\n+                    print(\n+                        "    {0}: {1} ({2})".format(\n+                            pull.user.login, pull.title, pull.url\n+                        )\n+                    )\n \n \n-@named(\'changelog\')\n-@arg(\'--start\')\n-@arg(\'--end\', default=\'here\')\n+@named("changelog")\n+@arg("--start")\n+@arg("--end", default="here")\n def changelog(**kwargs):\n     from plone.releaser.changelog import build_unified_changelog\n-    build_unified_changelog(kwargs[\'start\'], kwargs[\'end\'])\n \n+    build_unified_changelog(kwargs["start"], kwargs["end"])\n \n-@named(\'launchpad\')\n+\n+@named("launchpad")\n def create_launchpad_release(version):\n-    launchpad = Launchpad.login_with(\'plone.releaser\', \'production\')\n-    plone = launchpad.projects[\'plone\']\n+    launchpad = Launchpad.login_with("plone.releaser", "production")\n+    plone = launchpad.projects["plone"]\n     parsed_version = StrictVersion(version)\n     # Blech. This feels flimsy\n-    series_name = \'.\'.join([str(a) for a in parsed_version.version[0:2]])\n+    series_name = ".".join([str(a) for a in parsed_version.version[0:2]])\n     series = plone.getSeries(name=series_name)\n     if series is None:\n         return "No series named {0}.".format(series_name)\n     now = datetime.datetime.now().isoformat()\n-    milestone = series.newMilestone(name=version,\n-                                    date_targeted=now)\n+    milestone = series.newMilestone(name=version, date_targeted=now)\n     # TODO: Get release notes\n-    release = milestone.createProductRelease(date_released=now,\n-                                             release_notes=\'\')\n+    release = milestone.createProductRelease(date_released=now, release_notes="")\n \n     release_url = release.web_link\n \n@@ -119,16 +120,17 @@ def create_launchpad_release(version):\n \n def check_checkout(package_name, path):\n     if package_name not in CheckoutsFile(path):\n-        msg = \'Your package {0} is not on auto-checkout section\'\n+        msg = "Your package {0} is not on auto-checkout section"\n         raise KeyError(msg.format(package_name))\n \n \n def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     from zest.releaser.vcs import BaseVersionControl\n     from zest.releaser.utils import cleanup_version\n+\n     vcs = BaseVersionControl()\n     old_version = cleanup_version(vcs.version)\n-    new_version = \'{0}.{1}\'.format(old_version, jenkins_build_number)\n+    new_version = "{0}.{1}".format(old_version, jenkins_build_number)\n     vcs.version = new_version\n     return new_version\n \n@@ -139,20 +141,22 @@ def set_package_version(version_file_path, package_name, new_version):\n \n \n class Manage(object):\n-\n     def __call__(self, **kwargs):\n         parser = ArghParser()\n         parser.add_commands(\n-            [checkPypi,\n-             checkPackageForUpdates,\n-             checkAllPackagesForUpdates,\n-             pulls,\n-             changelog,\n-             create_launchpad_release,\n-             check_checkout,\n-             append_jenkins_build_number_to_package_version,\n-             set_package_version,\n-             jenkins_report])\n+            [\n+                checkPypi,\n+                checkPackageForUpdates,\n+                checkAllPackagesForUpdates,\n+                pulls,\n+                changelog,\n+                create_launchpad_release,\n+                check_checkout,\n+                append_jenkins_build_number_to_package_version,\n+                set_package_version,\n+                jenkins_report,\n+            ]\n+        )\n         parser.dispatch()\n \n \ndiff --git a/plone/releaser/package.py b/plone/releaser/package.py\nindex 92ebfed..b7d06fd 100644\n--- a/plone/releaser/package.py\n+++ b/plone/releaser/package.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from argh.interaction import confirm\n from configparser import NoOptionError\n from contextlib import contextmanager\n@@ -28,12 +29,7 @@ def git_repo(source):\n     http://preshing.com/20110920/the-python-with-statement-by-example/\n     """\n     tmp_dir = mkdtemp()\n-    repo = git.Repo.clone_from(\n-        source.url,\n-        tmp_dir,\n-        branch=source.branch,\n-        depth=100\n-    )\n+    repo = git.Repo.clone_from(source.url, tmp_dir, branch=source.branch, depth=100)\n \n     # give the control back\n     yield repo\n@@ -88,7 +84,7 @@ def __init__(self, buildout, package):\n \n     def __call__(self, action=ACTION_INTERACTIVE):\n         if action not in PACKAGE_ACTIONS:\n-            print(\'This package action does not exist: {0}\'.format(action))\n+            print("This package action does not exist: {0}".format(action))\n             return\n         self.set_interaction_and_report(action)\n \n@@ -96,9 +92,11 @@ def __call__(self, action=ACTION_INTERACTIVE):\n         # - is on the ignored list\n         # - there is no version available\n         # - is not hosted on a git VCS\n-        if self.name in IGNORED_PACKAGES or \\\n-                self.version is None or \\\n-                not self.is_git_hosted():\n+        if (\n+            self.name in IGNORED_PACKAGES\n+            or self.version is None\n+            or not self.is_git_hosted()\n+        ):\n             return\n \n         # clone the package and gather data about it\n@@ -118,43 +116,44 @@ def __call__(self, action=ACTION_INTERACTIVE):\n             if latest_ignored_commit is not None:\n                 try:\n                     commits_since_ignore = self._commits_between(\n-                        repo,\n-                        latest_ignored_commit,\n-                        self.source.branch\n+                        repo, latest_ignored_commit, self.source.branch\n                     )\n                 except git.exc.GitCommandError:\n-                    print(\'\\nCould not read commits for package {0}\'.format(self.name))\n+                    print("\\nCould not read commits for package {0}".format(self.name))\n                     return\n \n             # if there are no changes since the last release (i.e. last tag)\n-            if not commits_since_release \\\n-                    or \'Back to development\' in commits_since_release[0].message \\\n-                    or commits_since_release[0].message.startswith(\'vb\'):\n+            if (\n+                not commits_since_release\n+                or "Back to development" in commits_since_release[0].message\n+                or commits_since_release[0].message.startswith("vb")\n+            ):\n \n                 self.remove()\n \n             elif commits_since_ignore is None:\n                 # Check for checkout\n                 if self.name not in self.buildout.checkouts:\n-                    msg = \'\\nWARNING: No auto-checkout exists for {0}\\n Changes in {0}:\'  # noqa\n+                    msg = (\n+                        "\\nWARNING: No auto-checkout exists for {0}\\n Changes in {0}:"\n+                    )  # noqa\n                     self.print_commits(\n-                        commits_since_release,\n-                        message=msg.format(self.name)\n+                        commits_since_release, message=msg.format(self.name)\n                     )\n \n                     if self.name in THIRD_PARTY_PACKAGES:\n-                        msg = \'NOTE: {0} is a third-party package.\'\n+                        msg = "NOTE: {0} is a third-party package."\n                         print(msg.format(self.name))\n \n                     self.add(commits_since_release)\n \n                 else:\n                     if not self.interactive:\n-                        msg = \'\\nChanges in {0}:\'.format(self.name)\n+                        msg = "\\nChanges in {0}:".format(self.name)\n                         self.print_commits(commits_since_release, message=msg)\n \n                         if self.name in THIRD_PARTY_PACKAGES:\n-                            msg = \'NOTE: {0} is a third-party package.\'\n+                            msg = "NOTE: {0} is a third-party package."\n                             print(msg.format(self.name))\n \n     def set_interaction_and_report(self, action):\n@@ -169,9 +168,9 @@ def set_interaction_and_report(self, action):\n             self.report_only = False\n \n     def is_git_hosted(self):\n-        if self.source.protocol != \'git\':\n+        if self.source.protocol != "git":\n             if self.report_only:\n-                msg = \'Skipped check of {0} as it\\\'s not a git repo.\'\n+                msg = "Skipped check of {0} as it\'s not a git repo."\n                 print(msg.format(self.name))\n             return False\n         return True\n@@ -182,17 +181,17 @@ def get_version(self):\n             version = self.buildout.get_version(self.name)\n         except (NoOptionError, KeyError):\n             if self.report_only:\n-                print(\'No version available for {0}\'.format(self.name))\n+                print("No version available for {0}".format(self.name))\n \n         return version\n \n     def latest_tag(self, repo):\n         tag = None\n         try:\n-            tag = repo.git.describe(\'--abbrev=0\', \'--tags\')\n+            tag = repo.git.describe("--abbrev=0", "--tags")\n         except git.exc.GitCommandError:\n             if self.report_only:\n-                print(\'Unable to check tags for {0}\'.format(self.name))\n+                print("Unable to check tags for {0}".format(self.name))\n \n         return tag\n \n@@ -200,63 +199,53 @@ def latest_commits(self, repo):\n         commits = None\n \n         try:\n-            commits = self._commits_between(\n-                repo,\n-                self.version,\n-                self.source.branch\n-            )\n+            commits = self._commits_between(repo, self.version, self.source.branch)\n         except git.exc.GitCommandError:\n-            print(\'\\nCould not read commits for package {0}\'.format(self.name))\n+            print("\\nCould not read commits for package {0}".format(self.name))\n \n         return commits\n \n     @staticmethod\n     def _commits_between(repo, start, end):\n-        return list(\n-            repo.iter_commits(\n-                \'{0}..{1}\'.format(start, end)\n-            )\n-        )\n+        return list(repo.iter_commits("{0}..{1}".format(start, end)))\n \n     def remove(self):\n-        if self.name in self.buildout.checkouts and \\\n-                self.name not in ALWAYS_CHECKED_OUT:\n-            msg = \'\\nNo new changes in {0}, but it is listed for auto-checkout.\'  # noqa\n+        if self.name in self.buildout.checkouts and self.name not in ALWAYS_CHECKED_OUT:\n+            msg = "\\nNo new changes in {0}, but it is listed for auto-checkout."  # noqa\n             print(msg.format(self.name))\n \n             if self.report_only:\n                 return\n \n-            msg = \'Remove {0} from checkouts.cfg\'.format(self.name)\n+            msg = "Remove {0} from checkouts.cfg".format(self.name)\n             if confirm(msg, default=True, skip=not self.interactive):\n                 self.buildout.remove_from_checkouts(self.name)\n \n                 with buildout_coredev() as core_repo:\n-                    checkouts_path = os.path.join(os.getcwd(), \'checkouts.cfg\')\n+                    checkouts_path = os.path.join(os.getcwd(), "checkouts.cfg")\n                     core_repo.git.add(checkouts_path)\n-                    msg = \'No new changes in {0}\'.format(self.name)\n+                    msg = "No new changes in {0}".format(self.name)\n                     core_repo.git.commit(message=msg)\n \n     def add(self, commits_since_release):\n         if self.report_only:\n             return\n \n-        msg = \'Add {0} to checkouts.cfg\'.format(self.name)\n+        msg = "Add {0} to checkouts.cfg".format(self.name)\n         if confirm(msg, default=True, skip=not self.interactive):\n             self.buildout.add_to_checkouts(self.name)\n \n             with buildout_coredev() as core_repo:\n-                checkouts_path = os.path.join(os.getcwd(), \'checkouts.cfg\')\n+                checkouts_path = os.path.join(os.getcwd(), "checkouts.cfg")\n                 core_repo.index.add([checkouts_path])\n-                core_repo.index.commit(\'{0} has changes.\'.format(self.name))\n-\n-        elif confirm(\'Ignore changes in  {0}\'.format(self.name),\n-                     default=False,\n-                     skip=not self.interactive):\n-            self.commit_ignores.set(\n-                self.name,\n-                commits_since_release[0].hexsha\n-            )\n+                core_repo.index.commit("{0} has changes.".format(self.name))\n+\n+        elif confirm(\n+            "Ignore changes in  {0}".format(self.name),\n+            default=False,\n+            skip=not self.interactive,\n+        ):\n+            self.commit_ignores.set(self.name, commits_since_release[0].hexsha)\n \n     @staticmethod\n     def print_commits(commits_list, message=None):\n@@ -264,28 +253,28 @@ def print_commits(commits_list, message=None):\n             print(message)\n \n         for commit in commits_list:\n-            print(\'    {0}: {1}\'.format(\n-                commit.author.name.encode(\'ascii\', \'replace\'),\n-                commit.summary.encode(\'ascii\', \'replace\')\n-            ))\n+            print(\n+                u"    {0}: {1}".format(\n+                    commit.author.name,\n+                    commit.summary,\n+                )\n+            )\n \n     def update_version(self, tag):\n         if tag <= self.version:\n             return\n \n-        msg = \'\\nNewer version {0} is available for {1} (Currently {2})\'\n+        msg = "\\nNewer version {0} is available for {1} (Currently {2})"\n         print(msg.format(tag, self.name, self.version))\n \n         if self.report_only:\n             return\n \n-        if confirm(\'Update versions.cfg\',\n-                   default=True,\n-                   skip=not self.interactive):\n+        if confirm("Update versions.cfg", default=True, skip=not self.interactive):\n             self.buildout.set_version(self.name, tag)\n \n             with buildout_coredev() as core_repo:\n-                versions_path = os.path.join(os.getcwd(), \'versions.cfg\')\n+                versions_path = os.path.join(os.getcwd(), "versions.cfg")\n                 core_repo.git.add(versions_path)\n-                core_repo.git.commit(message=\'{0}={1}\'.format(self.name, tag))\n+                core_repo.git.commit(message="{0}={1}".format(self.name, tag))\n                 core_repo.git.push()\ndiff --git a/plone/releaser/pypi.py b/plone/releaser/pypi.py\nindex eb7600c..7b8f5e2 100644\n--- a/plone/releaser/pypi.py\n+++ b/plone/releaser/pypi.py\n@@ -1,15 +1,10 @@\n # -*- coding: utf-8 -*-\n-\n-try:\n-    from xmlrpclib import ServerProxy\n-except ImportError:\n-    from xmlrpc.client import ServerProxy\n+from six.moves.xmlrpc_client import ServerProxy\n \n \n def get_users_with_release_rights(package_name):\n-    client = ServerProxy(\'https://pypi.org/pypi\')\n-    existing_admins = set([\n-        user for role, user in client.package_roles(package_name)])\n+    client = ServerProxy("https://pypi.org/pypi")\n+    existing_admins = set([user for role, user in client.package_roles(package_name)])\n     return existing_admins\n \n \ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex 1e0dd35..126e037 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import print_function\n from copy import copy\n from plone.releaser.buildout import CheckoutsFile\n from plone.releaser.buildout import VersionsFile\n@@ -15,72 +16,73 @@\n import textwrap\n \n # Define texts to check for during prereleaser or add during postrelease.\n-NOTHING_CHANGED_YET = \'*add item here*\'\n+NOTHING_CHANGED_YET = "*add item here*"\n BREAKING_TEXT = """\n Breaking changes:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n FEATURE_TEXT = """\n New features:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n BUGFIXES_TEXT = """\n Bug fixes:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n-HEADERS = [\n-    BREAKING_TEXT,\n-    FEATURE_TEXT,\n-    BUGFIXES_TEXT,\n-]\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n+HEADERS = [BREAKING_TEXT, FEATURE_TEXT, BUGFIXES_TEXT]\n # Used by changelog.py:\n-HEADINGS = [\n-    \'Breaking changes:\',\n-    \'New features:\',\n-    \'Bug fixes:\',\n-]\n+HEADINGS = ["Breaking changes:", "New features:", "Bug fixes:"]\n # For compatibility with previous names of the headers.\n INCOMPATIBILITIES_TEXT = """\n Incompatibilities:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n NEW_TEXT = """\n New:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n FIXES_TEXT = """\n Fixes:\n \n - {}\n-""".format(NOTHING_CHANGED_YET)\n-OLD_HEADERS = [\n-    INCOMPATIBILITIES_TEXT,\n-    NEW_TEXT,\n-    FIXES_TEXT,\n-]\n+""".format(\n+    NOTHING_CHANGED_YET\n+)\n+OLD_HEADERS = [INCOMPATIBILITIES_TEXT, NEW_TEXT, FIXES_TEXT]\n ALL_HEADERS = copy(HEADERS)\n ALL_HEADERS.extend(OLD_HEADERS)\n OLD_HEADING_MAPPING = {\n-    \'Incompatibilities:\': \'Breaking changes:\',\n-    \'New:\': \'New features:\',\n-    \'Fixes:\': \'Bug fixes:\',\n+    "Incompatibilities:": "Breaking changes:",\n+    "New:": "New features:",\n+    "Fixes:": "Bug fixes:",\n }\n KNOWN_HEADINGS = copy(HEADINGS)\n-KNOWN_HEADINGS.extend(OLD_HEADING_MAPPING.keys())\n+KNOWN_HEADINGS.extend(list(OLD_HEADING_MAPPING.keys()))\n \n \n ALWAYS_CHECKED_OUT_PACKAGES = (\n-    \'Plone\',\n-    \'Products.CMFPlone\',\n-    \'plone.app.upgrade\',\n-    \'plone.app.locales\',\n+    "Plone",\n+    "Products.CMFPlone",\n+    "plone.app.upgrade",\n+    "plone.app.locales",\n )\n \n+\n def set_nothing_changed_yet(data):\n     """Set line that we look for in prerelease.\n \n@@ -90,7 +92,7 @@ def set_nothing_changed_yet(data):\n     Note that currently this must be a single line, because\n     zest.releaser looks for this text in each line.\n     """\n-    data[\'nothing_changed_yet\'] = NOTHING_CHANGED_YET\n+    data["nothing_changed_yet"] = NOTHING_CHANGED_YET\n \n \n def set_required_changelog(data):\n@@ -98,7 +100,7 @@ def set_required_changelog(data):\n \n     This is during the prerelease phase.\n     """\n-    data[\'required_changelog_text\'] = KNOWN_HEADINGS\n+    data["required_changelog_text"] = KNOWN_HEADINGS\n \n \n def set_new_changelog(data):\n@@ -107,8 +109,8 @@ def set_new_changelog(data):\n     Yes, this overrides what we have set in the prerelease, and that is\n     fine.\n     """\n-    text = \'\'.join(HEADERS)\n-    data[\'nothing_changed_yet\'] = textwrap.dedent(text).strip()\n+    text = "".join(HEADERS)\n+    data["nothing_changed_yet"] = textwrap.dedent(text).strip()\n \n \n def cleanup_changelog(data):\n@@ -129,42 +131,40 @@ def cleanup_changelog(data):\n     # The history_file is probably not set yet, as we are called too early.\n     # That might change subtly in future zest.releaser versions, so let\'s check\n     # it anyway.\n-    history_file = data.get(\'history_file\')\n+    history_file = data.get("history_file")\n     if history_file:\n-        contents = \'\\n\'.join(data[\'history_lines\'])\n-        encoding = data[\'history_encoding\']\n+        contents = "\\n".join(data["history_lines"])\n+        encoding = data["history_encoding"]\n     else:\n         # We do not want to copy the logic from zest.releaser that tries to\n         # find the history file, but we can check the most obvious spot.\n-        history_file = \'CHANGES.rst\'\n+        history_file = "CHANGES.rst"\n         if not os.path.exists(history_file):\n-            print(\'Cannot cleanup history, will try again later.\')\n+            print("Cannot cleanup history, will try again later.")\n             return\n         contents, encoding = read_text_file(history_file)\n     orig_contents = contents\n     changed = False\n     for header in ALL_HEADERS:\n         if header in contents:\n-            contents = contents.replace(header, \'\')\n+            contents = contents.replace(header, "")\n             changed = True\n     if not changed:\n         return\n-    write_text_file(\n-        history_file, contents, encoding=encoding)\n+    write_text_file(history_file, contents, encoding=encoding)\n     print("Cleaned up empty headers from history file {}".format(history_file))\n     # Update the data, otherwise our work may get overwritten.\n-    data[\'history_lines\'] = contents.split(\'\\n\')\n-    if not os.path.isdir(\'.git\'):\n-        print(\'Not a git checkout, cannot commit.\')\n+    data["history_lines"] = contents.split("\\n")\n+    if not os.path.isdir(".git"):\n+        print("Not a git checkout, cannot commit.")\n         return\n-    g = git.Git(\'.\')\n+    g = git.Git(".")\n     message = "Cleaned up empty headers from changelog.\\n\\n[ci skip]"\n     print(g.diff(history_file))\n     msg = "Commit changes?"\n     if not ask(msg, default=True):\n         # Restore original contents.\n-        write_text_file(\n-            history_file, orig_contents, encoding=encoding)\n+        write_text_file(history_file, orig_contents, encoding=encoding)\n         sys.exit()\n     print("Committing changes.")\n     print(g.add(history_file))\n@@ -172,10 +172,10 @@ def cleanup_changelog(data):\n \n \n def check_pypi_access(data):\n-    pypi_user = pypi.PypiConfig().config.get(\'pypi\', \'username\')\n-    if not can_user_release_package_to_pypi(pypi_user, data[\'name\']):\n+    pypi_user = pypi.PypiConfig().config.get("pypi", "username")\n+    if not can_user_release_package_to_pypi(pypi_user, data["name"]):\n         msg = "User {0} does not have pypi release rights to {1}. Continue?"\n-        if not ask(msg.format(pypi_user, data[\'name\']), default=False):\n+        if not ask(msg.format(pypi_user, data["name"]), default=False):\n             sys.exit()\n \n \n@@ -184,18 +184,18 @@ def update_core(data, branch=None):\n     if branch:\n         msg = "Ok to update coredev {0} versions.cfg/checkouts.cfg?".format(branch)\n     if ask(msg, default=True):\n-        root_path = os.path.join(os.getcwd(), \'../../\')\n+        root_path = os.path.join(os.getcwd(), "../../")\n         g = git.Git(root_path)\n         g.pull()  # make sure buildout.coredev is up-to-date\n-        package_name = data[\'name\']\n-        new_version = data[\'version\']\n+        package_name = data["name"]\n+        new_version = data["version"]\n         update_versions(package_name, new_version)\n         if package_name not in ALWAYS_CHECKED_OUT_PACKAGES:\n             remove_from_checkouts(package_name)\n         # git commit\n         message = "{0} {1}".format(package_name, new_version)\n-        g.add(\'versions.cfg\')\n-        g.add(\'checkouts.cfg\')\n+        g.add("versions.cfg")\n+        g.add("checkouts.cfg")\n         print("Committing changes.")\n         g.commit(message=message)\n         msg = "Ok to push coredev?"\n@@ -207,21 +207,21 @@ def update_core(data, branch=None):\n \n \n def update_other_core_branches(data):\n-    CORE_BRANCHES = [\'4.3\', \'5.1\', \'5.2\', ]\n-    package_name = data[\'name\']\n-    root_path = os.path.join(os.getcwd(), \'../../\')\n+    CORE_BRANCHES = ["4.3", "5.1", "5.2"]\n+    package_name = data["name"]\n+    root_path = os.path.join(os.getcwd(), "../../")\n \n     def _get_current_core_branch():\n         g = git.Repo(root_path)\n         return g.head.reference.name\n \n     def _get_package_branch(package_name):\n-        path = os.path.join(root_path, \'sources.cfg\')\n+        path = os.path.join(root_path, "sources.cfg")\n         sources = SourcesFile(path)\n         try:\n             return sources[package_name].branch\n         except KeyError:  # package is not on sources.cfg of the current core branch\n-            return \'\'\n+            return ""\n \n     current_core_branch = _get_current_core_branch()\n     CORE_BRANCHES.remove(current_core_branch)\n@@ -238,9 +238,8 @@ def _get_package_branch(package_name):\n                 update_core(data, branch=branch_name)\n             except Exception:\n                 print(\n-                    \'There was an error trying to update {0} on {1}\'.format(\n-                        package_name,\n-                        branch_name,\n+                    "There was an error trying to update {0} on {1}".format(\n+                        package_name, branch_name\n                     )\n                 )\n \n@@ -250,13 +249,13 @@ def _get_package_branch(package_name):\n def update_versions(package_name, new_version):\n     # Update version\n     print("Updating versions.cfg")\n-    path = os.path.join(os.getcwd(), \'../../versions.cfg\')\n+    path = os.path.join(os.getcwd(), "../../versions.cfg")\n     versions = VersionsFile(path)\n     versions.set(package_name, new_version)\n \n \n def remove_from_checkouts(package_name):\n     print("Removing package from checkouts.cfg")\n-    path = os.path.join(os.getcwd(), \'../../checkouts.cfg\')\n+    path = os.path.join(os.getcwd(), "../../checkouts.cfg")\n     checkouts = CheckoutsFile(path)\n     checkouts.remove(package_name)\ndiff --git a/setup.py b/setup.py\nindex 56b046f..943ba56 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,74 +3,73 @@\n from setuptools import setup\n \n \n-version = \'1.7.3.dev0\'\n+version = "1.7.3.dev0"\n \n-long_description = \'{0}\\n{1}\'.format(\n-    open(\'README.rst\').read(),\n-    open(\'CHANGES.rst\').read()\n+long_description = "{0}\\n{1}".format(\n+    open("README.rst").read(), open("CHANGES.rst").read()\n )\n \n setup(\n-    name=\'plone.releaser\',\n+    name="plone.releaser",\n     version=version,\n-    description=\'Plone release management utilities\',\n+    description="Plone release management utilities",\n     long_description=long_description,\n     # Get more strings from\n     # https://pypi.python.org/pypi?:action=list_classifiers\n     classifiers=[\n-      \'Framework :: Plone\',\n-      "License :: OSI Approved :: GNU General Public License (GPL)",\n-      \'Programming Language :: Python\',\n-      \'Programming Language :: Python :: 2.7\',\n+        "Framework :: Plone",\n+        "License :: OSI Approved :: GNU General Public License (GPL)",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n     ],\n-    keywords=\'plone release\',\n-    author=\'Eric Steele\',\n-    author_email=\'eric@esteele.net\',\n-    url=\'https://github.com/plone/plone.releaser\',\n-    license=\'GPL\',\n+    keywords="plone release",\n+    author="Eric Steele",\n+    author_email="eric@esteele.net",\n+    url="https://github.com/plone/plone.releaser",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'argh\',\n-        \'gitpython>=0.3\',\n-        \'configparser\',\n-        \'argcomplete\',\n-        \'progress\',\n-        \'PyGithub\',\n-        \'keyring\',\n-        \'zest.releaser>=6.6.0\',\n-        \'zestreleaser.towncrier>=1.0.0b3\',\n-        \'docutils\',\n-        \'launchpadlib\',\n+        "setuptools",\n+        "argh",\n+        "gitpython>=0.3",\n+        "configparser",\n+        "argcomplete",\n+        "progress",\n+        "PyGithub",\n+        "keyring",\n+        "six",\n+        "zest.releaser>=6.6.0",\n+        "zestreleaser.towncrier>=1.0.0b3",\n+        "docutils",\n+        "launchpadlib",\n     ],\n     entry_points={\n-        \'console_scripts\': [\n-            \'manage = plone.releaser.manage:manage\',\n+        "console_scripts": ["manage = plone.releaser.manage:manage"],\n+        "zest.releaser.prereleaser.before": [\n+            (\n+                "set_nothing_changed_yet="\n+                "plone.releaser.release:set_nothing_changed_yet"\n+            ),\n+            ("set_required_changelog=" "plone.releaser.release:set_required_changelog"),\n+            ("cleanup_changelog=" "plone.releaser.release:cleanup_changelog"),\n         ],\n-        \'zest.releaser.prereleaser.before\': [\n-            (\'set_nothing_changed_yet=\'\n-             \'plone.releaser.release:set_nothing_changed_yet\'),\n-            (\'set_required_changelog=\'\n-             \'plone.releaser.release:set_required_changelog\'),\n-            (\'cleanup_changelog=\'\n-             \'plone.releaser.release:cleanup_changelog\'),\n-        ],\n-        \'zest.releaser.prereleaser.middle\': [\n+        "zest.releaser.prereleaser.middle": [\n             # Note: we explicitly call cleanup_changelog twice.\n-            (\'cleanup_changelog=\'\n-             \'plone.releaser.release:cleanup_changelog\'),\n-            \'check_pypi=plone.releaser.release:check_pypi_access\',\n+            ("cleanup_changelog=" "plone.releaser.release:cleanup_changelog"),\n+            "check_pypi=plone.releaser.release:check_pypi_access",\n         ],\n-        \'zest.releaser.releaser.after\': [\n-            \'update_core=plone.releaser.release:update_core\',\n-            (\'update_other_core_branches=\'\n-             \'plone.releaser.release:update_other_core_branches\'),\n+        "zest.releaser.releaser.after": [\n+            "update_core=plone.releaser.release:update_core",\n+            (\n+                "update_other_core_branches="\n+                "plone.releaser.release:update_other_core_branches"\n+            ),\n         ],\n-        \'zest.releaser.postreleaser.before\': [\n-            \'set_new_changelog=plone.releaser.release:set_new_changelog\',\n+        "zest.releaser.postreleaser.before": [\n+            "set_new_changelog=plone.releaser.release:set_new_changelog"\n         ],\n     },\n )\n'

