Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-01-30T10:34:15+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.supermodel/commit/cce809eb81ee60c8119a766649393e1087c2afe7

start porting to Python 3

Files changed:
M plone/supermodel/__init__.py
M plone/supermodel/converters.py
M plone/supermodel/exportimport.py
M plone/supermodel/fields.rst
M plone/supermodel/parser.py
M plone/supermodel/schema.rst
M plone/supermodel/tests.py
M plone/supermodel/utils.py

b'diff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 5b3a582..cd8f4ad 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,4 +1,7 @@\n # -*- coding: utf-8 -*-\n+import sys\n+PY3 = sys.version_info[0] == 3\n+\n from plone.supermodel import model\n from plone.supermodel import parser\n from plone.supermodel import serializer\n@@ -8,11 +11,24 @@\n from six import StringIO\n from zope.interface import moduleProvides\n \n+if PY3:\n+    from io import BytesIO\n+else:\n+    from StringIO import StringIO\n \n # Cache models by absolute filename\n _model_cache = {}\n \n \n+def b(s):\n+    if PY3:\n+        if not isinstance(s, str):\n+            return s\n+        return bytes(s, encoding=\'latin-1\')\n+    else:\n+        return s\n+\n+\n def xmlSchema(filename, schema=u"", policy=u"", _frame=2):\n     _model = loadFile(filename, policy=policy, _frame=_frame + 1)\n     return _model.schemata[schema]\n@@ -30,7 +46,11 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n \n \n def loadString(model, policy=u""):\n-    return parser.parse(StringIO(model), policy=policy)\n+    if PY3:\n+        source = BytesIO(b(model))\n+    else:\n+        source = StringIO(model)\n+    return parser.parse(source, policy=policy)\n \n \n def serializeSchema(schema, name=u""):\ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex dbe9004..fa415bc 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from plone.supermodel import PY3\n from plone.supermodel.interfaces import IToUnicode\n from plone.supermodel.utils import fieldTypecast\n from zope.component import adapter\n@@ -37,7 +38,9 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        return six.text_type(value)\n+        if PY3:\n+            return str(value)\n+        return unicode(value)\n \n \n # Date/time fields\n@@ -97,7 +100,9 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        return six.text_type(value.__identifier__)\n+        if PY3:\n+            return value.__identifier__\n+        return unicode(value.__identifier__)\n \n \n # Object fields - we can read, but not write, as there is no way to know\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 0270c03..d24521c 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n from lxml import etree\n+from plone.supermodel import b, PY3\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IFieldExportImportHandler\n@@ -26,6 +27,11 @@\n except:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n+if PY3:\n+    stringish_types = (bytes, str)\n+else:\n+    stringish_types = (str, unicode)\n+\n \n class OrderedDictField(zope.schema.Dict):\n     _type = OrderedDict\n@@ -398,8 +404,8 @@ def write(self, field, name, type, elementName=\'field\'):\n             value = []\n             for term in field.vocabulary:\n                 if (\n-                    not isinstance(term.value, six.string_types, ) or\n-                    term.token != term.value.encode(\'unicode_escape\')\n+                    not isinstance(term.value, stringish_types) or\n+                    b(term.token) != term.value.encode(\'unicode_escape\')\n                 ):\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex b245cea..f62d8b4 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -30,7 +30,12 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from plone.supermodel import PY3\n+    >>> if PY3:\n+    ...     from io import StringIO\n+    ... else:\n+    ...     from StringIO import StringIO\n+    >>> from plone.supermodel import b\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -53,12 +58,12 @@ Bytes\n \n     >>> field = schema.Bytes(__name__="dummy", title=u"Test",\n     ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=\'abc\', missing_value=\'m\',\n+    ...     default=b(\'abc\'), missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Bytes">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -99,12 +104,12 @@ BytesLine\n \n     >>> field = schema.BytesLine(__name__="dummy", title=u"Test",\n     ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=\'abc\', missing_value=\'m\',\n+    ...     default=b(\'abc\'), missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.BytesLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -150,7 +155,7 @@ ASCII\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.ASCII">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -196,7 +201,7 @@ ASCIILine\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.ASCIILine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -242,7 +247,7 @@ Text\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Text">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -288,7 +293,7 @@ TextLine\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.TextLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -334,7 +339,7 @@ SourceText\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.SourceText">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -380,7 +385,7 @@ URI\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.URI">\n       <default>http://plone.org</default>\n       <description>Test desc</description>\n@@ -426,7 +431,7 @@ Id\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Id">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -472,7 +477,7 @@ DottedName\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.DottedName">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -524,7 +529,7 @@ Password\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Password">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -569,7 +574,7 @@ Bool\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Bool">\n       <default>False</default>\n       <description>Test desc</description>\n@@ -609,7 +614,7 @@ Int\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Int">\n       <default>12</default>\n       <description>Test desc</description>\n@@ -655,7 +660,7 @@ Float\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Float">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -702,7 +707,7 @@ Decimal\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Decimal">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -748,7 +753,7 @@ Date\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Date">\n       <default>2001-01-02</default>\n       <description>Test desc</description>\n@@ -794,7 +799,7 @@ Datetime\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Datetime">\n       <default>2001-01-02 01:02:03</default>\n       <description>Test desc</description>\n@@ -840,7 +845,7 @@ InterfaceField\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.InterfaceField">\n       <default>plone.supermodel.tests.IDummy</default>\n       <description>Test desc</description>\n@@ -881,7 +886,7 @@ Tuple\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Tuple">\n       <default>\n         <element>1</element>\n@@ -938,7 +943,7 @@ List\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.List">\n       <default>\n         <element>1</element>\n@@ -995,7 +1000,7 @@ Set\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Set">\n       <default>\n         <element>1</element>\n@@ -1052,7 +1057,7 @@ FrozenSet\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.FrozenSet">\n       <default>\n         <element>1</element>\n@@ -1110,7 +1115,7 @@ Dict\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Dict">\n       <default>\n         <element key="a">1</element>\n@@ -1179,7 +1184,7 @@ fields will be omitted, as there is no way to write these reliably.\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType) #doctest: +ELLIPSIS\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Object">\n       <description>Test desc</description>\n       <readonly>True</readonly>\n@@ -1244,7 +1249,7 @@ These can be both exported and imported.\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1291,7 +1296,7 @@ a unicode string when importing.\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1353,7 +1358,7 @@ tokens are the utf8-encoded values).\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1390,7 +1395,7 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n     ...     )\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element).decode(\'latin-1\'))\n     <field name="dummy" type="zope.schema.Choice">\n       <title>Test</title>\n       <values>\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 10ba2eb..9828f15 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n from lxml import etree\n+from plone.supermodel import PY3\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import DEFAULT_ORDER\n from plone.supermodel.interfaces import FIELDSETS_KEY\n@@ -24,6 +25,12 @@\n import linecache\n import six\n import sys\n+import traceback\n+\n+if PY3:\n+    string_types = str,\n+else:\n+    string_types = basestring,\n \n \n # Exception\n@@ -31,20 +38,21 @@\n \n class SupermodelParseError(Exception):\n \n-    def __init__(self, orig_exc, fname, element):\n+    def __init__(self, orig_exc, fname, element, tb):\n         msg = str(orig_exc)\n-\n         lineno = None\n         if hasattr(orig_exc, \'lineno\'):\n             lineno = orig_exc.lineno\n         elif element is not None:\n             lineno = getattr(element, \'sourceline\', \'unknown\')\n-\n         if fname or lineno != \'unknown\':\n             msg += \'\\n  File "%s", line %s\' % (fname or \'<unknown>\', lineno)\n         if fname and lineno:\n             line = linecache.getline(fname, lineno).strip()\n             msg += \'\\n    %s\' % line\n+        msg += \'\\n\'\n+        msg += \'\'.join(traceback.format_tb(tb))\n+        msg += \'\\n\'\n         self.args = [msg]\n \n \n@@ -65,7 +73,7 @@ def name(self, schemaName, tree):\n # Algorithm\n def parse(source, policy=u""):\n     fname = None\n-    if isinstance(source, six.string_types):\n+    if isinstance(source, string_types):\n         fname = source\n \n     try:\n@@ -75,11 +83,7 @@ def parse(source, policy=u""):\n         # the filename and line number of the element that caused the problem.\n         # Keep the original traceback so the developer can debug where the\n         # problem happened.\n-        six.reraise(SupermodelParseError(\n-            e,\n-            fname,\n-            parseinfo.stack[-1]\n-        ), None, sys.exc_info()[2])\n+        raise SupermodelParseError(e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n \n \n def _parse(source, policy):\n@@ -197,7 +201,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     fieldset_order = subelement.get(\'order\')\n                     if fieldset_order is None:\n                         fieldset_order = DEFAULT_ORDER\n-                    elif isinstance(fieldset_order, six.string_types):\n+                    elif isinstance(fieldset_order, string_types):\n                         fieldset_order = int(fieldset_order)\n                     fieldset = fieldsets_by_name[fieldset_name] = Fieldset(\n                         fieldset_name,\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex 4826284..90d756d 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -26,7 +26,12 @@ and can be loaded from the configure.zcml file of plone.supermodel.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from plone.supermodel import PY3\n+    >>> if PY3:\n+    ...     from io import StringIO\n+    ... else:\n+    ...     from StringIO import StringIO\n+\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -58,8 +63,8 @@ We can parse this model using the loadString() function:\n \n This will load one schema, with the default name u"":\n \n-    >>> model.schemata.keys()\n-    [u\'\']\n+    >>> list(model.schemata.keys())\n+    [\'\']\n \n We can inspect this schema and see that it contains zope.schema fields with\n attributes corresponding to the values set in XML.\n@@ -106,7 +111,7 @@ lxml.)\n In addition to parsing, we can serialize a model to an XML representation:\n \n     >>> from plone.supermodel import serializeModel\n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -166,7 +171,7 @@ directory.\n     >>> tmpdir = tempfile.mkdtemp()\n     >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n     >>> schema_file = open(schema_filename, "w")\n-    >>> schema_file.write(schema)\n+    >>> foo = schema_file.write(schema)\n     >>> schema_file.close()\n \n We can define interfaces from this using a helper function:\n@@ -194,7 +199,7 @@ dict as per the serializeModel() method seen above, or you can write a model\n of just a single schema using serializeSchema():\n \n     >>> from plone.supermodel import serializeSchema\n-    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestContent).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -207,7 +212,7 @@ of just a single schema using serializeSchema():\n       </schema>\n     </model>\n \n-    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestMetadata, name=u"metadata").decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema name="metadata">\n         <field name="created" type="zope.schema.Datetime">\n@@ -290,7 +295,7 @@ We should also verify that the description field was indeed overridden:\n \n Finally, let\'s verify that bases are preserved upon serialisation:\n \n-    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(model.schema).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema based-on="plone.supermodel.tests.IBase">\n         <field name="description" type="zope.schema.Text">\n@@ -403,7 +408,7 @@ default schema above is unrelated to the one in the metadata schema.\n When we serialise a schema with fieldsets, fields will be grouped by\n fieldset.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -482,7 +487,7 @@ in action.\n \n The model\'s serialization should include the invariant.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <invariant>plone.supermodel.tests.dummy_invariant</invariant>\n@@ -561,7 +566,7 @@ as a zope.i18nmessageid message id rather than a basic Unicode string::\n     <... \'zope.i18nmessageid.message.Message\'>\n     >>> msgid.default\n     u\'Title\'\n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -610,14 +615,14 @@ may expect to be able to parse a format like this:\n We can register schema and field metadata handlers as named utilities.\n Metadata handlers should be able to reciprocally read and write metadata.\n \n-    >>> from zope.interface import implements\n+    >>> from zope.interface import implementer\n     >>> from zope.component import provideUtility\n \n     >>> from plone.supermodel.interfaces import ISchemaMetadataHandler\n     >>> from plone.supermodel.utils import ns\n \n-    >>> class FormLayoutMetadata(object):\n-    ...     implements(ISchemaMetadataHandler)\n+    >>> @implementer(ISchemaMetadataHandler)\n+    ... class FormLayoutMetadata(object):\n     ...\n     ...     namespace = "http://namespaces.acme.com/ui"\n     ...     prefix = "ui"\n@@ -635,8 +640,8 @@ Metadata handlers should be able to reciprocally read and write metadata.\n     >>> provideUtility(component=FormLayoutMetadata(), name=\'acme.ui.schema\')\n \n     >>> from plone.supermodel.interfaces import IFieldMetadataHandler\n-    >>> class FieldWidgetMetadata(object):\n-    ...     implements(IFieldMetadataHandler)\n+    >>> @implementer(IFieldMetadataHandler)\n+    ... class FieldWidgetMetadata(object):\n     ...\n     ...     namespace = "http://namespaces.acme.com/ui"\n     ...     prefix = "ui"\n@@ -671,7 +676,7 @@ and each field, respectively.\n Of course, we can also serialize the schema back to XML. Here, the \'prefix\'\n set in the utility (if any) will be used by default.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema ui:layout="horizontal">\n         <field name="title" type="zope.schema.TextLine" ui:widget="largetype">\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 46d8b5c..663f29c 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -1,5 +1,10 @@\n # -*- coding: utf-8 -*-\n+try:\n+    from io import StringIO, BytesIO\n+except ImportError:\n+    from cStringIO import StringIO\n from lxml import etree\n+from plone.supermodel import b, PY3\n from plone.supermodel import utils\n from plone.supermodel.exportimport import ChoiceHandler\n from plone.supermodel.interfaces import IDefaultFactory\n@@ -19,6 +24,8 @@\n \n import doctest\n import unittest\n+import re\n+import sys\n import zope.component.testing\n \n \n@@ -332,7 +339,7 @@ class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n         IBase1.setTaggedValue(u"foo", {1: 1, 2: 1})      # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3}) # least specific of the bases\n+        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n         ISchema.setTaggedValue(u"foo", {4: 4, 5: 4})      # most specific\n \n         self.assertEqual({1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, u"foo"))\n@@ -346,48 +353,52 @@ def setUp(self):\n     tearDown = zope.component.testing.tearDown\n \n     def _assertSerialized(self, field, value, expected):\n-        element = utils.valueToElement(field, value, \'value\')\n-        sio = StringIO()\n+        element = utils.valueToElement(field, value, b(\'value\'))\n+        if PY3:\n+            sio = BytesIO()\n+        else:\n+            sio = StringIO()\n         etree.ElementTree(element).write(sio)\n         self.assertEqual(sio.getvalue(), expected)\n         unserialized = utils.elementToValue(field, element)\n-        self.assertEqual(value, unserialized)\n+        self.assertEqual(value, b(unserialized))\n \n     def test_lists(self):\n         field = schema.List(value_type=schema.Int())\n         value = []\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b(\'<value/>\'))\n         value = [1, 2]\n-        self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element>1</element>\'\n-            \'<element>2</element>\'\n-            \'</value>\'\n+        self._assertSerialized(\n+            field, value,\n+            b(\'<value>\'\n+              \'<element>1</element>\'\n+              \'<element>2</element>\'\n+              \'</value>\')\n             )\n \n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b(\'<value/>\'))\n         value = [[1], [1, 2], []]\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element><element>1</element></element>\'\n-            \'<element><element>1</element><element>2</element></element>\'\n-            \'<element/>\'\n-            \'</value>\'\n+            b(\'<value>\'\n+              \'<element><element>1</element></element>\'\n+              \'<element><element>1</element><element>2</element></element>\'\n+              \'<element/>\'\n+              \'</value>\')\n             )\n \n     def test_dicts(self):\n         field = schema.Dict(key_type=schema.Int(), value_type=schema.TextLine())\n         value = {}\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b(\'<value/>\'))\n         value = {1: \'one\', 2: \'two\'}\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element key="1">one</element>\'\n-            \'<element key="2">two</element>\'\n-            \'</value>\'\n+            b(\'<value>\'\n+              \'<element key="1">one</element>\'\n+              \'<element key="2">two</element>\'\n+              \'</value>\')\n             )\n \n     def test_nested_dicts(self):\n@@ -398,14 +409,14 @@ def test_nested_dicts(self):\n                 ),\n             )\n         value = {}\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b(\'<value/>\'))\n         value = {1: {2: \'two\'}, 3: {4: \'four\', 5: \'five\'}, 6: {}}\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element key="1"><element key="2">two</element></element>\'\n-            \'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n-            \'<element key="6"/>\'\n-            \'</value>\'\n+            b(\'<value>\'\n+              \'<element key="1"><element key="2">two</element></element>\'\n+              \'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n+              \'<element key="6"/>\'\n+              \'</value>\')\n             )\n \n \n@@ -471,15 +482,15 @@ def _choice_with_term_titles_and_ns(self):\n     def test_choice_serialized(self):\n         field, expected = self._choice()\n         el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n+        self.assertEquals(etree.tostring(el), b(expected))\n         # now with an empty string term in vocab:\n         field, expected = self._choice_with_empty()\n         el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n+        self.assertEquals(etree.tostring(el), b(expected))\n         # now with terms that have titles:\n         field, expected = self._choice_with_term_titles()\n         el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n+        self.assertEquals(etree.tostring(el), b(expected))\n \n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n@@ -499,6 +510,23 @@ def _termvalues(vocab):\n             )\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+    def check_output(self, want, got, optionflags):\n+        if sys.version_info[0] > 2:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub(\n+                \'plone.supermodel.parser.SupermodelParseError\',\n+                \'SupermodelParseError\', got)\n+            got = re.sub(\n+                \'zope.interface.exceptions.Invalid\',\n+                \'Invalid\', got)\n+            got = re.sub(\n+                "ModuleNotFoundError: No module named \'plone.supermodel.tests.nonExistentFactory\'; \'plone.supermodel.tests\' is not a package",\n+                \'ImportError: No module named nonExistentFactory\', got)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     return unittest.TestSuite((\n         unittest.makeSuite(TestUtils),\n@@ -508,20 +536,24 @@ def test_suite():\n             \'schema.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS),\n+            optionflags=doctest.ELLIPSIS,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n             \'fields.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS),\n+            optionflags=doctest.ELLIPSIS,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n             \'schemaclass.rst\',\n             setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown),\n+            tearDown=zope.component.testing.tearDown,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n             \'directives.rst\',\n             setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown),\n+            tearDown=zope.component.testing.tearDown,\n+            checker=Py23DocChecker()),\n     ))\n \n \ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 246bde1..41c14c9 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n from lxml import etree\n+from plone.supermodel import PY3\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import I18N_NAMESPACE\n from plone.supermodel.interfaces import IToUnicode\n@@ -100,6 +101,10 @@ def elementToValue(field, element, default=_marker):\n     If not, the field will be adapted to this interface to obtain a converter.\n     """\n     value = default\n+    if PY3:\n+        text_type = str\n+    else:\n+        text_type = unicode\n \n     if IDict.providedBy(field):\n         key_converter = IFromUnicode(field.key_type)\n@@ -113,7 +118,7 @@ def elementToValue(field, element, default=_marker):\n             if key_text is None:\n                 k = None\n             else:\n-                k = key_converter.fromUnicode(six.text_type(key_text))\n+                k = key_converter.fromUnicode(text_type(key_text))\n \n             value[k] = elementToValue(field.value_type, child)\n             parseinfo.stack.pop()\n@@ -153,10 +158,10 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            value = converter.fromUnicode(six.text_type(text))\n+            value = converter.fromUnicode(text_type(text))\n \n         # handle i18n\n-        if isinstance(value, six.text_type) and parseinfo.i18n_domain is not None:\n+        if isinstance(value, text_type) and parseinfo.i18n_domain is not None:\n             translate_attr = ns(\'translate\', I18N_NAMESPACE)\n             domain_attr = ns(\'domain\', I18N_NAMESPACE)\n             msgid = element.attrib.get(translate_attr)\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-01-30T10:34:15+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.supermodel/commit/29815daa51b1c380c4db909bf78f37c53762c58b

more python3-porting

Files changed:
M plone/supermodel/configure.zcml
M plone/supermodel/converters.py
M plone/supermodel/fields.rst

b'diff --git a/plone/supermodel/configure.zcml b/plone/supermodel/configure.zcml\nindex cd8491c..adee0b7 100644\n--- a/plone/supermodel/configure.zcml\n+++ b/plone/supermodel/configure.zcml\n@@ -40,6 +40,7 @@\n \n     <adapter factory=".converters.ObjectFromUnicode" />\n \n+    <adapter factory=".converters.BytesToUnicode" />\n \n     <!-- Field handlers for all of zope.schema -->\n \ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex fa415bc..71505e7 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -5,6 +5,7 @@\n from zope.component import adapter\n from zope.dottedname.resolve import resolve\n from zope.interface import implementer\n+from zope.schema.interfaces import IBytes\n from zope.schema.interfaces import IDate\n from zope.schema.interfaces import IDatetime\n from zope.schema.interfaces import IField\n@@ -121,3 +122,19 @@ def fromUnicode(self, value):\n         obj = resolve(value)\n         self.context.validate(obj)\n         return obj\n+\n+\n+@implementer(IToUnicode)\n+@adapter(IBytes)\n+class BytesToUnicode(object):\n+\n+    def __init__(self, context):\n+        self.context = context\n+\n+    def toUnicode(self, value):\n+        if PY3:\n+            if isinstance(value, str):\n+                return value\n+            else:\n+                return value.decode(\'latin-1\')\n+        return unicode(value)\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex f62d8b4..35c788f 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -88,9 +88,9 @@ Bytes\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n+    >>> reciprocal.default.decode(\'latin-1\')\n     \'abc\'\n-    >>> reciprocal.missing_value\n+    >>> reciprocal.missing_value.decode(\'latin-1\')\n     \'m\'\n     >>> reciprocal.min_length\n     2\n@@ -134,9 +134,9 @@ BytesLine\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n+    >>> reciprocal.default.decode(\'latin-1\')\n     \'abc\'\n-    >>> reciprocal.missing_value\n+    >>> reciprocal.missing_value.decode(\'latin-1\')\n     \'m\'\n     >>> reciprocal.min_length\n     2\n@@ -1031,10 +1031,14 @@ Set\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    set([1, 2])\n-    >>> reciprocal.missing_value\n-    set([])\n+    >>> isinstance(reciprocal.default, set)\n+    True\n+    >>> [i for i in reciprocal.default]\n+    [1, 2]\n+    >>> isinstance(reciprocal.missing_value, set)\n+    True\n+    >>> len(reciprocal.missing_value)\n+    0\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1088,10 +1092,14 @@ FrozenSet\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    frozenset([1, 2])\n-    >>> reciprocal.missing_value\n-    frozenset([])\n+    >>> isinstance(reciprocal.default, frozenset)\n+    True\n+    >>> [i for i in reciprocal.default]\n+    [1, 2]\n+    >>> isinstance(reciprocal.missing_value, frozenset)\n+    True\n+    >>> len(reciprocal.missing_value)\n+    0\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1338,7 +1346,7 @@ sure it hasn\'t regressed.\n \n     >>> from plone.supermodel.interfaces import XML_NAMESPACE\n     >>> element.set(\'xmlns\', XML_NAMESPACE)\n-    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()\n+    >>> element = etree.parse(StringIO(prettyXML(element).decode(\'latin-1\'))).getroot()\n     >>> reciprocal = handler.read(element)\n     >>> [t.value for t in reciprocal.vocabulary]\n     [u\'a\', u\'b\', u\'c\']\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T10:23:32+02:00
Author: Daniel Havlik (dhavlik) <dh@gocept.com>
Commit: https://github.com/plone/plone.supermodel/commit/fcaa542c463d61fa95877c1ba175fa94cc022e16

be graceful about python3.5 / python3.6 differences

Files changed:
M plone/supermodel/tests.py

b'diff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 663f29c..1a5ec0e 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -522,7 +522,9 @@ def check_output(self, want, got, optionflags):\n                 \'zope.interface.exceptions.Invalid\',\n                 \'Invalid\', got)\n             got = re.sub(\n-                "ModuleNotFoundError: No module named \'plone.supermodel.tests.nonExistentFactory\'; \'plone.supermodel.tests\' is not a package",\n+                "(Import|ModuleNotFound)Error: No module named "\n+                "\'plone.supermodel.tests.nonExistentFactory\'; "\n+                "\'plone.supermodel.tests\' is not a package",\n                 \'ImportError: No module named nonExistentFactory\', got)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T10:23:40+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.supermodel/commit/411832fce22dca486cf2a79548966035b1dfa990

fix some more doctests with python3

Files changed:
M plone/supermodel/directives.rst

b'diff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst\nindex dc967a7..6579236 100644\n--- a/plone/supermodel/directives.rst\n+++ b/plone/supermodel/directives.rst\n@@ -25,7 +25,11 @@ First, load this package\'s configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from plone.supermodel import PY3\n+    >>> if PY3:\n+    ...     from io import StringIO\n+    ... else:\n+    ...     from StringIO import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -76,7 +80,7 @@ temporary directory created above.\n \n     >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n     >>> schema_file = open(schema_filename, "w")\n-    >>> schema_file.write(schema)\n+    >>> foo = schema_file.write(schema)\n     >>> schema_file.close()\n \n We can now define a schema, using the directives defined in this package:\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T10:23:44+02:00
Author: Daniel Havlik (dhavlik) <dh@gocept.com>
Commit: https://github.com/plone/plone.supermodel/commit/d2a183eb390bbfe842ece65e10b0c1709d1d5fe1

finish python3 compatibility

Files changed:
M CHANGES.rst
M plone/supermodel/fields.rst
M plone/supermodel/model.py
M plone/supermodel/schema.rst
M plone/supermodel/schemaclass.rst
M plone/supermodel/tests.py
M plone/supermodel/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 34e2530..abbba24 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,7 +10,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- Python 3 compatibility.\n+  [pbauer, dhavlik]\n \n Bug fixes:\n \ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex 35c788f..9353e26 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -89,9 +89,9 @@ Bytes\n     >>> reciprocal.readonly\n     True\n     >>> reciprocal.default.decode(\'latin-1\')\n-    \'abc\'\n+    u\'abc\'\n     >>> reciprocal.missing_value.decode(\'latin-1\')\n-    \'m\'\n+    u\'m\'\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -135,9 +135,9 @@ BytesLine\n     >>> reciprocal.readonly\n     True\n     >>> reciprocal.default.decode(\'latin-1\')\n-    \'abc\'\n+    u\'abc\'\n     >>> reciprocal.missing_value.decode(\'latin-1\')\n-    \'m\'\n+    u\'m\'\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1157,8 +1157,12 @@ Dict\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    {\'a\': 1, \'b\': 2}\n+    >>> reciprocal.default[\'a\']\n+    1\n+    >>> reciprocal.default[\'b\']\n+    2\n+    >>> sorted(reciprocal.default.keys())\n+    [\'a\', \'b\']\n     >>> reciprocal.missing_value\n     {}\n     >>> reciprocal.min_length\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 37fc620..7ff077e 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -111,7 +111,7 @@ def walk(schema):\n             for s in walk(child):\n                 yield s\n     schemas = set(walk(parent))\n-    for schema in schemas:\n+    for schema in sorted(schemas):\n         if hasattr(schema, \'_SchemaClass_finalize\'):\n             schema._SchemaClass_finalize()\n         elif isinstance(schema, InterfaceClass):\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex 90d756d..4cfdb76 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -64,7 +64,7 @@ We can parse this model using the loadString() function:\n This will load one schema, with the default name u"":\n \n     >>> list(model.schemata.keys())\n-    [\'\']\n+    [u\'\']\n \n We can inspect this schema and see that it contains zope.schema fields with\n attributes corresponding to the values set in XML.\ndiff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst\nindex a909c7e..2176e93 100644\n--- a/plone/supermodel/schemaclass.rst\n+++ b/plone/supermodel/schemaclass.rst\n@@ -3,21 +3,23 @@ plone.supermodel: SchemaClass\n =============================\n \n     >>> from plone.supermodel.model import Schema, SchemaClass\n-    >>> from plone.supermodel import interfaces\n-    >>> from zope.interface import Interface, implements\n+    >>> from plone.supermodel import interfaces, PY3\n+    >>> from zope.interface import Interface, implementer\n     >>> from zope.component import adapts, provideAdapter\n \n Schema plugins are registered as named adapters. They may optionally contain\n an order attribute, which defaults to 0.\n \n-    >>> class TestPlugin(object):\n+    >>> adapter_calls = []\n+    >>> @implementer(interfaces.ISchemaPlugin)\n+    ... class TestPlugin(object):\n     ...     adapts(interfaces.ISchema)\n-    ...     implements(interfaces.ISchemaPlugin)\n     ...     order = 1\n     ...     def __init__(self, schema):\n     ...         self.schema = schema\n     ...     def __call__(self):\n-    ...         print("%s: %r" % (self.__class__.__name__, self.schema))\n+    ...         adapter_calls.append(\n+    ...             (self.__class__.__name__,self.schema.__name__))\n     ...\n     >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")\n \n@@ -25,7 +27,8 @@ Schema plugins are executed at schema declaration.\n \n     >>> class IA(Schema):\n     ...     pass\n-    TestPlugin: <SchemaClass __builtin__.IA>\n+    >>> adapter_calls == [(\'TestPlugin\', \'IA\')]\n+    True\n \n Any class descending from Schema becomes an instance of SchemaClass and has any\n schema plugins called.\n@@ -34,36 +37,46 @@ Except, there is a known issue. Until\n https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this\n inheritance only works if the *first* base class is an instance of SchemaClass.\n So below I\'ve commented out the output that we hope for once that issue is\n-resolved.\n+resolved. \n+Somehow the issue got solved when using python 3, so we need to check python\n+version to get expected results here.\n \n     >>> class ISomeInterface(Interface):\n     ...     pass\n \n+    >>> adapter_calls = []\n     >>> class IB(ISomeInterface, IA):\n     ...     pass\n+    >>> adapter_calls == ([(\'TestPlugin\', \'IB\')] if PY3 else [])\n+    True\n \n-#    TestPlugin: <SchemaClass __builtin__.IB>\n-\n+    >>> adapter_calls = []\n     >>> class IC(IB):\n     ...     pass\n-\n-#    TestPlugin: <SchemaClass __builtin__.IC>\n+    >>> adapter_calls == ([(\'TestPlugin\', \'IC\')] if PY3 else [])\n+    True\n \n To support the registration of schema plugins in ZCML, plugins are\n additionally executed at zope.configuration time with a ZCML order of 1000. To\n simulate this we will define another adapter and call the configuration action\n directly.\n \n+    >>> adapter_calls = []\n     >>> class TestPlugin2(TestPlugin):\n     ...     order = 0\n \n     >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")\n     >>> from plone.supermodel.model import finalizeSchemas\n     >>> finalizeSchemas(IA)\n-    TestPlugin2: <SchemaClass __builtin__.IA>\n-    TestPlugin: <SchemaClass __builtin__.IA>\n-\n-#    TestPlugin2: <SchemaClass __builtin__.IB>\n-#    TestPlugin: <SchemaClass __builtin__.IB>\n-#    TestPlugin2: <SchemaClass __builtin__.IC>\n-#    TestPlugin: <SchemaClass __builtin__.IC>\n+    >>> adapter_calls == (\n+    ...     [(\'TestPlugin2\', \'IA\'),\n+    ...         (\'TestPlugin\', \'IA\'),\n+    ...         (\'TestPlugin2\', \'IB\'),\n+    ...         (\'TestPlugin\', \'IB\'),\n+    ...         (\'TestPlugin2\', \'IC\'),\n+    ...         (\'TestPlugin\', \'IC\'),\n+    ...        ] if PY3 else [\n+    ...         (\'TestPlugin2\', \'IA\'),\n+    ...        (\'TestPlugin\', \'IA\')])\n+    True\n+    >>> adapter_calls = []\n\\ No newline at end of file\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 1a5ec0e..4a24d5c 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -1,8 +1,8 @@\n # -*- coding: utf-8 -*-\n try:\n-    from io import StringIO, BytesIO\n-except ImportError:\n     from cStringIO import StringIO\n+except ImportError:\n+    from io import StringIO, BytesIO\n from lxml import etree\n from plone.supermodel import b, PY3\n from plone.supermodel import utils\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 41c14c9..b9a77df 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -194,7 +194,7 @@ def valueToElement(field, value, name=None, force=False):\n \n         if IDict.providedBy(field):\n             key_converter = IToUnicode(field.key_type)\n-            for k, v in value.items():\n+            for k, v in sorted(value.items()):\n                 list_element = valueToElement(field.value_type, v, \'element\', force)\n                 list_element.attrib[\'key\'] = key_converter.toUnicode(k)\n                 child.append(list_element)\ndiff --git a/setup.py b/setup.py\nindex 74f3ffa..c17c840 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -27,6 +27,8 @@ def read(*rnames):\n         "Framework :: Plone :: 5.1",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.5",\n+        "Programming Language :: Python :: 3.6",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T10:23:57+02:00
Author: Davi Lima (davilima6) <davilima6@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/378da3059eb12e5229b501296524de6e3d7364fe

WIP: More Python 2 / 3 adjustments

Files changed:
M plone/supermodel/__init__.py
M plone/supermodel/converters.py
M plone/supermodel/directives.py
M plone/supermodel/directives.rst
M plone/supermodel/exportimport.py
M plone/supermodel/fields.rst
M plone/supermodel/parser.py
M plone/supermodel/schema.rst
M plone/supermodel/schemaclass.rst
M plone/supermodel/tests.py
M plone/supermodel/utils.py

b'diff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex cd8f4ad..84d9438 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,34 +1,21 @@\n # -*- coding: utf-8 -*-\n-import sys\n-PY3 = sys.version_info[0] == 3\n-\n from plone.supermodel import model\n from plone.supermodel import parser\n from plone.supermodel import serializer\n from plone.supermodel import utils\n from plone.supermodel.interfaces import FILENAME_KEY\n from plone.supermodel.interfaces import IXMLToSchema\n+from six import BytesIO\n from six import StringIO\n from zope.interface import moduleProvides\n \n-if PY3:\n-    from io import BytesIO\n-else:\n-    from StringIO import StringIO\n+import six\n+\n \n # Cache models by absolute filename\n _model_cache = {}\n \n \n-def b(s):\n-    if PY3:\n-        if not isinstance(s, str):\n-            return s\n-        return bytes(s, encoding=\'latin-1\')\n-    else:\n-        return s\n-\n-\n def xmlSchema(filename, schema=u"", policy=u"", _frame=2):\n     _model = loadFile(filename, policy=policy, _frame=_frame + 1)\n     return _model.schemata[schema]\n@@ -46,10 +33,9 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n \n \n def loadString(model, policy=u""):\n-    if PY3:\n-        source = BytesIO(b(model))\n-    else:\n-        source = StringIO(model)\n+    source = StringIO(model) if six.PY2 \\\n+        else BytesIO(six.binary_type(model, encoding=\'latin-1\'))\n+    # source = StringIO(model) if six.PY2 else BytesIO(model)\n     return parser.parse(source, policy=policy)\n \n \ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex 71505e7..8109f88 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -1,5 +1,4 @@\n # -*- coding: utf-8 -*-\n-from plone.supermodel import PY3\n from plone.supermodel.interfaces import IToUnicode\n from plone.supermodel.utils import fieldTypecast\n from zope.component import adapter\n@@ -39,9 +38,8 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if PY3:\n-            return str(value)\n-        return unicode(value)\n+\n+        return six.text_type(value)\n \n \n # Date/time fields\n@@ -101,9 +99,7 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if PY3:\n-            return value.__identifier__\n-        return unicode(value.__identifier__)\n+        return six.text_type(value.__identifier__)\n \n \n # Object fields - we can read, but not write, as there is no way to know\n@@ -132,9 +128,4 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if PY3:\n-            if isinstance(value, str):\n-                return value\n-            else:\n-                return value.decode(\'latin-1\')\n-        return unicode(value)\n+        return six.text_type(value)\ndiff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py\nindex 3591b46..77cda7a 100644\n--- a/plone/supermodel/directives.py\n+++ b/plone/supermodel/directives.py\n@@ -81,8 +81,8 @@ def check(self):\n         for fieldName in self.fieldNames():\n             if fieldName not in schema:\n                 raise ValueError(\n-                    u"The directive {0} applied to interface {1} "\n-                    u"refers to unknown field name {2}".format(\n+                    u\'The directive {0} applied to interface {1} \'\n+                    u\'refers to unknown field name {2}\'.format(\n                         self.key,\n                         schema.__identifier__,\n                         fieldName\n@@ -130,10 +130,10 @@ class load(Directive):\n     """\n \n     def store(self, tags, value):\n-        tags[FILENAME_KEY] = value["filename"]\n-        tags[SCHEMA_NAME_KEY] = value["schema"]\n+        tags[FILENAME_KEY] = value[\'filename\']\n+        tags[SCHEMA_NAME_KEY] = value[\'schema\']\n \n-    def factory(self, filename, schema=u""):\n+    def factory(self, filename, schema=u\'\'):\n         return dict(filename=filename, schema=schema)\n \n \n@@ -151,7 +151,7 @@ def __call__(self):\n         filename = interface.queryTaggedValue(FILENAME_KEY, None)\n         if filename is None:\n             return\n-        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u"")\n+        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u\'\')\n \n         moduleName = interface.__module__\n         module = sys.modules.get(moduleName, None)\n@@ -161,7 +161,7 @@ def __call__(self):\n         if hasattr(module, \'__path__\'):\n             directory = module.__path__[0]\n         else:\n-            while "." in moduleName:\n+            while \'.\' in moduleName:\n                 moduleName, _ = moduleName.rsplit(\'.\', 1)\n                 module = sys.modules.get(moduleName, None)\n                 if hasattr(module, \'__path__\'):\n@@ -176,8 +176,8 @@ def __call__(self):\n         model = loadFile(filename)\n         if schema not in model.schemata:\n             raise ValueError(\n-                u"Schema \'{0}\' specified for interface {1} does not exist "\n-                "in {2}.".format(\n+                \'Schema "{0}" specified for interface {1} does not exist \'\n+                \'in {2}.\'.format(\n                     schema,\n                     interface.__identifier__,\n                     filename,\ndiff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst\nindex 6579236..c173379 100644\n--- a/plone/supermodel/directives.rst\n+++ b/plone/supermodel/directives.rst\n@@ -13,7 +13,7 @@ Setup\n \n First, load this package\'s configuration:\n \n-    >>> configuration = """\\\n+    >>> configuration = u"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -25,11 +25,7 @@ First, load this package\'s configuration:\n     ... </configure>\n     ... """\n \n-    >>> from plone.supermodel import PY3\n-    >>> if PY3:\n-    ...     from io import StringIO\n-    ... else:\n-    ...     from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -112,7 +108,7 @@ We can also use a different, named schema:\n     >>> class ITestMetadata(model.Schema):\n     ...     """Test metadata schema, built from XML\n     ...     """\n-    ...     model.load(schema_filename, schema=u"metadata")\n+    ...     model.load(schema_filename, schema=u\'metadata\')\n \n     >>> getFieldNamesInOrder(ITestMetadata)\n     [\'created\', \'creator\']\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex d24521c..63be331 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -1,6 +1,5 @@\n # -*- coding: utf-8 -*-\n from lxml import etree\n-from plone.supermodel import b, PY3\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IFieldExportImportHandler\n@@ -24,14 +23,9 @@\n \n try:\n     from collections import OrderedDict\n-except:\n+except ImportError:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n-if PY3:\n-    stringish_types = (bytes, str)\n-else:\n-    stringish_types = (str, unicode)\n-\n \n class OrderedDictField(zope.schema.Dict):\n     _type = OrderedDict\n@@ -403,9 +397,11 @@ def write(self, field, name, type, elementName=\'field\'):\n         ):\n             value = []\n             for term in field.vocabulary:\n+                term_token = six.binary_type(term.token) if six.PY2 \\\n+                    else six.binary_type(term.token, encoding=\'unicode_escape\')\n                 if (\n-                    not isinstance(term.value, stringish_types) or\n-                    b(term.token) != term.value.encode(\'unicode_escape\')\n+                    not isinstance(term.value, six.string_types) or\n+                    term_token != term.value.encode(\'unicode_escape\')\n                 ):\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex 9353e26..9e55321 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -18,7 +18,7 @@ limitations:\n \n First, let\'s wire up the package.\n \n-    >>> configuration = """\\\n+    >>> configuration = u"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.behavior.tests">\n@@ -30,35 +30,30 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from plone.supermodel import PY3\n-    >>> if PY3:\n-    ...     from io import StringIO\n-    ... else:\n-    ...     from StringIO import StringIO\n-    >>> from plone.supermodel import b\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n Then, let\'s test each field in turn.\n \n-    >>> from zope.component import getUtility\n-    >>> from zope import schema\n-\n+    >>> from lxml import etree\n     >>> from plone.supermodel.interfaces import IFieldExportImportHandler\n     >>> from plone.supermodel.interfaces import IFieldNameExtractor\n     >>> from plone.supermodel.utils import prettyXML\n+    >>> from zope import schema\n+    >>> from zope.component import getUtility\n \n     >>> import datetime\n     >>> import plone.supermodel.tests\n+    >>> import six\n \n-    >>> from lxml import etree\n \n Bytes\n -----\n \n-    >>> field = schema.Bytes(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=b(\'abc\'), missing_value=\'m\',\n+    >>> field = schema.Bytes(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n+    ...     default=b\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -102,9 +97,9 @@ Bytes\n BytesLine\n ---------\n \n-    >>> field = schema.BytesLine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=b(\'abc\'), missing_value=\'m\',\n+    >>> field = schema.BytesLine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n+    ...     default=b\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -148,8 +143,8 @@ BytesLine\n ASCII\n -----\n \n-    >>> field = schema.ASCII(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.ASCII(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -194,8 +189,8 @@ ASCII\n ASCIILine\n ---------\n \n-    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.ASCIILine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -240,8 +235,8 @@ ASCIILine\n Text\n ----\n \n-    >>> field = schema.Text(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Text(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -286,8 +281,8 @@ Text\n TextLine\n --------\n \n-    >>> field = schema.TextLine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.TextLine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -332,8 +327,8 @@ TextLine\n SourceText\n ----------\n \n-    >>> field = schema.SourceText(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.SourceText(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -378,8 +373,8 @@ SourceText\n URI\n ---\n \n-    >>> field = schema.URI(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.URI(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'http://plone.org\', missing_value=\'m\',\n     ...     min_length=2, max_length=100)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -424,8 +419,8 @@ URI\n Id\n --\n \n-    >>> field = schema.Id(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Id(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a.b.c\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -470,8 +465,8 @@ Id\n DottedName\n -----------\n \n-    >>> field = schema.DottedName(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.DottedName(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a.b.c\', missing_value=\'m\',\n     ...     min_length=2, max_length=10, min_dots=2, max_dots=4)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -522,8 +517,8 @@ DottedName\n Password\n --------\n \n-    >>> field = schema.Password(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Password(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -568,8 +563,8 @@ Password\n Bool\n ----\n \n-    >>> field = schema.Bool(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Bool(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=False, missing_value=True)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -607,8 +602,8 @@ Bool\n Int\n ---\n \n-    >>> field = schema.Int(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Int(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=12, missing_value=-1,\n     ...     min=1, max=99)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -653,8 +648,8 @@ Int\n Float\n -----\n \n-    >>> field = schema.Float(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Float(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=12.1, missing_value=-1.0,\n     ...     min=1.123, max=99.5)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -700,8 +695,8 @@ Decimal\n -------\n \n     >>> import decimal\n-    >>> field = schema.Decimal(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Decimal(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),\n     ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -746,8 +741,8 @@ Decimal\n Date\n ----\n \n-    >>> field = schema.Date(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Date(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),\n     ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -792,8 +787,8 @@ Date\n Datetime\n ---------\n \n-    >>> field = schema.Datetime(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Datetime(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),\n     ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -838,8 +833,8 @@ Datetime\n InterfaceField\n ---------------\n \n-    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.InterfaceField(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=plone.supermodel.tests.IDummy,\n     ...     missing_value=plone.supermodel.tests.IDummy)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -878,8 +873,8 @@ InterfaceField\n Tuple\n -----\n \n-    >>> field = schema.Tuple(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Tuple(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=(1,2), missing_value=(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n@@ -935,8 +930,8 @@ Tuple\n List\n ----\n \n-    >>> field = schema.List(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.List(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=[1,2], missing_value=[],\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n@@ -992,8 +987,8 @@ List\n Set\n ---\n \n-    >>> field = schema.Set(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Set(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=set((1,2)), missing_value=set(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n@@ -1033,7 +1028,7 @@ Set\n     True\n     >>> isinstance(reciprocal.default, set)\n     True\n-    >>> [i for i in reciprocal.default]\n+    >>> list(reciprocal.default)\n     [1, 2]\n     >>> isinstance(reciprocal.missing_value, set)\n     True\n@@ -1053,8 +1048,8 @@ Set\n FrozenSet\n ---------\n \n-    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.FrozenSet(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=frozenset((1,2)), missing_value=frozenset(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n@@ -1094,7 +1089,7 @@ FrozenSet\n     True\n     >>> isinstance(reciprocal.default, frozenset)\n     True\n-    >>> [i for i in reciprocal.default]\n+    >>> list(reciprocal.default)\n     [1, 2]\n     >>> isinstance(reciprocal.missing_value, frozenset)\n     True\n@@ -1114,12 +1109,12 @@ FrozenSet\n Dict\n ----\n \n-    >>> field = schema.Dict(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Dict(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default={\'a\':1, \'b\':2}, missing_value={},\n     ...     min_length=2, max_length=10,\n-    ...     key_type=schema.ASCIILine(title=u"Key"),\n-    ...     value_type=schema.Int(title=u"Val"))\n+    ...     key_type=schema.ASCIILine(title=u\'Key\'),\n+    ...     value_type=schema.Int(title=u\'Val\'))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n@@ -1189,8 +1184,8 @@ fields will be omitted, as there is no way to write these reliably.\n     >>> dummy1 = plone.supermodel.tests.Dummy()\n     >>> dummy2 = plone.supermodel.tests.Dummy()\n \n-    >>> field = schema.Object(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Object(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=dummy1, missing_value=dummy2,\n     ...     schema=plone.supermodel.tests.IDummy)\n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -1254,8 +1249,8 @@ dotted name.\n \n These can be both exported and imported.\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', vocabulary=u\'dummy.vocab\')\n \n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -1301,8 +1296,8 @@ These can be both exported and imported.\n These can be both imported and exported, but note that the value is always\n a unicode string when importing.\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', values=[\'a\', \'b\', \'c\'])\n \n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -1363,8 +1358,8 @@ tokens are the utf8-encoded values).\n     ...     SimpleTerm(token=\'a\', value=u\'a\', title=u\'a\'),\n     ...     SimpleTerm(token=r\'\\xe7\', value=u\'\\xe7\', title=u\'\\xe7\'), # c with cedilla\n     ...     ])\n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', vocabulary=vocab)\n \n     >>> fieldType = IFieldNameExtractor(field)()\n@@ -1401,8 +1396,8 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n     ...     SimpleTerm(value=u\'b\', title=u\'B\'),\n     ...     ])\n     >>> field = schema.Choice(\n-    ...     __name__="dummy",\n-    ...     title=u"Test",\n+    ...     __name__=\'dummy\',\n+    ...     title=u\'Test\',\n     ...     vocabulary=vocab,\n     ...     )\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1420,8 +1415,8 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n \n We cannot export choice fields with a source or context source binder:\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1430,8 +1425,8 @@ We cannot export choice fields with a source or context source binder:\n     ...\n     NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     source=plone.supermodel.tests.dummy_vocabulary_instance)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1440,8 +1435,8 @@ We cannot export choice fields with a source or context source binder:\n     ...\n     NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     source=plone.supermodel.tests.dummy_binder)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 9828f15..bc3d022 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -1,6 +1,5 @@\n # -*- coding: utf-8 -*-\n from lxml import etree\n-from plone.supermodel import PY3\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import DEFAULT_ORDER\n from plone.supermodel.interfaces import FIELDSETS_KEY\n@@ -27,15 +26,9 @@\n import sys\n import traceback\n \n-if PY3:\n-    string_types = str,\n-else:\n-    string_types = basestring,\n \n \n # Exception\n-\n-\n class SupermodelParseError(Exception):\n \n     def __init__(self, orig_exc, fname, element, tb):\n@@ -73,7 +66,7 @@ def name(self, schemaName, tree):\n # Algorithm\n def parse(source, policy=u""):\n     fname = None\n-    if isinstance(source, string_types):\n+    if isinstance(source, six.string_types):\n         fname = source\n \n     try:\n@@ -83,7 +76,8 @@ def parse(source, policy=u""):\n         # the filename and line number of the element that caused the problem.\n         # Keep the original traceback so the developer can debug where the\n         # problem happened.\n-        raise SupermodelParseError(e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n+        raise SupermodelParseError(\n+            e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n \n \n def _parse(source, policy):\n@@ -114,7 +108,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                 \'<field /> element\'\n             )\n \n-        handler = handlers.get(fieldType, None)\n+        handler = handlers.get(fieldType)\n         if handler is None:\n             handler = handlers[fieldType] = queryUtility(\n                 IFieldExportImportHandler,\n@@ -130,7 +124,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         # Preserve order from base interfaces if this field is an override\n         # of a field with the same name in a base interface\n-        base_field = baseFields.get(fieldName, None)\n+        base_field = baseFields.get(fieldName)\n         if base_field is not None:\n             field.order = base_field.order\n \n@@ -184,6 +178,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     fieldElements,\n                     baseFields\n                 )\n+\n             elif subelement.tag == ns(\'fieldset\'):\n \n                 fieldset_name = subelement.get(\'name\')\n@@ -194,14 +189,14 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                         )\n                     )\n \n-                fieldset = fieldsets_by_name.get(fieldset_name, None)\n+                fieldset = fieldsets_by_name.get(fieldset_name)\n                 if fieldset is None:\n                     fieldset_label = subelement.get(\'label\')\n                     fieldset_description = subelement.get(\'description\')\n                     fieldset_order = subelement.get(\'order\')\n                     if fieldset_order is None:\n                         fieldset_order = DEFAULT_ORDER\n-                    elif isinstance(fieldset_order, string_types):\n+                    elif isinstance(fieldset_order, six.string_types):\n                         fieldset_order = int(fieldset_order)\n                     fieldset = fieldsets_by_name[fieldset_name] = Fieldset(\n                         fieldset_name,\n@@ -223,6 +218,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     if parsed_fieldName:\n                         fieldset.fields.append(parsed_fieldName)\n                     parseinfo.stack.pop()\n+\n             elif subelement.tag == ns(\'invariant\'):\n                 dotted = subelement.text\n                 invariant = resolve(dotted)\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex 4cfdb76..115db85 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -14,7 +14,7 @@ Before we can begin, we must register the field handlers that know how to\n import and export fields from/to XML. These are registered as named utilities,\n and can be loaded from the configure.zcml file of plone.supermodel.\n \n-    >>> configuration = """\\\n+    >>> configuration = u"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -26,12 +26,7 @@ and can be loaded from the configure.zcml file of plone.supermodel.\n     ... </configure>\n     ... """\n \n-    >>> from plone.supermodel import PY3\n-    >>> if PY3:\n-    ...     from io import StringIO\n-    ... else:\n-    ...     from StringIO import StringIO\n-\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -69,7 +64,7 @@ This will load one schema, with the default name u"":\n We can inspect this schema and see that it contains zope.schema fields with\n attributes corresponding to the values set in XML.\n \n-    >>> schema = model.schema # shortcut to model.schemata[u""]\n+    >>> schema = model.schema  # shortcut to model.schemata[u""]\n \n     >>> from zope.schema import getFieldNamesInOrder\n     >>> getFieldNamesInOrder(schema)\n@@ -169,10 +164,9 @@ directory.\n \n     >>> import tempfile, os.path, shutil\n     >>> tmpdir = tempfile.mkdtemp()\n-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n-    >>> schema_file = open(schema_filename, "w")\n-    >>> foo = schema_file.write(schema)\n-    >>> schema_file.close()\n+    >>> schema_filename = os.path.join(tmpdir, \'schema.xml\')\n+    >>> with open(schema_filename, \'w\') as fd:\n+    ...     fd.write(schema)\n \n We can define interfaces from this using a helper function:\n \n@@ -190,7 +184,7 @@ After being loaded, the interface should have the fields of the default\n \n We can also use a different, named schema:\n \n-    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")\n+    >>> ITestMetadata = xmlSchema(schema_filename, schema=u\'metadata\')\n     >>> getFieldNamesInOrder(ITestMetadata)\n     [\'created\', \'creator\']\n \n@@ -212,7 +206,7 @@ of just a single schema using serializeSchema():\n       </schema>\n     </model>\n \n-    >>> print(serializeSchema(ITestMetadata, name=u"metadata").decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestMetadata, name=u\'metadata\').decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema name="metadata">\n         <field name="created" type="zope.schema.Datetime">\n@@ -243,9 +237,9 @@ resolver needs to have a proper module path. The interface looks like this\n though:\n \n     class IBase(Interface):\n-        title = zope.schema.TextLine(title=u"Title")\n-        description = zope.schema.TextLine(title=u"Description")\n-        name = zope.schema.TextLine(title=u"Name")\n+        title = zope.schema.TextLine(title=u\'Title\')\n+        description = zope.schema.TextLine(title=u\'Description\')\n+        name = zope.schema.TextLine(title=u\'Name\')\n \n In real life, you\'d more likely have a dotted name like\n my.package.interfaces.IBase, of course.\n@@ -270,7 +264,7 @@ Then, let\'s define a schema that is based on this interface.\n Here, notice the use of the \'based-on\' attribute, which specifies a dotted\n name to the base interface. It is possible to specify multiple interfaces\n as a space-separated list. However, if you find that you need this, you\n-may want to ask yourself why. :) Inside the schema proper, we override the\n+may want to ask yourself why. :) Inside the proper schema, we override the\n \'description\' field and add a new field, \'age\'.\n \n When we load this model, we should find that the __bases__ list of the\n@@ -402,11 +396,10 @@ default schema above is unrelated to the one in the metadata schema.\n     >>> model.schema.getTaggedValue(FIELDSETS_KEY)\n     [<Fieldset \'dates\' order 1 of publication_date, expiry_date, notification_date>]\n \n-    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)\n+    >>> model.schemata[u\'metadata\'].getTaggedValue(FIELDSETS_KEY)\n     [<Fieldset \'standard\' order 9999 of creator>, <Fieldset \'dates\' order 9999 of created>, <Fieldset \'author\' order 9999 of >]\n \n-When we serialise a schema with fieldsets, fields will be grouped by\n-fieldset.\n+When we serialise a schema with fieldsets, fields will be grouped by fieldset.\n \n     >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n@@ -477,8 +470,8 @@ a dotted name for the invariant function.\n     >>> model.schema.getTaggedValue(\'invariants\')\n     [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]\n \n-When invariants are checked for our model.schema, we\'ll see our invariant\n-in action.\n+When invariants are checked for our model.schema, we\'ll see our invariant in\n+action.\n \n     >>> model.schema.validateInvariants(object())\n     Traceback (most recent call last):\n@@ -531,9 +524,9 @@ or we won\'t accept them.\n Internationalization\n --------------------\n \n-Translation domains and message ids can be specified for text\n-that is interpreted as unicode. This will result in deserialization\n-as a zope.i18nmessageid message id rather than a basic Unicode string::\n+Translation domains and message ids can be specified for text that is\n+interpreted as unicode. This will result in deserialization as a\n+zope.i18nmessageid message id rather than a basic Unicode string::\n \n     >>> schema = """\\\n     ... <?xml version="1.0" encoding="UTF-8"?>\n@@ -624,8 +617,8 @@ Metadata handlers should be able to reciprocally read and write metadata.\n     >>> @implementer(ISchemaMetadataHandler)\n     ... class FormLayoutMetadata(object):\n     ...\n-    ...     namespace = "http://namespaces.acme.com/ui"\n-    ...     prefix = "ui"\n+    ...     namespace = \'http://namespaces.acme.com/ui\'\n+    ...     prefix = \'ui\'\n     ...\n     ...     def read(self, schemaNode, schema):\n     ...         layout = schemaNode.get(ns(\'layout\', self.namespace))\n@@ -643,8 +636,8 @@ Metadata handlers should be able to reciprocally read and write metadata.\n     >>> @implementer(IFieldMetadataHandler)\n     ... class FieldWidgetMetadata(object):\n     ...\n-    ...     namespace = "http://namespaces.acme.com/ui"\n-    ...     prefix = "ui"\n+    ...     namespace = \'http://namespaces.acme.com/ui\'\n+    ...     prefix = \'ui\'\n     ...\n     ...     def read(self, fieldNode, schema, field):\n     ...         name = field.__name__\ndiff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst\nindex 2176e93..f718d75 100644\n--- a/plone/supermodel/schemaclass.rst\n+++ b/plone/supermodel/schemaclass.rst\n@@ -3,7 +3,7 @@ plone.supermodel: SchemaClass\n =============================\n \n     >>> from plone.supermodel.model import Schema, SchemaClass\n-    >>> from plone.supermodel import interfaces, PY3\n+    >>> from plone.supermodel import interfaces\n     >>> from zope.interface import Interface, implementer\n     >>> from zope.component import adapts, provideAdapter\n \n@@ -37,23 +37,24 @@ Except, there is a known issue. Until\n https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this\n inheritance only works if the *first* base class is an instance of SchemaClass.\n So below I\'ve commented out the output that we hope for once that issue is\n-resolved. \n+resolved.\n Somehow the issue got solved when using python 3, so we need to check python\n version to get expected results here.\n \n+    >>> import six\n     >>> class ISomeInterface(Interface):\n     ...     pass\n \n     >>> adapter_calls = []\n     >>> class IB(ISomeInterface, IA):\n     ...     pass\n-    >>> adapter_calls == ([(\'TestPlugin\', \'IB\')] if PY3 else [])\n+    >>> adapter_calls == ([] if six.PY2 else [(\'TestPlugin\', \'IB\')])\n     True\n \n     >>> adapter_calls = []\n     >>> class IC(IB):\n     ...     pass\n-    >>> adapter_calls == ([(\'TestPlugin\', \'IC\')] if PY3 else [])\n+    >>> adapter_calls == ([] if six.PY2 else [(\'TestPlugin\', \'IC\')])\n     True\n \n To support the registration of schema plugins in ZCML, plugins are\n@@ -71,12 +72,11 @@ directly.\n     >>> adapter_calls == (\n     ...     [(\'TestPlugin2\', \'IA\'),\n     ...         (\'TestPlugin\', \'IA\'),\n+    ...        ] if six.PY2 else [\n+    ...         (\'TestPlugin\', \'IA\'),\n     ...         (\'TestPlugin2\', \'IB\'),\n     ...         (\'TestPlugin\', \'IB\'),\n     ...         (\'TestPlugin2\', \'IC\'),\n-    ...         (\'TestPlugin\', \'IC\'),\n-    ...        ] if PY3 else [\n-    ...         (\'TestPlugin2\', \'IA\'),\n-    ...        (\'TestPlugin\', \'IA\')])\n+    ...        (\'TestPlugin\', \'IC\')])\n     True\n-    >>> adapter_calls = []\n\\ No newline at end of file\n+    >>> adapter_calls = []\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 4a24d5c..2af4a07 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -1,15 +1,11 @@\n # -*- coding: utf-8 -*-\n-try:\n-    from cStringIO import StringIO\n-except ImportError:\n-    from io import StringIO, BytesIO\n from lxml import etree\n-from plone.supermodel import b, PY3\n from plone.supermodel import utils\n from plone.supermodel.exportimport import ChoiceHandler\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IInvariant\n-from six.moves import cStringIO as StringIO\n+from six import BytesIO\n+from six import StringIO\n from zope import schema\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -25,13 +21,14 @@\n import doctest\n import unittest\n import re\n+import six\n import sys\n import zope.component.testing\n \n \n def configure():\n     zope.component.testing.setUp()\n-    configuration = """\\\n+    configuration = u"""\\\n     <configure\n          xmlns="http://namespaces.zope.org/zope"\n          i18n_domain="plone.supermodel.tests">\n@@ -353,71 +350,68 @@ def setUp(self):\n     tearDown = zope.component.testing.tearDown\n \n     def _assertSerialized(self, field, value, expected):\n-        element = utils.valueToElement(field, value, b(\'value\'))\n-        if PY3:\n-            sio = BytesIO()\n-        else:\n-            sio = StringIO()\n+        element = utils.valueToElement(field, value, b\'value\')\n+        sio = StringIO() if six.PY2 else BytesIO()\n         etree.ElementTree(element).write(sio)\n         self.assertEqual(sio.getvalue(), expected)\n         unserialized = utils.elementToValue(field, element)\n-        self.assertEqual(value, b(unserialized))\n+        self.assertEqual(value, unserialized)\n \n     def test_lists(self):\n         field = schema.List(value_type=schema.Int())\n         value = []\n-        self._assertSerialized(field, value, b(\'<value/>\'))\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = [1, 2]\n         self._assertSerialized(\n             field, value,\n-            b(\'<value>\'\n-              \'<element>1</element>\'\n-              \'<element>2</element>\'\n-              \'</value>\')\n-            )\n+            b\'<value>\'\n+            b\'<element>1</element>\'\n+            b\'<element>2</element>\'\n+            b\'</value>\'\n+        )\n \n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n-        self._assertSerialized(field, value, b(\'<value/>\'))\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = [[1], [1, 2], []]\n         self._assertSerialized(field, value,\n-            b(\'<value>\'\n-              \'<element><element>1</element></element>\'\n-              \'<element><element>1</element><element>2</element></element>\'\n-              \'<element/>\'\n-              \'</value>\')\n-            )\n+            b\'<value>\'\n+            b\'<element><element>1</element></element>\'\n+            b\'<element><element>1</element><element>2</element></element>\'\n+            b\'<element/>\'\n+            b\'</value>\'\n+        )\n \n     def test_dicts(self):\n         field = schema.Dict(key_type=schema.Int(), value_type=schema.TextLine())\n         value = {}\n-        self._assertSerialized(field, value, b(\'<value/>\'))\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = {1: \'one\', 2: \'two\'}\n         self._assertSerialized(field, value,\n-            b(\'<value>\'\n-              \'<element key="1">one</element>\'\n-              \'<element key="2">two</element>\'\n-              \'</value>\')\n-            )\n+            b\'<value>\'\n+            b\'<element key="1">one</element>\'\n+            b\'<element key="2">two</element>\'\n+            b\'</value>\'\n+        )\n \n     def test_nested_dicts(self):\n         field = schema.Dict(key_type=schema.Int(),\n             value_type=schema.Dict(\n                 key_type=schema.Int(),\n                 value_type=schema.TextLine(),\n-                ),\n-            )\n+            ),\n+        )\n         value = {}\n-        self._assertSerialized(field, value, b(\'<value/>\'))\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = {1: {2: \'two\'}, 3: {4: \'four\', 5: \'five\'}, 6: {}}\n         self._assertSerialized(field, value,\n-            b(\'<value>\'\n-              \'<element key="1"><element key="2">two</element></element>\'\n-              \'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n-              \'<element key="6"/>\'\n-              \'</value>\')\n-            )\n+            b\'<value>\'\n+            b\'<element key="1"><element key="2">two</element></element>\'\n+            b\'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n+            b\'<element key="6"/>\'\n+            b\'</value>\'\n+        )\n \n \n class TestChoiceHandling(unittest.TestCase):\n@@ -480,17 +474,19 @@ def _choice_with_term_titles_and_ns(self):\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def test_choice_serialized(self):\n-        field, expected = self._choice()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), b(expected))\n-        # now with an empty string term in vocab:\n-        field, expected = self._choice_with_empty()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), b(expected))\n-        # now with terms that have titles:\n-        field, expected = self._choice_with_term_titles()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), b(expected))\n+        """ Tests a regular choice, one with empty string term in vocab,\n+        and another with terms that have titles\n+        """\n+        choice = self._choice()\n+        choice_with_empty = self._choice_with_empty()\n+        choice_with_term_titles = self._choice_with_term_titles()\n+        for case in (choice, choice_with_empty, choice_with_term_titles):\n+            field, expected = case\n+            expected = six.binary_type(expected) if six.PY2 \\\n+                else six.binary_type(expected, encoding=\'latin-1\')\n+            el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n+            self.assertEquals(etree.tostring(el), expected)\n+\n \n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n@@ -512,7 +508,7 @@ def _termvalues(vocab):\n \n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        if sys.version_info[0] > 2:\n+        if not six.PY2:\n             want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n             want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n             got = re.sub(\n@@ -529,32 +525,40 @@ def check_output(self, want, got, optionflags):\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n+optionflags = doctest.ELLIPSIS | \\\n+    doctest.REPORT_UDIFF | \\\n+    doctest.NORMALIZE_WHITESPACE | \\\n+    doctest.REPORT_ONLY_FIRST_FAILURE\n+\n+\n def test_suite():\n     return unittest.TestSuite((\n         unittest.makeSuite(TestUtils),\n         unittest.makeSuite(TestValueToElement),\n         unittest.makeSuite(TestChoiceHandling),\n         doctest.DocFileSuite(\n-            \'schema.rst\',\n+            \'fields.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS,\n+            optionflags=optionflags,\n             checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'fields.rst\',\n+            \'directives.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS,\n+            optionflags=optionflags,\n             checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'schemaclass.rst\',\n+            \'schema.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n+            optionflags=optionflags,\n             checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'directives.rst\',\n+            \'schemaclass.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n+            optionflags=optionflags,\n             checker=Py23DocChecker()),\n     ))\n \ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex b9a77df..9b9cc1a 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -1,6 +1,5 @@\n # -*- coding: utf-8 -*-\n from lxml import etree\n-from plone.supermodel import PY3\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import I18N_NAMESPACE\n from plone.supermodel.interfaces import IToUnicode\n@@ -14,7 +13,6 @@\n from zope.schema.interfaces import IDict\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n-from zope.schema.interfaces import IVocabularyFactory\n \n import os.path\n import re\n@@ -24,7 +22,7 @@\n \n try:\n     from collections import OrderedDict\n-except:\n+except ImportError:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n \n@@ -36,7 +34,7 @@ def ns(name, prefix=XML_NAMESPACE):\n     """Return the element or attribute name with the given prefix\n     """\n \n-    return u"{%s}%s" % (prefix, name)\n+    return u\'{%s}%s\' % (prefix, name)\n \n \n def noNS(name):\n@@ -47,15 +45,16 @@ def noNS(name):\n \n def indent(node, level=0):\n \n-    node_indent = level * "  "\n-    child_indent = (level + 1) * "  "\n+    INDENT_SIZE = 2\n+    node_indent = level * (\' \' * INDENT_SIZE)\n+    child_indent = (level + 1) * (\' \' * INDENT_SIZE)\n \n     # node has childen\n     if len(node):\n \n         # add indent before first child node\n         if not node.text or not node.text.strip():\n-            node.text = "\\n" + child_indent\n+            node.text = \'\\n\' + child_indent\n \n         # let each child indent itself\n         last_idx = len(node) - 1\n@@ -65,11 +64,11 @@ def indent(node, level=0):\n             # add a tail for the next child node...\n             if idx != last_idx:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = "\\n" + child_indent\n+                    child.tail = \'\\n\' + child_indent\n             # ... or for the closing element of this node\n             else:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = "\\n" + node_indent\n+                    child.tail = \'\\n\' + node_indent\n \n \n def prettyXML(tree):\n@@ -101,11 +100,6 @@ def elementToValue(field, element, default=_marker):\n     If not, the field will be adapted to this interface to obtain a converter.\n     """\n     value = default\n-    if PY3:\n-        text_type = str\n-    else:\n-        text_type = unicode\n-\n     if IDict.providedBy(field):\n         key_converter = IFromUnicode(field.key_type)\n         value = OrderedDict()\n@@ -114,11 +108,11 @@ def elementToValue(field, element, default=_marker):\n                 continue\n             parseinfo.stack.append(child)\n \n-            key_text = child.attrib.get(\'key\', None)\n+            key_text = child.attrib.get(\'key\')\n             if key_text is None:\n                 k = None\n             else:\n-                k = key_converter.fromUnicode(text_type(key_text))\n+                k = key_converter.fromUnicode(six.text_type(key_text))\n \n             value[k] = elementToValue(field.value_type, child)\n             parseinfo.stack.pop()\n@@ -158,10 +152,11 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            value = converter.fromUnicode(text_type(text))\n+            value = converter.fromUnicode(six.text_type(text))\n \n         # handle i18n\n-        if isinstance(value, text_type) and parseinfo.i18n_domain is not None:\n+        if isinstance(value, six.string_types) and \\\n+                parseinfo.i18n_domain is not None:\n             translate_attr = ns(\'translate\', I18N_NAMESPACE)\n             domain_attr = ns(\'domain\', I18N_NAMESPACE)\n             msgid = element.attrib.get(translate_attr)\n@@ -195,13 +190,15 @@ def valueToElement(field, value, name=None, force=False):\n         if IDict.providedBy(field):\n             key_converter = IToUnicode(field.key_type)\n             for k, v in sorted(value.items()):\n-                list_element = valueToElement(field.value_type, v, \'element\', force)\n+                list_element = valueToElement(\n+                    field.value_type, v, \'element\', force)\n                 list_element.attrib[\'key\'] = key_converter.toUnicode(k)\n                 child.append(list_element)\n \n         elif ICollection.providedBy(field):\n             for v in value:\n-                list_element = valueToElement(field.value_type, v, \'element\', force)\n+                list_element = valueToElement(\n+                    field.value_type, v, \'element\', force)\n                 child.append(list_element)\n \n         else:\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T10:23:57+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/1d02b25d02b825cd64fa95760b0abee1b5055e7e

Fix tests

Files changed:
M CHANGES.rst
M plone/supermodel/__init__.py
M plone/supermodel/converters.py
M plone/supermodel/directives.rst
M plone/supermodel/exportimport.py
M plone/supermodel/fields.rst
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/schema.rst
M plone/supermodel/schemaclass.rst
M plone/supermodel/tests.py
M plone/supermodel/utils.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex abbba24..c25c7fc 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -11,7 +11,7 @@ Breaking changes:\n New features:\n \n - Python 3 compatibility.\n-  [pbauer, dhavlik]\n+  [pbauer, dhavlik, ale-rt]\n \n Bug fixes:\n \ndiff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 84d9438..6ccce91 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,12 +1,11 @@\n # -*- coding: utf-8 -*-\n+from io import BytesIO\n from plone.supermodel import model\n from plone.supermodel import parser\n from plone.supermodel import serializer\n from plone.supermodel import utils\n from plone.supermodel.interfaces import FILENAME_KEY\n from plone.supermodel.interfaces import IXMLToSchema\n-from six import BytesIO\n-from six import StringIO\n from zope.interface import moduleProvides\n \n import six\n@@ -33,10 +32,9 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n \n \n def loadString(model, policy=u""):\n-    source = StringIO(model) if six.PY2 \\\n-        else BytesIO(six.binary_type(model, encoding=\'latin-1\'))\n-    # source = StringIO(model) if six.PY2 else BytesIO(model)\n-    return parser.parse(source, policy=policy)\n+    if not isinstance(model, six.binary_type):\n+        model = model.encode()\n+    return parser.parse(BytesIO(model), policy=policy)\n \n \n def serializeSchema(schema, name=u""):\ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex 8109f88..1458a46 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -38,7 +38,8 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-\n+        if isinstance(value, six.binary_type):\n+            return value.decode()\n         return six.text_type(value)\n \n \n@@ -128,4 +129,6 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n+        if isinstance(value, six.binary_type):\n+            return value.decode()\n         return six.text_type(value)\ndiff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst\nindex c173379..24117e1 100644\n--- a/plone/supermodel/directives.rst\n+++ b/plone/supermodel/directives.rst\n@@ -13,7 +13,7 @@ Setup\n \n First, load this package\'s configuration:\n \n-    >>> configuration = u"""\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -25,9 +25,9 @@ First, load this package\'s configuration:\n     ... </configure>\n     ... """\n \n-    >>> from six import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n We will also need a temporary directory for storing test schema files.\n \n@@ -76,7 +76,7 @@ temporary directory created above.\n \n     >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n     >>> schema_file = open(schema_filename, "w")\n-    >>> foo = schema_file.write(schema)\n+    >>> _ = schema_file.write(schema)  # On Python 3 this returns the length\n     >>> schema_file.close()\n \n We can now define a schema, using the directives defined in this package:\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 63be331..0694f61 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -397,11 +397,9 @@ def write(self, field, name, type, elementName=\'field\'):\n         ):\n             value = []\n             for term in field.vocabulary:\n-                term_token = six.binary_type(term.token) if six.PY2 \\\n-                    else six.binary_type(term.token, encoding=\'unicode_escape\')\n                 if (\n                     not isinstance(term.value, six.string_types) or\n-                    term_token != term.value.encode(\'unicode_escape\')\n+                    six.b(term.token) != term.value.encode(\'unicode_escape\')\n                 ):\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex 9e55321..f1ac3ab 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -18,7 +18,7 @@ limitations:\n \n First, let\'s wire up the package.\n \n-    >>> configuration = u"""\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.behavior.tests">\n@@ -30,9 +30,9 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from six import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Then, let\'s test each field in turn.\n \n@@ -51,14 +51,15 @@ Then, let\'s test each field in turn.\n Bytes\n -----\n \n-    >>> field = schema.Bytes(__name__=\'dummy\', title=u\'Test\',\n-    ...     description=u\'Test desc\', required=False, readonly=True,\n-    ...     default=b\'abc\', missing_value=\'m\',\n+    >>> field = schema.Bytes(__name__="dummy", title=u"Test",\n+    ...     description=u"Test desc", required=False, readonly=True,\n+    ...     default=b\'abc\', missing_value=b\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> from __future__ import print_function\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Bytes">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -97,14 +98,14 @@ Bytes\n BytesLine\n ---------\n \n-    >>> field = schema.BytesLine(__name__=\'dummy\', title=u\'Test\',\n-    ...     description=u\'Test desc\', required=False, readonly=True,\n-    ...     default=b\'abc\', missing_value=\'m\',\n+    >>> field = schema.BytesLine(__name__="dummy", title=u"Test",\n+    ...     description=u"Test desc", required=False, readonly=True,\n+    ...     default=b\'abc\', missing_value=b\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.BytesLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -150,7 +151,7 @@ ASCII\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.ASCII">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -196,7 +197,7 @@ ASCIILine\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.ASCIILine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -242,7 +243,7 @@ Text\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Text">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -288,7 +289,7 @@ TextLine\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.TextLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -334,7 +335,7 @@ SourceText\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.SourceText">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -380,7 +381,7 @@ URI\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.URI">\n       <default>http://plone.org</default>\n       <description>Test desc</description>\n@@ -426,7 +427,7 @@ Id\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Id">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -472,7 +473,7 @@ DottedName\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.DottedName">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -524,7 +525,7 @@ Password\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Password">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -569,7 +570,7 @@ Bool\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Bool">\n       <default>False</default>\n       <description>Test desc</description>\n@@ -609,7 +610,7 @@ Int\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Int">\n       <default>12</default>\n       <description>Test desc</description>\n@@ -655,7 +656,7 @@ Float\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Float">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -702,7 +703,7 @@ Decimal\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Decimal">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -748,7 +749,7 @@ Date\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Date">\n       <default>2001-01-02</default>\n       <description>Test desc</description>\n@@ -794,7 +795,7 @@ Datetime\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Datetime">\n       <default>2001-01-02 01:02:03</default>\n       <description>Test desc</description>\n@@ -840,7 +841,7 @@ InterfaceField\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.InterfaceField">\n       <default>plone.supermodel.tests.IDummy</default>\n       <description>Test desc</description>\n@@ -881,7 +882,7 @@ Tuple\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Tuple">\n       <default>\n         <element>1</element>\n@@ -922,8 +923,8 @@ Tuple\n     10\n     >>> reciprocal.value_type.__class__\n     <class \'zope.schema._bootstrapfields.Int\'>\n-    >>> reciprocal.value_type.title\n-    u\'Val\'\n+    >>> reciprocal.value_type.title == u\'Val\'\n+    True\n     >>> reciprocal._init_field\n     False\n \n@@ -938,7 +939,7 @@ List\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.List">\n       <default>\n         <element>1</element>\n@@ -961,10 +962,10 @@ List\n     <class \'zope.schema._field.List\'>\n     >>> reciprocal.__name__\n     \'dummy\'\n-    >>> reciprocal.title\n-    u\'Test\'\n-    >>> reciprocal.description\n-    u\'Test desc\'\n+    >>> reciprocal.title == u\'Test\'\n+    True\n+    >>> reciprocal.description == u\'Test desc\'\n+    True\n     >>> reciprocal.required\n     False\n     >>> reciprocal.readonly\n@@ -995,7 +996,7 @@ Set\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Set">\n       <default>\n         <element>1</element>\n@@ -1026,14 +1027,10 @@ Set\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> isinstance(reciprocal.default, set)\n+    >>> reciprocal.default == {1, 2}\n     True\n-    >>> list(reciprocal.default)\n-    [1, 2]\n-    >>> isinstance(reciprocal.missing_value, set)\n+    >>> reciprocal.missing_value == set()\n     True\n-    >>> len(reciprocal.missing_value)\n-    0\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1056,7 +1053,7 @@ FrozenSet\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.FrozenSet">\n       <default>\n         <element>1</element>\n@@ -1118,7 +1115,7 @@ Dict\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Dict">\n       <default>\n         <element key="a">1</element>\n@@ -1191,7 +1188,7 @@ fields will be omitted, as there is no way to write these reliably.\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType) #doctest: +ELLIPSIS\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Object">\n       <description>Test desc</description>\n       <readonly>True</readonly>\n@@ -1256,7 +1253,7 @@ These can be both exported and imported.\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1303,7 +1300,7 @@ a unicode string when importing.\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1335,8 +1332,8 @@ a unicode string when importing.\n     \'a\'\n     >>> reciprocal.missing_value\n     \'\'\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'b\', u\'c\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'b\', u\'c\']\n+    True\n     >>> reciprocal.vocabularyName is None\n     True\n \n@@ -1345,17 +1342,18 @@ sure it hasn\'t regressed.\n \n     >>> from plone.supermodel.interfaces import XML_NAMESPACE\n     >>> element.set(\'xmlns\', XML_NAMESPACE)\n-    >>> element = etree.parse(StringIO(prettyXML(element).decode(\'latin-1\'))).getroot()\n+    >>> from io import BytesIO\n+    >>> element = etree.parse(BytesIO(prettyXML(element).encode())).getroot()\n     >>> reciprocal = handler.read(element)\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'b\', u\'c\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'b\', u\'c\']\n+    True\n \n Also, make sure we can handle terms with unicode values (as long as their\n tokens are the utf8-encoded values).\n \n     >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm\n     >>> vocab = SimpleVocabulary([\n-    ...     SimpleTerm(token=\'a\', value=u\'a\', title=u\'a\'),\n+    ...     SimpleTerm(token=b\'a\', value=u\'a\', title=u\'a\'),\n     ...     SimpleTerm(token=r\'\\xe7\', value=u\'\\xe7\', title=u\'\\xe7\'), # c with cedilla\n     ...     ])\n     >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n@@ -1365,7 +1363,7 @@ tokens are the utf8-encoded values).\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1380,8 +1378,8 @@ tokens are the utf8-encoded values).\n     </field>\n \n     >>> reciprocal = handler.read(element)\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'\\xe7\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'\\xe7\']\n+    True\n \n \n Additionally, it is possible for Choice fields with a values vocabulary\n@@ -1402,7 +1400,7 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n     ...     )\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print(prettyXML(element).decode(\'latin-1\'))\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <title>Test</title>\n       <values>\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 7ff077e..6353f4a 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -89,6 +89,7 @@ def _SchemaClass_finalize(self):\n         for order, name, adapter in adapters:\n             adapter()\n \n+\n Schema = SchemaClass(\n     \'Schema\',\n     (Interface,),\n@@ -110,6 +111,7 @@ def walk(schema):\n         for child in schema.dependents.keys():\n             for s in walk(child):\n                 yield s\n+\n     schemas = set(walk(parent))\n     for schema in sorted(schemas):\n         if hasattr(schema, \'_SchemaClass_finalize\'):\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex bc3d022..13a1088 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -27,7 +27,6 @@\n import traceback\n \n \n-\n # Exception\n class SupermodelParseError(Exception):\n \ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex 115db85..bcf9e48 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -14,7 +14,7 @@ Before we can begin, we must register the field handlers that know how to\n import and export fields from/to XML. These are registered as named utilities,\n and can be loaded from the configure.zcml file of plone.supermodel.\n \n-    >>> configuration = u"""\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -26,9 +26,9 @@ and can be loaded from the configure.zcml file of plone.supermodel.\n     ... </configure>\n     ... """\n \n-    >>> from six import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Next, let\'s define a sample model with a single, unnamed schema.\n \n@@ -58,8 +58,8 @@ We can parse this model using the loadString() function:\n \n This will load one schema, with the default name u"":\n \n-    >>> list(model.schemata.keys())\n-    [u\'\']\n+    >>> list(model.schemata.keys()) == [u\'\']\n+    True\n \n We can inspect this schema and see that it contains zope.schema fields with\n attributes corresponding to the values set in XML.\n@@ -70,15 +70,15 @@ attributes corresponding to the values set in XML.\n     >>> getFieldNamesInOrder(schema)\n     [\'title\', \'description\']\n \n-    >>> schema[\'title\'].title\n-    u\'Title\'\n+    >>> schema[\'title\'].title == u\'Title\'\n+    True\n     >>> schema[\'title\'].required\n     True\n \n-    >>> schema[\'description\'].title\n-    u\'Description\'\n-    >>> schema[\'description\'].description\n-    u\'A short summary\'\n+    >>> schema[\'description\'].title == u\'Description\'\n+    True\n+    >>> schema[\'description\'].description == u\'A short summary\'\n+    True\n     >>> schema[\'description\'].required\n     False\n     >>> schema[\'description\'].min_length\n@@ -106,7 +106,8 @@ lxml.)\n In addition to parsing, we can serialize a model to an XML representation:\n \n     >>> from plone.supermodel import serializeModel\n-    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> from __future__ import print_function\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -166,7 +167,7 @@ directory.\n     >>> tmpdir = tempfile.mkdtemp()\n     >>> schema_filename = os.path.join(tmpdir, \'schema.xml\')\n     >>> with open(schema_filename, \'w\') as fd:\n-    ...     fd.write(schema)\n+    ...     _ = fd.write(schema)  # On Py3 write resturns the schema len\n \n We can define interfaces from this using a helper function:\n \n@@ -193,7 +194,7 @@ dict as per the serializeModel() method seen above, or you can write a model\n of just a single schema using serializeSchema():\n \n     >>> from plone.supermodel import serializeSchema\n-    >>> print(serializeSchema(ITestContent).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestContent)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -206,7 +207,7 @@ of just a single schema using serializeSchema():\n       </schema>\n     </model>\n \n-    >>> print(serializeSchema(ITestMetadata, name=u\'metadata\').decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestMetadata, name=u"metadata")) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema name="metadata">\n         <field name="created" type="zope.schema.Datetime">\n@@ -289,7 +290,7 @@ We should also verify that the description field was indeed overridden:\n \n Finally, let\'s verify that bases are preserved upon serialisation:\n \n-    >>> print(serializeSchema(model.schema).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(model.schema)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema based-on="plone.supermodel.tests.IBase">\n         <field name="description" type="zope.schema.Text">\n@@ -401,7 +402,7 @@ default schema above is unrelated to the one in the metadata schema.\n \n When we serialise a schema with fieldsets, fields will be grouped by fieldset.\n \n-    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -480,7 +481,7 @@ action.\n \n The model\'s serialization should include the invariant.\n \n-    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <invariant>plone.supermodel.tests.dummy_invariant</invariant>\n@@ -553,13 +554,13 @@ zope.i18nmessageid message id rather than a basic Unicode string::\n     ... """\n     >>> model = loadString(schema)\n     >>> msgid = model.schema[\'title\'].title\n-    >>> msgid\n-    u\'supermodel_test_title\'\n+    >>> msgid == u\'supermodel_test_title\'\n+    True\n     >>> type(msgid)\n     <... \'zope.i18nmessageid.message.Message\'>\n-    >>> msgid.default\n-    u\'Title\'\n-    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> msgid.default == u\'Title\'\n+    True\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -669,7 +670,7 @@ and each field, respectively.\n Of course, we can also serialize the schema back to XML. Here, the \'prefix\'\n set in the utility (if any) will be used by default.\n \n-    >>> print(serializeModel(model).decode(\'latin-1\')) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema ui:layout="horizontal">\n         <field name="title" type="zope.schema.TextLine" ui:widget="largetype">\ndiff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst\nindex f718d75..66dee60 100644\n--- a/plone/supermodel/schemaclass.rst\n+++ b/plone/supermodel/schemaclass.rst\n@@ -5,15 +5,16 @@ plone.supermodel: SchemaClass\n     >>> from plone.supermodel.model import Schema, SchemaClass\n     >>> from plone.supermodel import interfaces\n     >>> from zope.interface import Interface, implementer\n-    >>> from zope.component import adapts, provideAdapter\n+    >>> from zope.component import adapter, provideAdapter\n \n Schema plugins are registered as named adapters. They may optionally contain\n an order attribute, which defaults to 0.\n \n     >>> adapter_calls = []\n     >>> @implementer(interfaces.ISchemaPlugin)\n+    ... @adapter(interfaces.ISchema)\n     ... class TestPlugin(object):\n-    ...     adapts(interfaces.ISchema)\n+    ...\n     ...     order = 1\n     ...     def __init__(self, schema):\n     ...         self.schema = schema\n@@ -25,7 +26,7 @@ an order attribute, which defaults to 0.\n \n Schema plugins are executed at schema declaration.\n \n-    >>> class IA(Schema):\n+    >>> class IA(Schema):  # doctest: +ELLIPSIS\n     ...     pass\n     >>> adapter_calls == [(\'TestPlugin\', \'IA\')]\n     True\n@@ -68,15 +69,20 @@ directly.\n \n     >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")\n     >>> from plone.supermodel.model import finalizeSchemas\n+\n     >>> finalizeSchemas(IA)\n     >>> adapter_calls == (\n-    ...     [(\'TestPlugin2\', \'IA\'),\n+    ...     [\n+    ...         (\'TestPlugin2\', \'IA\'),\n     ...         (\'TestPlugin\', \'IA\'),\n-    ...        ] if six.PY2 else [\n+    ...     ] if six.PY2 else [\n+    ...         (\'TestPlugin2\', \'IA\'),\n     ...         (\'TestPlugin\', \'IA\'),\n     ...         (\'TestPlugin2\', \'IB\'),\n     ...         (\'TestPlugin\', \'IB\'),\n     ...         (\'TestPlugin2\', \'IC\'),\n-    ...        (\'TestPlugin\', \'IC\')])\n+    ...         (\'TestPlugin\', \'IC\'),\n+    ...     ]\n+    ... )\n     True\n     >>> adapter_calls = []\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 2af4a07..75f3c4b 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -19,10 +19,9 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n import doctest\n-import unittest\n import re\n import six\n-import sys\n+import unittest\n import zope.component.testing\n \n \n@@ -487,7 +486,6 @@ def test_choice_serialized(self):\n             el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n             self.assertEquals(etree.tostring(el), expected)\n \n-\n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n             return tuple((t.value, t.title) for t in vocab)\n@@ -500,7 +498,7 @@ def _termvalues(vocab):\n         for field, expected in cases:\n             el = etree.fromstring(expected)\n             imported_field = self.handler.read(el)\n-            self.assertEquals(\n+            self.assertEqual(\n                 _termvalues(imported_field.vocabulary),\n                 _termvalues(field.vocabulary),\n             )\n@@ -508,7 +506,9 @@ def _termvalues(vocab):\n \n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        if not six.PY2:\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n             want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n             want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n             got = re.sub(\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 9b9cc1a..bbca1d0 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -73,7 +73,10 @@ def indent(node, level=0):\n \n def prettyXML(tree):\n     indent(tree)\n-    return etree.tostring(tree)\n+    xml = etree.tostring(tree)\n+    if six.PY2:\n+        return xml\n+    return xml.decode()\n \n \n def fieldTypecast(field, value):\n@@ -152,7 +155,11 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            value = converter.fromUnicode(six.text_type(text))\n+            if isinstance(text, six.binary_type):\n+                text = text.decode()\n+            else:\n+                text = six.text_type(text)\n+            value = converter.fromUnicode(text)\n \n         # handle i18n\n         if isinstance(value, six.string_types) and \\\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T10:23:57+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/65b78b8c4d4d4dd1a62d5396797db1574791e629

Do not depend on class representation

Files changed:
M plone/supermodel/fields.rst

b'diff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex f1ac3ab..3f1544c 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -1213,8 +1213,8 @@ object field that references a particular dotted name.\n     ... """)\n \n     >>> reciprocal = handler.read(element)\n-    >>> reciprocal.__class__\n-    <class \'zope.schema._field.Object\'>\n+    >>> isinstance(reciprocal, schema._field.Object)\n+    True\n     >>> reciprocal.__name__\n     \'dummy\'\n     >>> reciprocal.title\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-09-20T14:18:47+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.supermodel/commit/b6af529483522e8a66b5d03110ea853793a2b0a7

Merge pull request #21 from plone/python3

Add support for Python3

Files changed:
M CHANGES.rst
M plone/supermodel/__init__.py
M plone/supermodel/configure.zcml
M plone/supermodel/converters.py
M plone/supermodel/directives.py
M plone/supermodel/directives.rst
M plone/supermodel/exportimport.py
M plone/supermodel/fields.rst
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/schema.rst
M plone/supermodel/schemaclass.rst
M plone/supermodel/tests.py
M plone/supermodel/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 34e2530..c25c7fc 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,7 +10,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- Python 3 compatibility.\n+  [pbauer, dhavlik, ale-rt]\n \n Bug fixes:\n \ndiff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 5b3a582..6ccce91 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,13 +1,15 @@\n # -*- coding: utf-8 -*-\n+from io import BytesIO\n from plone.supermodel import model\n from plone.supermodel import parser\n from plone.supermodel import serializer\n from plone.supermodel import utils\n from plone.supermodel.interfaces import FILENAME_KEY\n from plone.supermodel.interfaces import IXMLToSchema\n-from six import StringIO\n from zope.interface import moduleProvides\n \n+import six\n+\n \n # Cache models by absolute filename\n _model_cache = {}\n@@ -30,7 +32,9 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n \n \n def loadString(model, policy=u""):\n-    return parser.parse(StringIO(model), policy=policy)\n+    if not isinstance(model, six.binary_type):\n+        model = model.encode()\n+    return parser.parse(BytesIO(model), policy=policy)\n \n \n def serializeSchema(schema, name=u""):\ndiff --git a/plone/supermodel/configure.zcml b/plone/supermodel/configure.zcml\nindex cd8491c..adee0b7 100644\n--- a/plone/supermodel/configure.zcml\n+++ b/plone/supermodel/configure.zcml\n@@ -40,6 +40,7 @@\n \n     <adapter factory=".converters.ObjectFromUnicode" />\n \n+    <adapter factory=".converters.BytesToUnicode" />\n \n     <!-- Field handlers for all of zope.schema -->\n \ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex dbe9004..1458a46 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -4,6 +4,7 @@\n from zope.component import adapter\n from zope.dottedname.resolve import resolve\n from zope.interface import implementer\n+from zope.schema.interfaces import IBytes\n from zope.schema.interfaces import IDate\n from zope.schema.interfaces import IDatetime\n from zope.schema.interfaces import IField\n@@ -37,6 +38,8 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n+        if isinstance(value, six.binary_type):\n+            return value.decode()\n         return six.text_type(value)\n \n \n@@ -116,3 +119,16 @@ def fromUnicode(self, value):\n         obj = resolve(value)\n         self.context.validate(obj)\n         return obj\n+\n+\n+@implementer(IToUnicode)\n+@adapter(IBytes)\n+class BytesToUnicode(object):\n+\n+    def __init__(self, context):\n+        self.context = context\n+\n+    def toUnicode(self, value):\n+        if isinstance(value, six.binary_type):\n+            return value.decode()\n+        return six.text_type(value)\ndiff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py\nindex 3591b46..77cda7a 100644\n--- a/plone/supermodel/directives.py\n+++ b/plone/supermodel/directives.py\n@@ -81,8 +81,8 @@ def check(self):\n         for fieldName in self.fieldNames():\n             if fieldName not in schema:\n                 raise ValueError(\n-                    u"The directive {0} applied to interface {1} "\n-                    u"refers to unknown field name {2}".format(\n+                    u\'The directive {0} applied to interface {1} \'\n+                    u\'refers to unknown field name {2}\'.format(\n                         self.key,\n                         schema.__identifier__,\n                         fieldName\n@@ -130,10 +130,10 @@ class load(Directive):\n     """\n \n     def store(self, tags, value):\n-        tags[FILENAME_KEY] = value["filename"]\n-        tags[SCHEMA_NAME_KEY] = value["schema"]\n+        tags[FILENAME_KEY] = value[\'filename\']\n+        tags[SCHEMA_NAME_KEY] = value[\'schema\']\n \n-    def factory(self, filename, schema=u""):\n+    def factory(self, filename, schema=u\'\'):\n         return dict(filename=filename, schema=schema)\n \n \n@@ -151,7 +151,7 @@ def __call__(self):\n         filename = interface.queryTaggedValue(FILENAME_KEY, None)\n         if filename is None:\n             return\n-        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u"")\n+        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u\'\')\n \n         moduleName = interface.__module__\n         module = sys.modules.get(moduleName, None)\n@@ -161,7 +161,7 @@ def __call__(self):\n         if hasattr(module, \'__path__\'):\n             directory = module.__path__[0]\n         else:\n-            while "." in moduleName:\n+            while \'.\' in moduleName:\n                 moduleName, _ = moduleName.rsplit(\'.\', 1)\n                 module = sys.modules.get(moduleName, None)\n                 if hasattr(module, \'__path__\'):\n@@ -176,8 +176,8 @@ def __call__(self):\n         model = loadFile(filename)\n         if schema not in model.schemata:\n             raise ValueError(\n-                u"Schema \'{0}\' specified for interface {1} does not exist "\n-                "in {2}.".format(\n+                \'Schema "{0}" specified for interface {1} does not exist \'\n+                \'in {2}.\'.format(\n                     schema,\n                     interface.__identifier__,\n                     filename,\ndiff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst\nindex dc967a7..24117e1 100644\n--- a/plone/supermodel/directives.rst\n+++ b/plone/supermodel/directives.rst\n@@ -13,7 +13,7 @@ Setup\n \n First, load this package\'s configuration:\n \n-    >>> configuration = """\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -25,9 +25,9 @@ First, load this package\'s configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n We will also need a temporary directory for storing test schema files.\n \n@@ -76,7 +76,7 @@ temporary directory created above.\n \n     >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n     >>> schema_file = open(schema_filename, "w")\n-    >>> schema_file.write(schema)\n+    >>> _ = schema_file.write(schema)  # On Python 3 this returns the length\n     >>> schema_file.close()\n \n We can now define a schema, using the directives defined in this package:\n@@ -108,7 +108,7 @@ We can also use a different, named schema:\n     >>> class ITestMetadata(model.Schema):\n     ...     """Test metadata schema, built from XML\n     ...     """\n-    ...     model.load(schema_filename, schema=u"metadata")\n+    ...     model.load(schema_filename, schema=u\'metadata\')\n \n     >>> getFieldNamesInOrder(ITestMetadata)\n     [\'created\', \'creator\']\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 0270c03..0694f61 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -23,7 +23,7 @@\n \n try:\n     from collections import OrderedDict\n-except:\n+except ImportError:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n \n@@ -398,8 +398,8 @@ def write(self, field, name, type, elementName=\'field\'):\n             value = []\n             for term in field.vocabulary:\n                 if (\n-                    not isinstance(term.value, six.string_types, ) or\n-                    term.token != term.value.encode(\'unicode_escape\')\n+                    not isinstance(term.value, six.string_types) or\n+                    six.b(term.token) != term.value.encode(\'unicode_escape\')\n                 ):\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex b245cea..3f1544c 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -18,7 +18,7 @@ limitations:\n \n First, let\'s wire up the package.\n \n-    >>> configuration = """\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.behavior.tests">\n@@ -30,35 +30,36 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Then, let\'s test each field in turn.\n \n-    >>> from zope.component import getUtility\n-    >>> from zope import schema\n-\n+    >>> from lxml import etree\n     >>> from plone.supermodel.interfaces import IFieldExportImportHandler\n     >>> from plone.supermodel.interfaces import IFieldNameExtractor\n     >>> from plone.supermodel.utils import prettyXML\n+    >>> from zope import schema\n+    >>> from zope.component import getUtility\n \n     >>> import datetime\n     >>> import plone.supermodel.tests\n+    >>> import six\n \n-    >>> from lxml import etree\n \n Bytes\n -----\n \n     >>> field = schema.Bytes(__name__="dummy", title=u"Test",\n     ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=\'abc\', missing_value=\'m\',\n+    ...     default=b\'abc\', missing_value=b\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> from __future__ import print_function\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Bytes">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -83,10 +84,10 @@ Bytes\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    \'abc\'\n-    >>> reciprocal.missing_value\n-    \'m\'\n+    >>> reciprocal.default.decode(\'latin-1\')\n+    u\'abc\'\n+    >>> reciprocal.missing_value.decode(\'latin-1\')\n+    u\'m\'\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -99,12 +100,12 @@ BytesLine\n \n     >>> field = schema.BytesLine(__name__="dummy", title=u"Test",\n     ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=\'abc\', missing_value=\'m\',\n+    ...     default=b\'abc\', missing_value=b\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.BytesLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -129,10 +130,10 @@ BytesLine\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    \'abc\'\n-    >>> reciprocal.missing_value\n-    \'m\'\n+    >>> reciprocal.default.decode(\'latin-1\')\n+    u\'abc\'\n+    >>> reciprocal.missing_value.decode(\'latin-1\')\n+    u\'m\'\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -143,14 +144,14 @@ BytesLine\n ASCII\n -----\n \n-    >>> field = schema.ASCII(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.ASCII(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.ASCII">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -189,14 +190,14 @@ ASCII\n ASCIILine\n ---------\n \n-    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.ASCIILine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.ASCIILine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -235,14 +236,14 @@ ASCIILine\n Text\n ----\n \n-    >>> field = schema.Text(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Text(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Text">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -281,14 +282,14 @@ Text\n TextLine\n --------\n \n-    >>> field = schema.TextLine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.TextLine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.TextLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -327,14 +328,14 @@ TextLine\n SourceText\n ----------\n \n-    >>> field = schema.SourceText(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.SourceText(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.SourceText">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -373,14 +374,14 @@ SourceText\n URI\n ---\n \n-    >>> field = schema.URI(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.URI(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'http://plone.org\', missing_value=\'m\',\n     ...     min_length=2, max_length=100)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.URI">\n       <default>http://plone.org</default>\n       <description>Test desc</description>\n@@ -419,14 +420,14 @@ URI\n Id\n --\n \n-    >>> field = schema.Id(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Id(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a.b.c\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Id">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -465,14 +466,14 @@ Id\n DottedName\n -----------\n \n-    >>> field = schema.DottedName(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.DottedName(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a.b.c\', missing_value=\'m\',\n     ...     min_length=2, max_length=10, min_dots=2, max_dots=4)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.DottedName">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -517,14 +518,14 @@ DottedName\n Password\n --------\n \n-    >>> field = schema.Password(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Password(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Password">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -563,13 +564,13 @@ Password\n Bool\n ----\n \n-    >>> field = schema.Bool(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Bool(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=False, missing_value=True)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Bool">\n       <default>False</default>\n       <description>Test desc</description>\n@@ -602,14 +603,14 @@ Bool\n Int\n ---\n \n-    >>> field = schema.Int(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Int(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=12, missing_value=-1,\n     ...     min=1, max=99)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Int">\n       <default>12</default>\n       <description>Test desc</description>\n@@ -648,14 +649,14 @@ Int\n Float\n -----\n \n-    >>> field = schema.Float(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Float(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=12.1, missing_value=-1.0,\n     ...     min=1.123, max=99.5)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Float">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -695,14 +696,14 @@ Decimal\n -------\n \n     >>> import decimal\n-    >>> field = schema.Decimal(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Decimal(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),\n     ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Decimal">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -741,14 +742,14 @@ Decimal\n Date\n ----\n \n-    >>> field = schema.Date(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Date(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),\n     ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Date">\n       <default>2001-01-02</default>\n       <description>Test desc</description>\n@@ -787,14 +788,14 @@ Date\n Datetime\n ---------\n \n-    >>> field = schema.Datetime(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Datetime(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),\n     ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Datetime">\n       <default>2001-01-02 01:02:03</default>\n       <description>Test desc</description>\n@@ -833,14 +834,14 @@ Datetime\n InterfaceField\n ---------------\n \n-    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.InterfaceField(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=plone.supermodel.tests.IDummy,\n     ...     missing_value=plone.supermodel.tests.IDummy)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.InterfaceField">\n       <default>plone.supermodel.tests.IDummy</default>\n       <description>Test desc</description>\n@@ -873,15 +874,15 @@ InterfaceField\n Tuple\n -----\n \n-    >>> field = schema.Tuple(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Tuple(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=(1,2), missing_value=(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Tuple">\n       <default>\n         <element>1</element>\n@@ -922,23 +923,23 @@ Tuple\n     10\n     >>> reciprocal.value_type.__class__\n     <class \'zope.schema._bootstrapfields.Int\'>\n-    >>> reciprocal.value_type.title\n-    u\'Val\'\n+    >>> reciprocal.value_type.title == u\'Val\'\n+    True\n     >>> reciprocal._init_field\n     False\n \n List\n ----\n \n-    >>> field = schema.List(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.List(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=[1,2], missing_value=[],\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.List">\n       <default>\n         <element>1</element>\n@@ -961,10 +962,10 @@ List\n     <class \'zope.schema._field.List\'>\n     >>> reciprocal.__name__\n     \'dummy\'\n-    >>> reciprocal.title\n-    u\'Test\'\n-    >>> reciprocal.description\n-    u\'Test desc\'\n+    >>> reciprocal.title == u\'Test\'\n+    True\n+    >>> reciprocal.description == u\'Test desc\'\n+    True\n     >>> reciprocal.required\n     False\n     >>> reciprocal.readonly\n@@ -987,15 +988,15 @@ List\n Set\n ---\n \n-    >>> field = schema.Set(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Set(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=set((1,2)), missing_value=set(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Set">\n       <default>\n         <element>1</element>\n@@ -1026,10 +1027,10 @@ Set\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    set([1, 2])\n-    >>> reciprocal.missing_value\n-    set([])\n+    >>> reciprocal.default == {1, 2}\n+    True\n+    >>> reciprocal.missing_value == set()\n+    True\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1044,15 +1045,15 @@ Set\n FrozenSet\n ---------\n \n-    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.FrozenSet(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=frozenset((1,2)), missing_value=frozenset(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.FrozenSet">\n       <default>\n         <element>1</element>\n@@ -1083,10 +1084,14 @@ FrozenSet\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    frozenset([1, 2])\n-    >>> reciprocal.missing_value\n-    frozenset([])\n+    >>> isinstance(reciprocal.default, frozenset)\n+    True\n+    >>> list(reciprocal.default)\n+    [1, 2]\n+    >>> isinstance(reciprocal.missing_value, frozenset)\n+    True\n+    >>> len(reciprocal.missing_value)\n+    0\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1101,16 +1106,16 @@ FrozenSet\n Dict\n ----\n \n-    >>> field = schema.Dict(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Dict(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default={\'a\':1, \'b\':2}, missing_value={},\n     ...     min_length=2, max_length=10,\n-    ...     key_type=schema.ASCIILine(title=u"Key"),\n-    ...     value_type=schema.Int(title=u"Val"))\n+    ...     key_type=schema.ASCIILine(title=u\'Key\'),\n+    ...     value_type=schema.Int(title=u\'Val\'))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Dict">\n       <default>\n         <element key="a">1</element>\n@@ -1144,8 +1149,12 @@ Dict\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    {\'a\': 1, \'b\': 2}\n+    >>> reciprocal.default[\'a\']\n+    1\n+    >>> reciprocal.default[\'b\']\n+    2\n+    >>> sorted(reciprocal.default.keys())\n+    [\'a\', \'b\']\n     >>> reciprocal.missing_value\n     {}\n     >>> reciprocal.min_length\n@@ -1172,14 +1181,14 @@ fields will be omitted, as there is no way to write these reliably.\n     >>> dummy1 = plone.supermodel.tests.Dummy()\n     >>> dummy2 = plone.supermodel.tests.Dummy()\n \n-    >>> field = schema.Object(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Object(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=dummy1, missing_value=dummy2,\n     ...     schema=plone.supermodel.tests.IDummy)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType) #doctest: +ELLIPSIS\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Object">\n       <description>Test desc</description>\n       <readonly>True</readonly>\n@@ -1204,8 +1213,8 @@ object field that references a particular dotted name.\n     ... """)\n \n     >>> reciprocal = handler.read(element)\n-    >>> reciprocal.__class__\n-    <class \'zope.schema._field.Object\'>\n+    >>> isinstance(reciprocal, schema._field.Object)\n+    True\n     >>> reciprocal.__name__\n     \'dummy\'\n     >>> reciprocal.title\n@@ -1237,14 +1246,14 @@ dotted name.\n \n These can be both exported and imported.\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', vocabulary=u\'dummy.vocab\')\n \n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1284,14 +1293,14 @@ These can be both exported and imported.\n These can be both imported and exported, but note that the value is always\n a unicode string when importing.\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', values=[\'a\', \'b\', \'c\'])\n \n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1323,8 +1332,8 @@ a unicode string when importing.\n     \'a\'\n     >>> reciprocal.missing_value\n     \'\'\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'b\', u\'c\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'b\', u\'c\']\n+    True\n     >>> reciprocal.vocabularyName is None\n     True\n \n@@ -1333,27 +1342,28 @@ sure it hasn\'t regressed.\n \n     >>> from plone.supermodel.interfaces import XML_NAMESPACE\n     >>> element.set(\'xmlns\', XML_NAMESPACE)\n-    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()\n+    >>> from io import BytesIO\n+    >>> element = etree.parse(BytesIO(prettyXML(element).encode())).getroot()\n     >>> reciprocal = handler.read(element)\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'b\', u\'c\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'b\', u\'c\']\n+    True\n \n Also, make sure we can handle terms with unicode values (as long as their\n tokens are the utf8-encoded values).\n \n     >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm\n     >>> vocab = SimpleVocabulary([\n-    ...     SimpleTerm(token=\'a\', value=u\'a\', title=u\'a\'),\n+    ...     SimpleTerm(token=b\'a\', value=u\'a\', title=u\'a\'),\n     ...     SimpleTerm(token=r\'\\xe7\', value=u\'\\xe7\', title=u\'\\xe7\'), # c with cedilla\n     ...     ])\n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', vocabulary=vocab)\n \n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1368,8 +1378,8 @@ tokens are the utf8-encoded values).\n     </field>\n \n     >>> reciprocal = handler.read(element)\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'\\xe7\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'\\xe7\']\n+    True\n \n \n Additionally, it is possible for Choice fields with a values vocabulary\n@@ -1384,13 +1394,13 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n     ...     SimpleTerm(value=u\'b\', title=u\'B\'),\n     ...     ])\n     >>> field = schema.Choice(\n-    ...     __name__="dummy",\n-    ...     title=u"Test",\n+    ...     __name__=\'dummy\',\n+    ...     title=u\'Test\',\n     ...     vocabulary=vocab,\n     ...     )\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <title>Test</title>\n       <values>\n@@ -1403,8 +1413,8 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n \n We cannot export choice fields with a source or context source binder:\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1413,8 +1423,8 @@ We cannot export choice fields with a source or context source binder:\n     ...\n     NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     source=plone.supermodel.tests.dummy_vocabulary_instance)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1423,8 +1433,8 @@ We cannot export choice fields with a source or context source binder:\n     ...\n     NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     source=plone.supermodel.tests.dummy_binder)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 37fc620..6353f4a 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -89,6 +89,7 @@ def _SchemaClass_finalize(self):\n         for order, name, adapter in adapters:\n             adapter()\n \n+\n Schema = SchemaClass(\n     \'Schema\',\n     (Interface,),\n@@ -110,8 +111,9 @@ def walk(schema):\n         for child in schema.dependents.keys():\n             for s in walk(child):\n                 yield s\n+\n     schemas = set(walk(parent))\n-    for schema in schemas:\n+    for schema in sorted(schemas):\n         if hasattr(schema, \'_SchemaClass_finalize\'):\n             schema._SchemaClass_finalize()\n         elif isinstance(schema, InterfaceClass):\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 10ba2eb..13a1088 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -24,27 +24,27 @@\n import linecache\n import six\n import sys\n+import traceback\n \n \n # Exception\n-\n-\n class SupermodelParseError(Exception):\n \n-    def __init__(self, orig_exc, fname, element):\n+    def __init__(self, orig_exc, fname, element, tb):\n         msg = str(orig_exc)\n-\n         lineno = None\n         if hasattr(orig_exc, \'lineno\'):\n             lineno = orig_exc.lineno\n         elif element is not None:\n             lineno = getattr(element, \'sourceline\', \'unknown\')\n-\n         if fname or lineno != \'unknown\':\n             msg += \'\\n  File "%s", line %s\' % (fname or \'<unknown>\', lineno)\n         if fname and lineno:\n             line = linecache.getline(fname, lineno).strip()\n             msg += \'\\n    %s\' % line\n+        msg += \'\\n\'\n+        msg += \'\'.join(traceback.format_tb(tb))\n+        msg += \'\\n\'\n         self.args = [msg]\n \n \n@@ -75,11 +75,8 @@ def parse(source, policy=u""):\n         # the filename and line number of the element that caused the problem.\n         # Keep the original traceback so the developer can debug where the\n         # problem happened.\n-        six.reraise(SupermodelParseError(\n-            e,\n-            fname,\n-            parseinfo.stack[-1]\n-        ), None, sys.exc_info()[2])\n+        raise SupermodelParseError(\n+            e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n \n \n def _parse(source, policy):\n@@ -110,7 +107,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                 \'<field /> element\'\n             )\n \n-        handler = handlers.get(fieldType, None)\n+        handler = handlers.get(fieldType)\n         if handler is None:\n             handler = handlers[fieldType] = queryUtility(\n                 IFieldExportImportHandler,\n@@ -126,7 +123,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         # Preserve order from base interfaces if this field is an override\n         # of a field with the same name in a base interface\n-        base_field = baseFields.get(fieldName, None)\n+        base_field = baseFields.get(fieldName)\n         if base_field is not None:\n             field.order = base_field.order\n \n@@ -180,6 +177,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     fieldElements,\n                     baseFields\n                 )\n+\n             elif subelement.tag == ns(\'fieldset\'):\n \n                 fieldset_name = subelement.get(\'name\')\n@@ -190,7 +188,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                         )\n                     )\n \n-                fieldset = fieldsets_by_name.get(fieldset_name, None)\n+                fieldset = fieldsets_by_name.get(fieldset_name)\n                 if fieldset is None:\n                     fieldset_label = subelement.get(\'label\')\n                     fieldset_description = subelement.get(\'description\')\n@@ -219,6 +217,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     if parsed_fieldName:\n                         fieldset.fields.append(parsed_fieldName)\n                     parseinfo.stack.pop()\n+\n             elif subelement.tag == ns(\'invariant\'):\n                 dotted = subelement.text\n                 invariant = resolve(dotted)\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex 4826284..bcf9e48 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -14,7 +14,7 @@ Before we can begin, we must register the field handlers that know how to\n import and export fields from/to XML. These are registered as named utilities,\n and can be loaded from the configure.zcml file of plone.supermodel.\n \n-    >>> configuration = """\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -26,9 +26,9 @@ and can be loaded from the configure.zcml file of plone.supermodel.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Next, let\'s define a sample model with a single, unnamed schema.\n \n@@ -58,27 +58,27 @@ We can parse this model using the loadString() function:\n \n This will load one schema, with the default name u"":\n \n-    >>> model.schemata.keys()\n-    [u\'\']\n+    >>> list(model.schemata.keys()) == [u\'\']\n+    True\n \n We can inspect this schema and see that it contains zope.schema fields with\n attributes corresponding to the values set in XML.\n \n-    >>> schema = model.schema # shortcut to model.schemata[u""]\n+    >>> schema = model.schema  # shortcut to model.schemata[u""]\n \n     >>> from zope.schema import getFieldNamesInOrder\n     >>> getFieldNamesInOrder(schema)\n     [\'title\', \'description\']\n \n-    >>> schema[\'title\'].title\n-    u\'Title\'\n+    >>> schema[\'title\'].title == u\'Title\'\n+    True\n     >>> schema[\'title\'].required\n     True\n \n-    >>> schema[\'description\'].title\n-    u\'Description\'\n-    >>> schema[\'description\'].description\n-    u\'A short summary\'\n+    >>> schema[\'description\'].title == u\'Description\'\n+    True\n+    >>> schema[\'description\'].description == u\'A short summary\'\n+    True\n     >>> schema[\'description\'].required\n     False\n     >>> schema[\'description\'].min_length\n@@ -106,7 +106,8 @@ lxml.)\n In addition to parsing, we can serialize a model to an XML representation:\n \n     >>> from plone.supermodel import serializeModel\n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> from __future__ import print_function\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -164,10 +165,9 @@ directory.\n \n     >>> import tempfile, os.path, shutil\n     >>> tmpdir = tempfile.mkdtemp()\n-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n-    >>> schema_file = open(schema_filename, "w")\n-    >>> schema_file.write(schema)\n-    >>> schema_file.close()\n+    >>> schema_filename = os.path.join(tmpdir, \'schema.xml\')\n+    >>> with open(schema_filename, \'w\') as fd:\n+    ...     _ = fd.write(schema)  # On Py3 write resturns the schema len\n \n We can define interfaces from this using a helper function:\n \n@@ -185,7 +185,7 @@ After being loaded, the interface should have the fields of the default\n \n We can also use a different, named schema:\n \n-    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")\n+    >>> ITestMetadata = xmlSchema(schema_filename, schema=u\'metadata\')\n     >>> getFieldNamesInOrder(ITestMetadata)\n     [\'created\', \'creator\']\n \n@@ -194,7 +194,7 @@ dict as per the serializeModel() method seen above, or you can write a model\n of just a single schema using serializeSchema():\n \n     >>> from plone.supermodel import serializeSchema\n-    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestContent)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -207,7 +207,7 @@ of just a single schema using serializeSchema():\n       </schema>\n     </model>\n \n-    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestMetadata, name=u"metadata")) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema name="metadata">\n         <field name="created" type="zope.schema.Datetime">\n@@ -238,9 +238,9 @@ resolver needs to have a proper module path. The interface looks like this\n though:\n \n     class IBase(Interface):\n-        title = zope.schema.TextLine(title=u"Title")\n-        description = zope.schema.TextLine(title=u"Description")\n-        name = zope.schema.TextLine(title=u"Name")\n+        title = zope.schema.TextLine(title=u\'Title\')\n+        description = zope.schema.TextLine(title=u\'Description\')\n+        name = zope.schema.TextLine(title=u\'Name\')\n \n In real life, you\'d more likely have a dotted name like\n my.package.interfaces.IBase, of course.\n@@ -265,7 +265,7 @@ Then, let\'s define a schema that is based on this interface.\n Here, notice the use of the \'based-on\' attribute, which specifies a dotted\n name to the base interface. It is possible to specify multiple interfaces\n as a space-separated list. However, if you find that you need this, you\n-may want to ask yourself why. :) Inside the schema proper, we override the\n+may want to ask yourself why. :) Inside the proper schema, we override the\n \'description\' field and add a new field, \'age\'.\n \n When we load this model, we should find that the __bases__ list of the\n@@ -290,7 +290,7 @@ We should also verify that the description field was indeed overridden:\n \n Finally, let\'s verify that bases are preserved upon serialisation:\n \n-    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(model.schema)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema based-on="plone.supermodel.tests.IBase">\n         <field name="description" type="zope.schema.Text">\n@@ -397,13 +397,12 @@ default schema above is unrelated to the one in the metadata schema.\n     >>> model.schema.getTaggedValue(FIELDSETS_KEY)\n     [<Fieldset \'dates\' order 1 of publication_date, expiry_date, notification_date>]\n \n-    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)\n+    >>> model.schemata[u\'metadata\'].getTaggedValue(FIELDSETS_KEY)\n     [<Fieldset \'standard\' order 9999 of creator>, <Fieldset \'dates\' order 9999 of created>, <Fieldset \'author\' order 9999 of >]\n \n-When we serialise a schema with fieldsets, fields will be grouped by\n-fieldset.\n+When we serialise a schema with fieldsets, fields will be grouped by fieldset.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -472,8 +471,8 @@ a dotted name for the invariant function.\n     >>> model.schema.getTaggedValue(\'invariants\')\n     [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]\n \n-When invariants are checked for our model.schema, we\'ll see our invariant\n-in action.\n+When invariants are checked for our model.schema, we\'ll see our invariant in\n+action.\n \n     >>> model.schema.validateInvariants(object())\n     Traceback (most recent call last):\n@@ -482,7 +481,7 @@ in action.\n \n The model\'s serialization should include the invariant.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <invariant>plone.supermodel.tests.dummy_invariant</invariant>\n@@ -526,9 +525,9 @@ or we won\'t accept them.\n Internationalization\n --------------------\n \n-Translation domains and message ids can be specified for text\n-that is interpreted as unicode. This will result in deserialization\n-as a zope.i18nmessageid message id rather than a basic Unicode string::\n+Translation domains and message ids can be specified for text that is\n+interpreted as unicode. This will result in deserialization as a\n+zope.i18nmessageid message id rather than a basic Unicode string::\n \n     >>> schema = """\\\n     ... <?xml version="1.0" encoding="UTF-8"?>\n@@ -555,13 +554,13 @@ as a zope.i18nmessageid message id rather than a basic Unicode string::\n     ... """\n     >>> model = loadString(schema)\n     >>> msgid = model.schema[\'title\'].title\n-    >>> msgid\n-    u\'supermodel_test_title\'\n+    >>> msgid == u\'supermodel_test_title\'\n+    True\n     >>> type(msgid)\n     <... \'zope.i18nmessageid.message.Message\'>\n-    >>> msgid.default\n-    u\'Title\'\n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> msgid.default == u\'Title\'\n+    True\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -610,17 +609,17 @@ may expect to be able to parse a format like this:\n We can register schema and field metadata handlers as named utilities.\n Metadata handlers should be able to reciprocally read and write metadata.\n \n-    >>> from zope.interface import implements\n+    >>> from zope.interface import implementer\n     >>> from zope.component import provideUtility\n \n     >>> from plone.supermodel.interfaces import ISchemaMetadataHandler\n     >>> from plone.supermodel.utils import ns\n \n-    >>> class FormLayoutMetadata(object):\n-    ...     implements(ISchemaMetadataHandler)\n+    >>> @implementer(ISchemaMetadataHandler)\n+    ... class FormLayoutMetadata(object):\n     ...\n-    ...     namespace = "http://namespaces.acme.com/ui"\n-    ...     prefix = "ui"\n+    ...     namespace = \'http://namespaces.acme.com/ui\'\n+    ...     prefix = \'ui\'\n     ...\n     ...     def read(self, schemaNode, schema):\n     ...         layout = schemaNode.get(ns(\'layout\', self.namespace))\n@@ -635,11 +634,11 @@ Metadata handlers should be able to reciprocally read and write metadata.\n     >>> provideUtility(component=FormLayoutMetadata(), name=\'acme.ui.schema\')\n \n     >>> from plone.supermodel.interfaces import IFieldMetadataHandler\n-    >>> class FieldWidgetMetadata(object):\n-    ...     implements(IFieldMetadataHandler)\n+    >>> @implementer(IFieldMetadataHandler)\n+    ... class FieldWidgetMetadata(object):\n     ...\n-    ...     namespace = "http://namespaces.acme.com/ui"\n-    ...     prefix = "ui"\n+    ...     namespace = \'http://namespaces.acme.com/ui\'\n+    ...     prefix = \'ui\'\n     ...\n     ...     def read(self, fieldNode, schema, field):\n     ...         name = field.__name__\n@@ -671,7 +670,7 @@ and each field, respectively.\n Of course, we can also serialize the schema back to XML. Here, the \'prefix\'\n set in the utility (if any) will be used by default.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema ui:layout="horizontal">\n         <field name="title" type="zope.schema.TextLine" ui:widget="largetype">\ndiff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst\nindex a909c7e..66dee60 100644\n--- a/plone/supermodel/schemaclass.rst\n+++ b/plone/supermodel/schemaclass.rst\n@@ -4,28 +4,32 @@ plone.supermodel: SchemaClass\n \n     >>> from plone.supermodel.model import Schema, SchemaClass\n     >>> from plone.supermodel import interfaces\n-    >>> from zope.interface import Interface, implements\n-    >>> from zope.component import adapts, provideAdapter\n+    >>> from zope.interface import Interface, implementer\n+    >>> from zope.component import adapter, provideAdapter\n \n Schema plugins are registered as named adapters. They may optionally contain\n an order attribute, which defaults to 0.\n \n-    >>> class TestPlugin(object):\n-    ...     adapts(interfaces.ISchema)\n-    ...     implements(interfaces.ISchemaPlugin)\n+    >>> adapter_calls = []\n+    >>> @implementer(interfaces.ISchemaPlugin)\n+    ... @adapter(interfaces.ISchema)\n+    ... class TestPlugin(object):\n+    ...\n     ...     order = 1\n     ...     def __init__(self, schema):\n     ...         self.schema = schema\n     ...     def __call__(self):\n-    ...         print("%s: %r" % (self.__class__.__name__, self.schema))\n+    ...         adapter_calls.append(\n+    ...             (self.__class__.__name__,self.schema.__name__))\n     ...\n     >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")\n \n Schema plugins are executed at schema declaration.\n \n-    >>> class IA(Schema):\n+    >>> class IA(Schema):  # doctest: +ELLIPSIS\n     ...     pass\n-    TestPlugin: <SchemaClass __builtin__.IA>\n+    >>> adapter_calls == [(\'TestPlugin\', \'IA\')]\n+    True\n \n Any class descending from Schema becomes an instance of SchemaClass and has any\n schema plugins called.\n@@ -35,35 +39,50 @@ https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this\n inheritance only works if the *first* base class is an instance of SchemaClass.\n So below I\'ve commented out the output that we hope for once that issue is\n resolved.\n+Somehow the issue got solved when using python 3, so we need to check python\n+version to get expected results here.\n \n+    >>> import six\n     >>> class ISomeInterface(Interface):\n     ...     pass\n \n+    >>> adapter_calls = []\n     >>> class IB(ISomeInterface, IA):\n     ...     pass\n+    >>> adapter_calls == ([] if six.PY2 else [(\'TestPlugin\', \'IB\')])\n+    True\n \n-#    TestPlugin: <SchemaClass __builtin__.IB>\n-\n+    >>> adapter_calls = []\n     >>> class IC(IB):\n     ...     pass\n-\n-#    TestPlugin: <SchemaClass __builtin__.IC>\n+    >>> adapter_calls == ([] if six.PY2 else [(\'TestPlugin\', \'IC\')])\n+    True\n \n To support the registration of schema plugins in ZCML, plugins are\n additionally executed at zope.configuration time with a ZCML order of 1000. To\n simulate this we will define another adapter and call the configuration action\n directly.\n \n+    >>> adapter_calls = []\n     >>> class TestPlugin2(TestPlugin):\n     ...     order = 0\n \n     >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")\n     >>> from plone.supermodel.model import finalizeSchemas\n-    >>> finalizeSchemas(IA)\n-    TestPlugin2: <SchemaClass __builtin__.IA>\n-    TestPlugin: <SchemaClass __builtin__.IA>\n \n-#    TestPlugin2: <SchemaClass __builtin__.IB>\n-#    TestPlugin: <SchemaClass __builtin__.IB>\n-#    TestPlugin2: <SchemaClass __builtin__.IC>\n-#    TestPlugin: <SchemaClass __builtin__.IC>\n+    >>> finalizeSchemas(IA)\n+    >>> adapter_calls == (\n+    ...     [\n+    ...         (\'TestPlugin2\', \'IA\'),\n+    ...         (\'TestPlugin\', \'IA\'),\n+    ...     ] if six.PY2 else [\n+    ...         (\'TestPlugin2\', \'IA\'),\n+    ...         (\'TestPlugin\', \'IA\'),\n+    ...         (\'TestPlugin2\', \'IB\'),\n+    ...         (\'TestPlugin\', \'IB\'),\n+    ...         (\'TestPlugin2\', \'IC\'),\n+    ...         (\'TestPlugin\', \'IC\'),\n+    ...     ]\n+    ... )\n+    True\n+    >>> adapter_calls = []\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 46d8b5c..75f3c4b 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -4,7 +4,8 @@\n from plone.supermodel.exportimport import ChoiceHandler\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IInvariant\n-from six.moves import cStringIO as StringIO\n+from six import BytesIO\n+from six import StringIO\n from zope import schema\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -18,13 +19,15 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n import doctest\n+import re\n+import six\n import unittest\n import zope.component.testing\n \n \n def configure():\n     zope.component.testing.setUp()\n-    configuration = """\\\n+    configuration = u"""\\\n     <configure\n          xmlns="http://namespaces.zope.org/zope"\n          i18n_domain="plone.supermodel.tests">\n@@ -332,7 +335,7 @@ class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n         IBase1.setTaggedValue(u"foo", {1: 1, 2: 1})      # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3}) # least specific of the bases\n+        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n         ISchema.setTaggedValue(u"foo", {4: 4, 5: 4})      # most specific\n \n         self.assertEqual({1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, u"foo"))\n@@ -346,8 +349,8 @@ def setUp(self):\n     tearDown = zope.component.testing.tearDown\n \n     def _assertSerialized(self, field, value, expected):\n-        element = utils.valueToElement(field, value, \'value\')\n-        sio = StringIO()\n+        element = utils.valueToElement(field, value, b\'value\')\n+        sio = StringIO() if six.PY2 else BytesIO()\n         etree.ElementTree(element).write(sio)\n         self.assertEqual(sio.getvalue(), expected)\n         unserialized = utils.elementToValue(field, element)\n@@ -356,57 +359,58 @@ def _assertSerialized(self, field, value, expected):\n     def test_lists(self):\n         field = schema.List(value_type=schema.Int())\n         value = []\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = [1, 2]\n-        self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element>1</element>\'\n-            \'<element>2</element>\'\n-            \'</value>\'\n-            )\n+        self._assertSerialized(\n+            field, value,\n+            b\'<value>\'\n+            b\'<element>1</element>\'\n+            b\'<element>2</element>\'\n+            b\'</value>\'\n+        )\n \n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = [[1], [1, 2], []]\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element><element>1</element></element>\'\n-            \'<element><element>1</element><element>2</element></element>\'\n-            \'<element/>\'\n-            \'</value>\'\n-            )\n+            b\'<value>\'\n+            b\'<element><element>1</element></element>\'\n+            b\'<element><element>1</element><element>2</element></element>\'\n+            b\'<element/>\'\n+            b\'</value>\'\n+        )\n \n     def test_dicts(self):\n         field = schema.Dict(key_type=schema.Int(), value_type=schema.TextLine())\n         value = {}\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = {1: \'one\', 2: \'two\'}\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element key="1">one</element>\'\n-            \'<element key="2">two</element>\'\n-            \'</value>\'\n-            )\n+            b\'<value>\'\n+            b\'<element key="1">one</element>\'\n+            b\'<element key="2">two</element>\'\n+            b\'</value>\'\n+        )\n \n     def test_nested_dicts(self):\n         field = schema.Dict(key_type=schema.Int(),\n             value_type=schema.Dict(\n                 key_type=schema.Int(),\n                 value_type=schema.TextLine(),\n-                ),\n-            )\n+            ),\n+        )\n         value = {}\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = {1: {2: \'two\'}, 3: {4: \'four\', 5: \'five\'}, 6: {}}\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element key="1"><element key="2">two</element></element>\'\n-            \'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n-            \'<element key="6"/>\'\n-            \'</value>\'\n-            )\n+            b\'<value>\'\n+            b\'<element key="1"><element key="2">two</element></element>\'\n+            b\'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n+            b\'<element key="6"/>\'\n+            b\'</value>\'\n+        )\n \n \n class TestChoiceHandling(unittest.TestCase):\n@@ -469,17 +473,18 @@ def _choice_with_term_titles_and_ns(self):\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def test_choice_serialized(self):\n-        field, expected = self._choice()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n-        # now with an empty string term in vocab:\n-        field, expected = self._choice_with_empty()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n-        # now with terms that have titles:\n-        field, expected = self._choice_with_term_titles()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n+        """ Tests a regular choice, one with empty string term in vocab,\n+        and another with terms that have titles\n+        """\n+        choice = self._choice()\n+        choice_with_empty = self._choice_with_empty()\n+        choice_with_term_titles = self._choice_with_term_titles()\n+        for case in (choice, choice_with_empty, choice_with_term_titles):\n+            field, expected = case\n+            expected = six.binary_type(expected) if six.PY2 \\\n+                else six.binary_type(expected, encoding=\'latin-1\')\n+            el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n+            self.assertEquals(etree.tostring(el), expected)\n \n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n@@ -493,35 +498,68 @@ def _termvalues(vocab):\n         for field, expected in cases:\n             el = etree.fromstring(expected)\n             imported_field = self.handler.read(el)\n-            self.assertEquals(\n+            self.assertEqual(\n                 _termvalues(imported_field.vocabulary),\n                 _termvalues(field.vocabulary),\n             )\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub(\n+                \'plone.supermodel.parser.SupermodelParseError\',\n+                \'SupermodelParseError\', got)\n+            got = re.sub(\n+                \'zope.interface.exceptions.Invalid\',\n+                \'Invalid\', got)\n+            got = re.sub(\n+                "(Import|ModuleNotFound)Error: No module named "\n+                "\'plone.supermodel.tests.nonExistentFactory\'; "\n+                "\'plone.supermodel.tests\' is not a package",\n+                \'ImportError: No module named nonExistentFactory\', got)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n+optionflags = doctest.ELLIPSIS | \\\n+    doctest.REPORT_UDIFF | \\\n+    doctest.NORMALIZE_WHITESPACE | \\\n+    doctest.REPORT_ONLY_FIRST_FAILURE\n+\n+\n def test_suite():\n     return unittest.TestSuite((\n         unittest.makeSuite(TestUtils),\n         unittest.makeSuite(TestValueToElement),\n         unittest.makeSuite(TestChoiceHandling),\n         doctest.DocFileSuite(\n-            \'schema.rst\',\n+            \'fields.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS),\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'fields.rst\',\n+            \'directives.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS),\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'schemaclass.rst\',\n+            \'schema.rst\',\n             setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown),\n+            tearDown=zope.component.testing.tearDown,\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'directives.rst\',\n+            \'schemaclass.rst\',\n             setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown),\n+            tearDown=zope.component.testing.tearDown,\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n     ))\n \n \ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 246bde1..bbca1d0 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -13,7 +13,6 @@\n from zope.schema.interfaces import IDict\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n-from zope.schema.interfaces import IVocabularyFactory\n \n import os.path\n import re\n@@ -23,7 +22,7 @@\n \n try:\n     from collections import OrderedDict\n-except:\n+except ImportError:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n \n@@ -35,7 +34,7 @@ def ns(name, prefix=XML_NAMESPACE):\n     """Return the element or attribute name with the given prefix\n     """\n \n-    return u"{%s}%s" % (prefix, name)\n+    return u\'{%s}%s\' % (prefix, name)\n \n \n def noNS(name):\n@@ -46,15 +45,16 @@ def noNS(name):\n \n def indent(node, level=0):\n \n-    node_indent = level * "  "\n-    child_indent = (level + 1) * "  "\n+    INDENT_SIZE = 2\n+    node_indent = level * (\' \' * INDENT_SIZE)\n+    child_indent = (level + 1) * (\' \' * INDENT_SIZE)\n \n     # node has childen\n     if len(node):\n \n         # add indent before first child node\n         if not node.text or not node.text.strip():\n-            node.text = "\\n" + child_indent\n+            node.text = \'\\n\' + child_indent\n \n         # let each child indent itself\n         last_idx = len(node) - 1\n@@ -64,16 +64,19 @@ def indent(node, level=0):\n             # add a tail for the next child node...\n             if idx != last_idx:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = "\\n" + child_indent\n+                    child.tail = \'\\n\' + child_indent\n             # ... or for the closing element of this node\n             else:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = "\\n" + node_indent\n+                    child.tail = \'\\n\' + node_indent\n \n \n def prettyXML(tree):\n     indent(tree)\n-    return etree.tostring(tree)\n+    xml = etree.tostring(tree)\n+    if six.PY2:\n+        return xml\n+    return xml.decode()\n \n \n def fieldTypecast(field, value):\n@@ -100,7 +103,6 @@ def elementToValue(field, element, default=_marker):\n     If not, the field will be adapted to this interface to obtain a converter.\n     """\n     value = default\n-\n     if IDict.providedBy(field):\n         key_converter = IFromUnicode(field.key_type)\n         value = OrderedDict()\n@@ -109,7 +111,7 @@ def elementToValue(field, element, default=_marker):\n                 continue\n             parseinfo.stack.append(child)\n \n-            key_text = child.attrib.get(\'key\', None)\n+            key_text = child.attrib.get(\'key\')\n             if key_text is None:\n                 k = None\n             else:\n@@ -153,10 +155,15 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            value = converter.fromUnicode(six.text_type(text))\n+            if isinstance(text, six.binary_type):\n+                text = text.decode()\n+            else:\n+                text = six.text_type(text)\n+            value = converter.fromUnicode(text)\n \n         # handle i18n\n-        if isinstance(value, six.text_type) and parseinfo.i18n_domain is not None:\n+        if isinstance(value, six.string_types) and \\\n+                parseinfo.i18n_domain is not None:\n             translate_attr = ns(\'translate\', I18N_NAMESPACE)\n             domain_attr = ns(\'domain\', I18N_NAMESPACE)\n             msgid = element.attrib.get(translate_attr)\n@@ -189,14 +196,16 @@ def valueToElement(field, value, name=None, force=False):\n \n         if IDict.providedBy(field):\n             key_converter = IToUnicode(field.key_type)\n-            for k, v in value.items():\n-                list_element = valueToElement(field.value_type, v, \'element\', force)\n+            for k, v in sorted(value.items()):\n+                list_element = valueToElement(\n+                    field.value_type, v, \'element\', force)\n                 list_element.attrib[\'key\'] = key_converter.toUnicode(k)\n                 child.append(list_element)\n \n         elif ICollection.providedBy(field):\n             for v in value:\n-                list_element = valueToElement(field.value_type, v, \'element\', force)\n+                list_element = valueToElement(\n+                    field.value_type, v, \'element\', force)\n                 child.append(list_element)\n \n         else:\ndiff --git a/setup.py b/setup.py\nindex 74f3ffa..c17c840 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -27,6 +27,8 @@ def read(*rnames):\n         "Framework :: Plone :: 5.1",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.5",\n+        "Programming Language :: Python :: 3.6",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n'

